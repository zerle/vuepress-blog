<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器灵魂之问 | 张垒的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="记录好的技术文档">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.06cff2a7.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.5d9f3e6e.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/7.52cd3cfd.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.5e77f0d2.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/1.c3e4b76d.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/34.5977256e.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.fce7151c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.665820a8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.1cfbcfc6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.06542fc4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.5a7a423b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.d2f8beac.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.3366a66f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.a0f84501.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.8cf233fc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.d142c8ff.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.3f0558f8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.7f170fad.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.ca3d8f1b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.e8704ed0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.ea2f5a39.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.87921c42.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.f31d39ff.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.5c2c99a1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.eff7fee9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.b375e77b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.e44aa03f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.82fe56b9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.c7707b2a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.7648c433.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.0d04e6fc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.f85a8b69.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.a49efe7f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.98053ef4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.15d7a48b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.2ed1c6b3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.665e6da9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.bba66369.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.0102712f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.fc0cf83d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.b24876fd.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.999a2df2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.5cfca3d0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.d70d2f6c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/49.80d9cea6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.fb9624e5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/50.ca82dac4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/51.a6b49e93.js"><link rel="prefetch" href="/vuepress-blog/assets/js/52.7f08f076.js"><link rel="prefetch" href="/vuepress-blog/assets/js/53.2a888b74.js"><link rel="prefetch" href="/vuepress-blog/assets/js/54.b39c22d6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/55.a9a9bc24.js"><link rel="prefetch" href="/vuepress-blog/assets/js/56.c9ba9d63.js"><link rel="prefetch" href="/vuepress-blog/assets/js/57.af85ad1c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/58.b21e620f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/59.604943d3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.09f6a933.js"><link rel="prefetch" href="/vuepress-blog/assets/js/60.d0b6fce9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/61.54065b41.js"><link rel="prefetch" href="/vuepress-blog/assets/js/62.f0028e7f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/63.195ddca5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/64.761c82aa.js"><link rel="prefetch" href="/vuepress-blog/assets/js/65.6002006f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/66.97ef0021.js"><link rel="prefetch" href="/vuepress-blog/assets/js/67.ac085f10.js"><link rel="prefetch" href="/vuepress-blog/assets/js/68.e3587494.js"><link rel="prefetch" href="/vuepress-blog/assets/js/69.22b18dd6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/70.017b9424.js"><link rel="prefetch" href="/vuepress-blog/assets/js/71.1c39dd94.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.0899600d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.1f42c771.js"><link rel="prefetch" href="/vuepress-blog/assets/js/vendors~docsearch.680926dd.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.06cff2a7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>张垒的博客</h3> <p class="description" data-v-59e6cb88>记录好的技术文档</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">张垒的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/vuepress-blogme.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>33</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>31</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>浏览器灵魂之问</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">浏览器灵魂之问</h1> <div data-v-8a445198><!----> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2020/10/25</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>浏览器</span></i></div></div> <div class="theme-reco-content content__default"><p>作为一个合格的前端工程师，浏览器相关的工作原理是我们进行性能优化的基石,必须牢牢掌握才能面对瞬息万变的实际场景，针对性地给出实际方案，而不是背诵各种开发军规和性能优化的条例，这样很难发现真正的问题所在, 更无法真正地解决问题。</p> <h1 id="第1篇-能不能说一说浏览器缓存"><a href="#第1篇-能不能说一说浏览器缓存" class="header-anchor">#</a> 第1篇: 能不能说一说浏览器缓存?</h1> <p>缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：</p> <ul><li>强缓存</li> <li>协商缓存</li> <li>缓存位置</li></ul> <h2 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h2> <p>浏览器中的缓存作用分为两种情况，一种是需要发送<font color="#ff502c">HTTP</font>请求，一种是不需要发送。
首先是检查强缓存，这个阶段<font color="#ff502c">不需要</font>发送HTTP请求。
如何来检查呢？通过相应的字段来进行，但是说起这个字段就有点门道了。
在<font color="#ff502c">HTTP/1.0</font>和<font color="#ff502c">HTTP/1.1</font>当中，这个字段是不一样的。在早期，也就是HTTP/1.0时期，使用的是Expires，而HTTP/1.1使用的是Cache-Control。让我们首先来看看Expires。</p> <h3 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h3> <p><font color="#ff502c">Expires</font>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    Expires: Wed, <span class="token number">22</span> Nov <span class="token number">2019</span> 08:41:00 GMT
</code></pre></div><p>表示资源在<font color="#ff502c">2019年11月22号8点41分</font>过期，过期了就得向服务端发请求。</p> <p>这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。</p> <h3 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h3> <p>在HTTP1.1中，采用了一个非常关键的字段：<font color="#ff502c">Cache-Control</font>。这个字段也是存在于</p> <p>它和<font color="#ff502c">Expires</font>本质的不同在于它并没有采用<font color="#ff502c">具体的过期时间点</font>这个方式，而是采用过期时长来控制缓存，对应的字段是max-age。比如这个例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    Cache-Control:max-age<span class="token operator">=</span><span class="token number">3600</span>
</code></pre></div><p>代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。
如果你觉得它只有<font color="#ff502c">max-age</font>一个属性的话，那就大错特错了。
它其实可以组合非常多的指令，完成更多场景的缓存判断, 将一些关键的属性列举如下:
public: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的<font color="#ff502c">代理服务器</font>最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。
private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入<font color="#ff502c">协商缓存阶段</font>。
no-store：非常粗暴，不进行任何形式的缓存。
s-maxage：这和<font color="#ff502c">max-age</font>长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。
值得注意的是，当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。
当然，还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——协商缓存了。</p> <h2 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h2> <p>强缓存失效之后，浏览器在请求头中携带相应的<font color="#ff502c">缓存tag</font>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。
具体来说，这样的缓存tag分为两种: Last-Modified 和 ETag。这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存的两个 tag 不一样。</p> <h3 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h3> <p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。
浏览器接收到后，如果再次请求，会在请求头中携带<font color="#ff502c">If-Modified-Since</font>字段，这个字段的值也就是服务器传来的最后修改时间。
服务器拿到请求头中的<font color="#ff502c">If-Modified-Since</font>的字段后，其实会和这个服务器中<font color="#ff502c">该资源的最后修改时间</font>对比:</p> <p>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
否则返回304，告诉浏览器直接用缓存。</p> <h3 id="etag"><a href="#etag" class="header-anchor">#</a> ETag</h3> <p><font color="#ff502c">ETag</font>是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过<font color="#ff502c">响应头</font>把这个值给浏览器。
浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。
服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:</p> <p>如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
否则返回304，告诉浏览器直接用缓存。</p> <h3 id="两者对比"><a href="#两者对比" class="header-anchor">#</a> 两者对比</h3> <p>在精准度上，ETag优于Last-Modified。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:</p> <p>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</p> <p>在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。</p> <p>另外，如果两种方式都支持的话，服务器会优先考虑ETag。</p> <h2 id="缓存位置"><a href="#缓存位置" class="header-anchor">#</a> 缓存位置</h2> <p>前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？
浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p> <ul><li>Service Worker</li> <li>Memory Cache</li> <li>Disk Cache</li> <li>Push Cache</li></ul> <h3 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h3> <p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。
Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍</p> <h3 id="memory-cache-和-disk-cache"><a href="#memory-cache-和-disk-cache" class="header-anchor">#</a> Memory Cache 和 Disk Cache</h3> <p>[Memory Cache]指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。
[Disk Cache]就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。
好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p> <ul><li>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存</li> <li>内存使用率比较高的时候，文件优先进入磁盘</li></ul> <h3 id="push-cache"><a href="#push-cache" class="header-anchor">#</a> Push Cache</h3> <p>即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。关于 Push Cache，有非常多的内容可以挖掘，不过这已经不是本文的重点，大家可以参考这篇<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener noreferrer">扩展文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>对浏览器的缓存机制来做个简要的总结:
首先通过<font color="#ff502c">Cache-Control</font>验证强缓存是否可用</p> <ul><li>如果强缓存可用，直接使用</li> <li>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的<font color="#ff502c">If-Modified-Since</font>或者<font color="#ff502c">If-None-Match</font>字段检查资源是否更新
<ul><li>若资源更新，返回资源和200状态码</li></ul> <ul><li>否则，返回304，告诉浏览器直接从缓存获取资源</li></ul></li></ul> <h1 id="第2篇-能不能说一说浏览器的本地存储-各自优劣如何"><a href="#第2篇-能不能说一说浏览器的本地存储-各自优劣如何" class="header-anchor">#</a> 第2篇: 能不能说一说浏览器的本地存储？各自优劣如何？</h1> <p>浏览器的本地存储主要分为<font color="#ff502c">Cookie</font>、<font color="#ff502c">WebStorage</font>和<font color="#ff502c">IndexedDB</font>, 其中<font color="#ff502c">WebStorage</font>又可以分为<font color="#ff502c">localStorage</font>和<font color="#ff502c">sessionStorage</font>。接下来我们就来一一分析这些本地存储方案。</p> <h2 id="cookie"><a href="#cookie" class="header-anchor">#</a> Cookie</h2> <p>Cookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足。
HTTP 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？
这种背景下，就产生了 Cookie.
Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。
Cookie 的作用很好理解，就是用来做状态存储的，但它也是有诸多致命的缺陷的：</p> <p>1.容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。</p> <p>2.性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。</p> <p>3.安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</p> <h2 id="localstorage"><a href="#localstorage" class="header-anchor">#</a> localStorage</h2> <h3 id="和cookie异同"><a href="#和cookie异同" class="header-anchor">#</a> 和Cookie异同</h3> <p>localStorage有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage。
不过它相对Cookie还是有相当多的区别的:</p> <p>1.容量。localStorage 的容量上限为5M，相比于Cookie的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。</p> <p>2.只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。</p> <p>3.接口封装。通过localStorage暴露在全局，并通过它的 setItem 和 getItem等方法进行操作，非常方便。</p> <h3 id="操作方式"><a href="#操作方式" class="header-anchor">#</a> 操作方式</h3> <p>接下来我们来具体看看如何来操作localStorage。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    <span class="token builtin class-name">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name: <span class="token string">&quot;sanyuan&quot;</span>, age: <span class="token number">18</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    localStorage.setItem<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;sanyuan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    localStorage.setItem<span class="token punctuation">(</span><span class="token string">&quot;info&quot;</span>, JSON.stringify<span class="token punctuation">(</span>obj<span class="token punctuation">))</span><span class="token punctuation">;</span>
</code></pre></div><p>接着进入相同的域名时就能拿到相应的值:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    <span class="token builtin class-name">let</span> name <span class="token operator">=</span> localStorage.getItem<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin class-name">let</span> info <span class="token operator">=</span> JSON.parse<span class="token punctuation">(</span>localStorage.getItem<span class="token punctuation">(</span><span class="token string">&quot;info&quot;</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
</code></pre></div><p>从这里可以看出，localStorage其实存储的都是字符串，如果是存储对象需要调用JSON的stringify方法，并且用JSON.parse来解析成对象。</p> <h3 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h3> <p>利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源，比如官网的logo，存储Base64格式的图片资源，因此利用localStorage</p> <h2 id="sessionstorage"><a href="#sessionstorage" class="header-anchor">#</a> sessionStorage</h2> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <p>sessionStorage以下方面和localStorage一致:</p> <ul><li>容量。容量上限也为 5M。</li> <li>只存在客户端，默认不参与与服务端的通信。</li> <li>接口封装。除了sessionStorage名字有所变化，存储方式、操作方式均和localStorage一样。</li></ul> <p>但sessionStorage和localStorage有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分sessionStorage就不复存在了。</p> <h3 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> 应用场景</h3> <p>1.可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
2.可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage就再合适不过了。事实上微博就采取了这样的存储方式。</p> <h2 id="indexeddb"><a href="#indexeddb" class="header-anchor">#</a> IndexedDB</h2> <p>IndexedDB是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。
关于它的使用，本文侧重原理，而且 MDN 上的教程文档已经非常详尽，这里就不做赘述了，感兴趣可以看一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB" target="_blank" rel="noopener noreferrer">使用文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。
接着我们来分析一下IndexedDB的一些重要特性，除了拥有数据库本身的特性，比如支持事务，存储二进制数据，还有这样一些特性需要格外注意：</p> <p>1.键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。
2.异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
3.受同源策略限制，即无法访问跨域的数据库。</p> <h2 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h2> <p>浏览器中各种本地存储和缓存技术的发展，给前端应用带来了大量的机会，PWA 也正是依托了这些优秀的存储方案才得以发展起来。重新梳理一下这些本地存储方案:</p> <p>1.<font color="#ff502c">cookie</font>并不适合存储，而且存在非常多的缺陷。
2.<font color="#ff502c">Web Storage</font>包括<font color="#ff502c">localStorage和</font><font color="#ff502c">sessionStorage</font>, 默认不会参与和服务器的通信。
3.<font color="#ff502c">IndexedDB</font>为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。</p> <h1 id="第3篇-说一说从输入url到页面呈现发生了什么-网络篇"><a href="#第3篇-说一说从输入url到页面呈现发生了什么-网络篇" class="header-anchor">#</a> 第3篇: 说一说从输入URL到页面呈现发生了什么？——网络篇</h1> <p>这是一个可以无限难的问题。出这个题目的目的就是为了考察你的 web 基础深入到什么程度。由于水平和篇幅有限，在这里我将把其中一些重要的过程给大家梳理一遍，相信能在绝大部分的情况下给出一个比较惊艳的答案。
这里我提前声明，由于是一个综合性非常强的问题，可能会在某一个点上深挖出非常多的细节，我个人觉得学习是一个循序渐进的过程，在明白了整体过程后再去自己研究这些细节，会对整个知识体系有更深的理解。同时，关于延申出来的细节点我都有参考资料，看完这篇之后不妨再去深入学习一下，扩展知识面。
好，正题开始。
此时此刻，你在浏览器地址栏输入了百度的网址:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    https://www.baidu.com/
</code></pre></div><h2 id="网络请求"><a href="#网络请求" class="header-anchor">#</a> 网络请求</h2> <h3 id="_1-构建请求"><a href="#_1-构建请求" class="header-anchor">#</a> 1. 构建请求</h3> <p>浏览器会构建请求行:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    // 请求方法是GET，路径为根路径，HTTP协议版本为1.1
    GET / HTTP/1.1
</code></pre></div><h3 id="_2-查找强缓存"><a href="#_2-查找强缓存" class="header-anchor">#</a> 2. 查找强缓存</h3> <p>先检查强缓存，如果命中直接使用，否则进入下一步。关于强缓存，如果不清楚可以参考上一篇文章。</p> <h3 id="_3-dns解析"><a href="#_3-dns解析" class="header-anchor">#</a> 3. DNS解析</h3> <p>由于我们输入的是域名，而数据包是通过IP地址传给对方的。因此我们需要得到域名对应的IP地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做DNS（域名系统）。得到具体 IP 的过程就是DNS解析。
当然，值得注意的是，浏览器提供了DNS数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS解析。
另外，如果不指定端口的话，默认采用对应的 IP 的 80 端口。</p> <h3 id="_4-建立-tcp-连接"><a href="#_4-建立-tcp-连接" class="header-anchor">#</a> 4. 建立 TCP 连接</h3> <p>这里要提醒一点，Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待。</p> <p>假设现在不需要等待，我们进入了 TCP 连接的建立阶段。首先解释一下什么是 TCP:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
</code></pre></div><p>建立 TCP连接经历了下面三个阶段:</p> <p>1.通过三次握手(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。
2.进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。
3.断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。</p> <p>读到这里，你应该明白 TCP 连接通过什么手段来保证数据传输的可靠性，一是三次握手确认连接，二是数据包校验保证数据到达接收方，三是通过四次挥手断开连接。
当然，如果再深入地问，比如为什么要三次握手，两次不行吗？第三次握手失败了怎么办？为什么要四次挥手等等这一系列的问题，涉及计算机网络的基础知识，比较底层，但是也是非常重要的细节，希望你能好好研究一下，另外这里有一篇不错的文章，<a href="https://zhuanlan.zhihu.com/p/86426969" target="_blank" rel="noopener noreferrer">点击进入相应的推荐文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，相信这篇文章能给你启发。</p> <h3 id="_5-发送-http-请求"><a href="#_5-发送-http-请求" class="header-anchor">#</a> 5.发送 HTTP 请求</h3> <p>现在TCP连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:请求行、请求头和请求体。</p> <p>首先，浏览器会向服务器发送请求行,关于请求行， 我们在这一部分的第一步就构建完了，贴一下内容:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    // 请求方法是GET，路径为根路径，HTTP协议版本为1.1
    GET / HTTP/1.1
</code></pre></div><p>结构很简单，由请求方法、请求URI和HTTP版本协议组成。
同时也要带上请求头，比如我们之前说的Cache-Control、If-Modified-Since、If-None-Match都由可能被放入请求头中作为缓存的标识信息。当然了还有一些其他的属性，列举如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    Accept: text/html,application/xhtml+xml,application/xml<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.9</span>,image/webp,image/apng,*/*<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.8</span>,application/signed-exchange<span class="token punctuation">;</span><span class="token assign-left variable">v</span><span class="token operator">=</span>b3
    Accept-Encoding: gzip, deflate, br
    Accept-Language: zh-CN,zh<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.9</span>
    Cache-Control: no-cache
    Connection: keep-alive
    Cookie: /* 省略cookie信息 */
    Host: www.baidu.com
    Pragma: no-cache
    Upgrade-Insecure-Requests: <span class="token number">1</span>
    User-Agent: Mozilla/5.0 <span class="token punctuation">(</span>iPhone<span class="token punctuation">;</span> CPU iPhone OS 11_0 like Mac OS X<span class="token punctuation">)</span> AppleWebKit/604.1.38 <span class="token punctuation">(</span>KHTML, like Gecko<span class="token punctuation">)</span> Version/11.0 Mobile/15A372 Safari/604.1
</code></pre></div><p>最后是请求体，请求体只有在POST方法下存在，常见的场景是表单提交。</p> <h2 id="网络响应"><a href="#网络响应" class="header-anchor">#</a> 网络响应</h2> <p>HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。</p> <p>跟请求部分类似，网络响应具有三个部分:响应行、响应头和响应体。</p> <p>响应行类似下面这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    HTTP/1.1 <span class="token number">200</span> OK
</code></pre></div><p>由HTTP协议版本、状态码和状态描述组成。</p> <p>响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。</p> <p>举例如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    Cache-Control: no-cache
    Connection: keep-alive
    Content-Encoding: <span class="token function">gzip</span>
    Content-Type: text/html<span class="token punctuation">;</span><span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
    Date: Wed, 04 Dec <span class="token number">2019</span> <span class="token number">12</span>:29:13 GMT
    Server: apache
    Set-Cookie: <span class="token assign-left variable">rsv_i</span><span class="token operator">=</span>f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXby4wXKT8Au8O7ZT9UuMsBq2k<span class="token punctuation">;</span> <span class="token assign-left variable">path</span><span class="token operator">=</span>/<span class="token punctuation">;</span> <span class="token assign-left variable">domain</span><span class="token operator">=</span>.baidu.com
</code></pre></div><p>响应完成之后怎么办？TCP 连接就断开了吗？
不一定。这时候要判断Connection字段, 如果请求头或响应头中包含Connection: Keep-Alive，表示建立了持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。
否则断开TCP连接, 请求-响应流程结束。</p> <h2 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结</h2> <p>到此，我们来总结一下主要内容，也就是浏览器端的网络请求过程：</p> <p><img src="/vuepress-blogassets/img/01.c6764517.png" alt=""></p> <h1 id="第4篇-说一说从输入url到页面呈现发生了什么-解析算法篇"><a href="#第4篇-说一说从输入url到页面呈现发生了什么-解析算法篇" class="header-anchor">#</a> 第4篇: 说一说从输入URL到页面呈现发生了什么？——解析算法篇</h1> <p>完成了网络请求和响应，如果响应头中Content-Type的值是text/html，那么接下来就是浏览器的解析和渲染工作了。</p> <p>首先来介绍解析部分，主要分为以下几个步骤:</p> <ul><li>构建 DOM树</li> <li>样式计算</li> <li>生成布局树(Layout Tree)</li></ul> <h2 id="构建-dom-树"><a href="#构建-dom-树" class="header-anchor">#</a> 构建 DOM 树</h2> <p>由于浏览器无法直接理解HTML字符串，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是DOM树。DOM树本质上是一个以document为根节点的多叉树。</p> <p>那通过什么样的方式来进行解析呢？</p> <h3 id="html文法的本质"><a href="#html文法的本质" class="header-anchor">#</a> HTML文法的本质</h3> <p>首先，我们应该清楚把握一点: HTML 的文法并不是上下文无关文法。</p> <p>这里，有必要讨论一下什么是上下文无关文法。</p> <p>在计算机科学的编译原理学科中，有非常明确的定义:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    若一个形式文法G <span class="token operator">=</span> <span class="token punctuation">(</span>N, Σ, P, S<span class="token punctuation">)</span> 的产生式规则都取如下的形式：V-<span class="token operator">&gt;</span>w，则叫上下文无关语法。其中 V∈N ，w∈<span class="token punctuation">(</span>N∪Σ<span class="token punctuation">)</span>* 。
</code></pre></div><p>其中把 G = (N, Σ, P, S) 中各个参量的意义解释一下:</p> <p>1.N 是非终结符(顾名思义，就是说最后一个符号不是它, 下面同理)集合。
2.Σ 是终结符集合。
3.P 是开始符，它必须属于 N ，也就是非终结符。
4.S 就是不同的产生式的集合。如 S -&gt; aSb 等等。</p> <p>通俗一点讲，上下文无关的文法就是说这个文法中所有产生式的左边都是一个非终结符。</p> <p>看到这里，如果还有一点懵圈，我举个例子你就明白了。</p> <p>比如:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    A -<span class="token operator">&gt;</span> B
</code></pre></div><p>这个文法中，每个产生式左边都会有一个非终结符，这就是上下文无关的文法。在这种情况下，xBy一定是可以规约出xAy的。</p> <p>我们下面看看看一个反例：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    aA -<span class="token operator">&gt;</span> B
    Aa -<span class="token operator">&gt;</span> B
</code></pre></div><p>这种情况就是不是上下文无关的文法，当遇到B的时候，我们不知道到底能不能规约出A，取决于左边或者右边是否有a存在，也就是说和上下文有关。
关于它为什么是非上下文无关文法，首先需要让大家注意的是，规范的 HTML 语法，是符合上下文无关文法的，能够体现它非上下文无关的是不标准的语法。在此我仅举一个反例即可证明。
比如解析器扫描到form标签的时候，上下文无关文法的处理方式是直接创建对应 form 的 DOM 对象，而真实的 HTML5 场景中却不是这样，解析器会查看 form 的上下文，如果这个 form 标签的父标签也是 form, 那么直接跳过当前的 form 标签，否则才创建 DOM 对象。
常规的编程语言都是上下文无关的，而HTML却相反，也正是它非上下文无关的特性，决定了HTML Parser并不能使用常规编程语言的解析器来完成，需要另辟蹊径。</p> <h3 id="解析算法"><a href="#解析算法" class="header-anchor">#</a> 解析算法</h3> <p>HTML5 规范详细地介绍了解析算法。这个算法分为两个阶段:</p> <p>1.标记化。
2.建树。
对应的两个过程就是词法分析和语法分析。</p> <h4 id="标记化算法"><a href="#标记化算法" class="header-anchor">#</a> 标记化算法</h4> <p>这个算法输入为HTML文本，输出为HTML标记，也成为标记生成器。其中运用有限自动状态机来完成。即在当当前状态下，接收一个或多个字符，就会更新到下一个状态。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
    Hello sanyuan
  <span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>
</code></pre></div><p>通过一个简单的例子来演示一下标记化的过程。
遇到&lt;, 状态为标记打开。
接收[a-z]的字符，会进入标记名称状态。
这个状态一直保持，直到遇到&gt;，表示标记名称记录完成，这时候变为数据状态。
接下来遇到body标签做同样的处理。
这个时候html和body的标记都记录好了。
现在来到&lt;body&gt;中的&gt;，进入数据状态，之后保持这样状态接收后面的字符hello sanyuan。
接着接收 &lt;/body&gt; 中的&lt;，回到标记打开, 接收下一个/后，这时候会创建一个end tag的token。
随后进入标记名称状态, 遇到&gt;回到数据状态。
接着以同样的样式处理 &lt;/body&gt;。</p> <h4 id="建树算法"><a href="#建树算法" class="header-anchor">#</a> 建树算法</h4> <p>之前提到过，DOM 树是一个以document为根节点的多叉树。因此解析器首先会创建一个document对象。标记生成器会把每个标记的信息发送给建树器。建树器接收到相应的标记时，会创建对应的 DOM 对象。创建这个DOM对象后会做两件事情:</p> <p>将DOM对象加入 DOM 树中。
将对应标记压入存放开放(与闭合标签意思对应)元素的栈中。</p> <p>还是拿下面这个例子说:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
    Hello sanyuan
  <span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>
</code></pre></div><p>首先，状态为初始化状态。
接收到标记生成器传来的html标签，这时候状态变为before html状态。同时创建一个HTMLHtmlElement的 DOM 元素, 将其加到document根对象上，并进行压栈操作。
接着状态自动变为before head, 此时从标记生成器那边传来body，表示并没有head, 这时候建树器会自动创建一个HTMLHeadElement并将其加入到DOM树中。
现在进入到in head状态, 然后直接跳到after head。
现在标记生成器传来了body标记，创建HTMLBodyElement, 插入到DOM树中，同时压入开放标记栈。
接着状态变为in body，然后来接收后面一系列的字符: Hello sanyuan。接收到第一个字符的时候，会创建一个Text节点并把字符插入其中，然后把Text节点插入到 DOM 树中body元素的下面。随着不断接收后面的字符，这些字符会附在Text节点上。
现在，标记生成器传过来一个body的结束标记，进入到after body状态。
标记生成器最后传过来一个html的结束标记, 进入到after after body的状态，表示解析过程到此结束。</p> <h4 id="容错机制"><a href="#容错机制" class="header-anchor">#</a> 容错机制</h4> <p>讲到HTML5规范，就不得不说它强大的宽容策略, 容错能力非常强，虽然大家褒贬不一，不过我想作为一名资深的前端工程师，有必要知道HTML Parser在容错方面做了哪些事情。
接下来是 WebKit 中一些经典的容错示例，发现有其他的也欢迎来补充。</p> <p>1.使用&lt;/br&gt;而不是&lt;br&gt;</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>t-<span class="token operator">&gt;</span>isCloseTag<span class="token punctuation">(</span>brTag<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> m_document-<span class="token operator">&gt;</span>inCompatMode<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>
  reportError<span class="token punctuation">(</span>MalformedBRError<span class="token punctuation">)</span><span class="token punctuation">;</span>
  t-<span class="token operator">&gt;</span>beginTag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>全部换为&lt;br&gt;的形式。</p> <p>2.表格离散</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>table<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>table<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>tr<span class="token operator">&gt;</span><span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>inner table<span class="token operator">&lt;</span>/td<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/tr<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>/table<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>tr<span class="token operator">&gt;</span><span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>outer table<span class="token operator">&lt;</span>/td<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/tr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/table<span class="token operator">&gt;</span>
</code></pre></div><p>WebKit会自动转换为:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>table<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>tr<span class="token operator">&gt;</span><span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>outer table<span class="token operator">&lt;</span>/td<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/tr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/table<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>table<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>tr<span class="token operator">&gt;</span><span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>inner table<span class="token operator">&lt;</span>/td<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/tr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/table<span class="token operator">&gt;</span>
</code></pre></div><p>3.表单元素嵌套</p> <p>这时候直接忽略里面的form。</p> <h2 id="样式计算"><a href="#样式计算" class="header-anchor">#</a> 样式计算</h2> <p>关于CSS样式，它的来源一般是三种:</p> <p>1.link标签引用
2.style标签中的样式
3.元素的内嵌style属性</p> <h3 id="格式化样式表"><a href="#格式化样式表" class="header-anchor">#</a> 格式化样式表</h3> <p>首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即styleSheets。
这个格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了。
在浏览器控制台能够通过document.styleSheets来查看这个最终的结构。当然，这个结构包含了以上三种CSS来源，为后面的样式操作提供了基础。</p> <h3 id="标准化样式属性"><a href="#标准化样式属性" class="header-anchor">#</a> 标准化样式属性</h3> <p>有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如em-&gt;px,red-&gt;#ff0000,bold-&gt;700等等。</p> <h3 id="计算每个节点的具体样式"><a href="#计算每个节点的具体样式" class="header-anchor">#</a> 计算每个节点的具体样式</h3> <p>样式已经被格式化和标准化,接下来就可以计算每个节点的具体样式信息了。
其实计算的方式也并不复杂，主要就是两个规则: 继承和层叠。
每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式。这就是继承规则，非常容易理解。
然后是层叠规则，CSS 最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果，甚至有很多诡异的层叠现象，看过《CSS世界》的同学应该对此深有体会，具体的层叠规则属于深入 CSS 语言的范畴，这里就不过多介绍了。
不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到window.getComputedStyle当中，也就是可以通过JS来获取计算后的样式，非常方便。</p> <h2 id="生成布局树"><a href="#生成布局树" class="header-anchor">#</a> 生成布局树</h2> <p>现在已经生成了DOM树和DOM样式，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一棵布局树(Layout Tree)。
布局树生成的大致工作如下:</p> <p>1.遍历生成的 DOM 树节点，并把他们添加到布局树中。
2.计算布局树节点的坐标位置。</p> <p>值得注意的是，这棵布局树值包含可见元素，对于 head标签和设置了display: none的元素，将不会被放入其中。</p> <p>有人说首先会生成Render Tree，也就是渲染树，其实这还是 16 年之前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成Render Tree的过程了。而布局树的信息已经非常完善，完全拥有Render Tree的功能。</p> <p>之所以不讲布局的细节，是因为它过于复杂，一一介绍会显得文章过于臃肿，不过大部分情况下我们只需要知道它所做的工作是什么即可，如果想深入其中的原理，知道它是如何来做的，我强烈推荐你去读一读人人FED团队的文章<a href="https://www.rrfed.com/2017/02/26/chrome-layout/" target="_blank" rel="noopener noreferrer">从Chrome源码看浏览器如何layout布局<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="总结-4"><a href="#总结-4" class="header-anchor">#</a> 总结</h2> <p>梳理一下这一节的主要脉络:</p> <p><img src="/vuepress-blogassets/img/02.145420f5.png" alt=""></p> <h1 id="第5篇-说一说从输入url到页面呈现发生了什么-渲染过程篇"><a href="#第5篇-说一说从输入url到页面呈现发生了什么-渲染过程篇" class="header-anchor">#</a> 第5篇: 说一说从输入URL到页面呈现发生了什么？——渲染过程篇</h1> <p>上一节介绍了浏览器解析的过程,其中包含构建DOM、样式计算和构建布局树。</p> <p>接下来就来拆解下一个过程——渲染。分为以下几个步骤:</p> <ul><li>建立图层树(Layer Tree)</li> <li>生成绘制列表</li> <li>生成图块并栅格化</li> <li>显示器显示内容</li></ul> <h2 id="一、建图层树"><a href="#一、建图层树" class="header-anchor">#</a> 一、建图层树</h2> <p>如果你觉得现在DOM节点也有了，样式和位置信息也都有了，可以开始绘制页面了，那你就错了。
因为你考虑掉了另外一些复杂的场景，比如3D动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等。
为了解决如上所述的问题，浏览器在构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树(Layer Tree)。
那这棵图层树是根据什么来构建的呢？
一般情况下，节点的图层会默认属于父亲节点的图层(这些图层也称为合成层)。那什么时候会提升为一个单独的合成层呢？
有两种情况需要分别讨论，一种是显式合成，一种是隐式合成。</p> <h3 id="显式合成"><a href="#显式合成" class="header-anchor">#</a> 显式合成</h3> <p>下面是显式合成的情况:</p> <p>一、 拥有层叠上下文的节点。</p> <p>层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:</p> <p>1.HTML根元素本身就具有层叠上下文。
2.普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文。
3.元素的 opacity 值不是 1
4.元素的 transform 值不是 none
5.元素的 filter 值不是 none
6.元素的 isolation 值是isolate
7.will-change指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)</p> <p>二、需要剪裁的地方。</p> <p>比如一个div，你只给他设置 100 * 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。</p> <h3 id="隐式合成"><a href="#隐式合成" class="header-anchor">#</a> 隐式合成</h3> <p>接下来是隐式合成，简单来说就是层叠等级低的节点被提升为单独的图层之后，那么所有层叠等级比它高的节点都会成为一个单独的图层。
这个隐式合成其实隐藏着巨大的风险，如果在一个大型应用中，当一个z-index比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是层爆炸的原理。这里有一个具体的例子，<a href="https://segmentfault.com/a/1190000014520786" target="_blank" rel="noopener noreferrer">点击打开<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>值得注意的是，当需要repaint时，只需要repaint本身，而不会影响到其他的层。</p> <h2 id="二、生成绘制列表"><a href="#二、生成绘制列表" class="header-anchor">#</a> 二、生成绘制列表</h2> <p>接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。
这里我以百度首页为例，大家可以在 Chrome 开发者工具中在设置栏中展开 more tools, 然后选择Layers面板，就能看到下面的绘制列表:</p> <p><img src="/vuepress-blogassets/img/03.52c0b1da.png" alt=""></p> <h2 id="三、生成图块和生成位图"><a href="#三、生成图块和生成位图" class="header-anchor">#</a> 三、生成图块和生成位图</h2> <p>现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫合成线程。
绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候啦。
首先，考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将图层分块。这些块的大小一般不会特别大，通常是 256  256 或者 512  512 这个规格。这样可以大大加速页面的首屏展示。
因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。
顺便提醒一点，渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据。
然后合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图。
生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程。</p> <h2 id="四、显示器显示内容"><a href="#四、显示器显示内容" class="header-anchor">#</a> 四、显示器显示内容</h2> <p>栅格化操作完成后，合成线程会生成一个绘制命令，即&quot;DrawQuad&quot;，并发送给浏览器进程。
浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。
无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。
看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。</p> <h2 id="总结-5"><a href="#总结-5" class="header-anchor">#</a> 总结</h2> <p>到这里，我们算是把整个过程给走通了，现在重新来梳理一下页面渲染的流程。</p> <p><img src="/vuepress-blogassets/img/04.90d35186.png" alt=""></p> <h1 id="第6篇-谈谈你对重绘和回流的理解"><a href="#第6篇-谈谈你对重绘和回流的理解" class="header-anchor">#</a> 第6篇: 谈谈你对重绘和回流的理解</h1> <p>我们首先来回顾一下渲染流水线的流程:</p> <p><img src="/vuepress-blogassets/img/05.cb78408f.png" alt=""></p> <p>接下来，我们将来以此为依据来介绍重绘和回流，以及让更新视图的另外一种方式——合成。</p> <h2 id="回流"><a href="#回流" class="header-anchor">#</a> 回流</h2> <p>首先介绍回流。回流也叫重排。</p> <h3 id="触发条件"><a href="#触发条件" class="header-anchor">#</a> 触发条件</h3> <p>简单来说，就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流的过程。
具体一点，有以下的操作会触发回流:</p> <p>1.一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解。</p> <p>2.使 DOM 节点发生增减或者移动。</p> <p>3.读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。</p> <p>4.调用 window.getComputedStyle 方法。</p> <h3 id="回流过程"><a href="#回流过程" class="header-anchor">#</a> 回流过程</h3> <p>依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。</p> <p><img src="/vuepress-blogassets/img/06.315d55be.png" alt=""></p> <p>相当于将解析和合成的过程重新又走了一篇，开销是非常大的。</p> <h2 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h2> <h3 id="触发条件-2"><a href="#触发条件-2" class="header-anchor">#</a> 触发条件</h3> <p>当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。</p> <h3 id="重绘过程"><a href="#重绘过程" class="header-anchor">#</a> 重绘过程</h3> <p>由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。流程如下：</p> <p><img src="data:image/png;base64,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" alt=""></p> <p>跳过了生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。</p> <p>可以看到，重绘不一定导致回流，但回流一定发生了重绘。</p> <h2 id="合成"><a href="#合成" class="header-anchor">#</a> 合成</h2> <p>还有一种情况，是直接合成。比如利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。</p> <h3 id="gpu加速的原因"><a href="#gpu加速的原因" class="header-anchor">#</a> GPU加速的原因</h3> <p>在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处:</p> <p>1.能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。</p> <p>2.没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。</p> <h2 id="实践意义"><a href="#实践意义" class="header-anchor">#</a> 实践意义</h2> <p>知道上面的原理之后，对于开发过程有什么指导意义呢？</p> <p>1.避免频繁使用 style，而是采用修改class的方式。
2.使用createDocumentFragment进行批量的 DOM 操作。
3.对于 resize、scroll 等进行防抖/节流处理。
4.添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。这里有一个实际的例子，一行will-change: tranform拯救一个项目，<a href="https://juejin.im/post/6844903966573068301" target="_blank" rel="noopener noreferrer">点击直达<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h1 id="第7篇-能不能说一说xss攻击"><a href="#第7篇-能不能说一说xss攻击" class="header-anchor">#</a> 第7篇: 能不能说一说XSS攻击？</h1> <h2 id="什么是-xss-攻击"><a href="#什么是-xss-攻击" class="header-anchor">#</a> 什么是 XSS 攻击？</h2> <p>XSS 全称是 Cross Site Scripting(即跨站脚本)，为了和 CSS 区分，故叫它XSS。XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。
这些操作一般可以完成下面这些事情:</p> <p>1.窃取Cookie。
2.监听用户行为，比如输入账号密码后直接发送到黑客服务器。
3.修改 DOM 伪造登录表单。
4.在页面中生成浮窗广告。</p> <p>通常情况，XSS 攻击的实现有三种方式——存储型、反射型和文档型。原理都比较简单，先来一一介绍一下。</p> <h3 id="存储型"><a href="#存储型" class="header-anchor">#</a> 存储型</h3> <p>存储型，顾名思义就是将恶意脚本存储了起来，确实，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。
常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中直接执行, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击。</p> <h3 id="反射型"><a href="#反射型" class="header-anchor">#</a> 反射型</h3> <p>反射型XSS指的是恶意脚本作为网络请求的一部分。
比如我输入:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    http://sanyuan.com?q<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>alert<span class="token punctuation">(</span><span class="token string">&quot;你完蛋了&quot;</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span>
</code></pre></div><p>这杨，在服务器端会拿到q参数,然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。
之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。</p> <h3 id="文档型"><a href="#文档型" class="header-anchor">#</a> 文档型</h3> <p>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！
这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。</p> <h2 id="防范措施"><a href="#防范措施" class="header-anchor">#</a> 防范措施</h2> <p>明白了三种XSS攻击的原理，我们能发现一个共同点: 都是让恶意脚本直接能在浏览器中执行。</p> <p>那么要防范它，就是要避免这些脚本代码的执行。</p> <p>为了完成这一点，必须做到一个信念，两个利用。</p> <h3 id="一个信念"><a href="#一个信念" class="header-anchor">#</a> 一个信念</h3> <p>千万不要相信任何用户的输入！</p> <p>无论是在前端和服务端，都要对用户的输入进行转码或者过滤。</p> <p>如:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>alert<span class="token punctuation">(</span><span class="token string">'你完蛋了'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span>
</code></pre></div><p>转码后变为:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>script<span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>alert<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment">#39;你完蛋了&amp;#39;)&amp;lt;/script&amp;gt;</span>
</code></pre></div><p>这样的代码在 html 解析的过程中是无法执行的。</p> <p>当然也可以利用关键词过滤的方式，将 script 标签给删除。那么现在的内容只剩下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>
</code></pre></div><p>什么也没有了:）</p> <h3 id="利用-csp"><a href="#利用-csp" class="header-anchor">#</a> 利用 CSP</h3> <p>CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能:</p> <p>限制其他域下的资源加载。
禁止向其它域提交数据。
提供上报机制，能帮助我们及时发现 XSS 攻击。</p> <h3 id="利用-httponly"><a href="#利用-httponly" class="header-anchor">#</a> 利用 HttpOnly</h3> <p>很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。</p> <p>##总结</p> <p>XSS 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括:</p> <p>一个信念: 不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。
两个利用: 利用 CSP，利用 Cookie 的 HttpOnly 属性。</p> <h1 id="第8篇-能不能说一说csrf攻击"><a href="#第8篇-能不能说一说csrf攻击" class="header-anchor">#</a> 第8篇: 能不能说一说CSRF攻击？</h1> <h2 id="什么是csrf攻击"><a href="#什么是csrf攻击" class="header-anchor">#</a> 什么是CSRF攻击？</h2> <p>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。
举个例子, 你在某个论坛点击了黑客精心挑选的小姐姐图片，你点击后，进入了一个新的页面。
那么恭喜你，被攻击了:）
你可能会比较好奇，怎么突然就被攻击了呢？接下来我们就来拆解一下当你点击了链接之后，黑客在背后做了哪些事情。
可能会做三样事情。列举如下：</p> <h3 id="_1-自动发-get-请求"><a href="#_1-自动发-get-请求" class="header-anchor">#</a> 1.自动发 GET 请求</h3> <p>黑客网页里面可能有一段这样的代码:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    <span class="token operator">&lt;</span>img <span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token string">&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;</span><span class="token operator">&gt;</span>
</code></pre></div><p>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。
假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。</p> <h3 id="_2-自动发-post-请求"><a href="#_2-自动发-post-请求" class="header-anchor">#</a> 2.自动发 POST 请求</h3> <p>黑客可能自己填了一个表单，写了一段自动提交的脚本。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>form <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">'hacker-form'</span> <span class="token assign-left variable">action</span><span class="token operator">=</span><span class="token string">&quot;https://xxx.com/info&quot;</span> <span class="token assign-left variable">method</span><span class="token operator">=</span><span class="token string">&quot;POST&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>input <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">&quot;hidden&quot;</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;user&quot;</span> <span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token string">&quot;hhh&quot;</span> /<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>input <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">&quot;hidden&quot;</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;count&quot;</span> <span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token string">&quot;100&quot;</span> /<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/form<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>document.getElementById<span class="token punctuation">(</span><span class="token string">'hacker-form'</span><span class="token punctuation">)</span>.submit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span>
</code></pre></div><p>同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。</p> <h3 id="_3-诱导点击发送-get-请求"><a href="#_3-诱导点击发送-get-请求" class="header-anchor">#</a> 3.诱导点击发送 GET 请求</h3> <p>在黑客的网站上，可能会放上一个链接，驱使你来点击:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>a <span class="token assign-left variable">href</span><span class="token operator">=</span><span class="token string">&quot;https://xxx/info?user=hhh&amp;count=100&quot;</span> <span class="token assign-left variable">taget</span><span class="token operator">=</span><span class="token string">&quot;_blank&quot;</span><span class="token operator">&gt;</span>点击进入修仙世界<span class="token operator">&lt;</span>/a<span class="token operator">&gt;</span>
</code></pre></div><p>点击后，自动发送 get 请求，接下来和自动发 GET 请求部分同理。
这就是CSRF攻击的原理。和XSS攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的html文档中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登录状态来模拟用户进行操作。</p> <h2 id="防范措施-2"><a href="#防范措施-2" class="header-anchor">#</a> 防范措施</h2> <h3 id="_1-利用cookie的samesite属性"><a href="#_1-利用cookie的samesite属性" class="header-anchor">#</a> 1.利用Cookie的SameSite属性</h3> <p>CSRF攻击中重要的一环就是自动发送目标站点下的 Cookie,然后就是这一份 Cookie 模拟了用户的身份。因此在Cookie上面下文章是防范的不二之选。
恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是SameSite。
SameSite可以设置为三个值，Strict、Lax和None。
a. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。
b. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
c. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。</p> <h3 id="_2-验证来源站点"><a href="#_2-验证来源站点" class="header-anchor">#</a> 2.验证来源站点</h3> <p>这就需要要用到请求头中的两个字段: Origin和Referer。
其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。
当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。</p> <h3 id="_3-csrf-token"><a href="#_3-csrf-token" class="header-anchor">#</a> 3.CSRF Token</h3> <p>Django作为 Python 的一门后端框架，如果是用它开发过的同学就知道，在它的模板(template)中, 开发表单时，经常会附上这样一行代码:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    <span class="token punctuation">{</span>% csrf_token %<span class="token punctuation">}</span>
</code></pre></div><p>这就是CSRF Token的典型应用。那它的原理是怎样的呢？
首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。
然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。</p> <h2 id="总结-6"><a href="#总结-6" class="header-anchor">#</a> 总结</h2> <p>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。
CSRF攻击一般会有三种方式:</p> <ul><li>自动 GET 请求</li> <li>自动 POST 请求</li> <li>诱导点击发送 GET 请求。</li></ul> <p>防范措施: 利用 Cookie 的 SameSite 属性、验证来源站点和CSRF Token。</p> <h1 id="第9篇-https为什么让数据传输更安全"><a href="#第9篇-https为什么让数据传输更安全" class="header-anchor">#</a> 第9篇:HTTPS为什么让数据传输更安全？</h1> <p>谈到HTTPS, 就不得不谈到与之相对的HTTP。HTTP的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过WIFI路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的中间人攻击。
为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。
HTTPS并不是一个新的协议, 而是一个加强版的HTTP。其原理是在HTTP和TCP之间建立了一个中间层，当HTTP和TCP通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给TCP, 响应的，TCP必须将数据包解密，才能传给上面的HTTP。这个中间层也叫安全层。安全层的核心就是对数据加解密。
接下来我们就来剖析一下HTTPS的加解密是如何实现的。</p> <h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="header-anchor">#</a> 对称加密和非对称加密</h2> <p>###概念</p> <p>首先需要理解对称加密和非对称加密的概念，然后讨论两者应用后的效果如何。
对称加密是最简单的方式，指的是加密和解密用的是同样的密钥。
而对于非对称加密，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。</p> <h3 id="加解密过程"><a href="#加解密过程" class="header-anchor">#</a> 加解密过程</h3> <p>接着我们来谈谈浏览器和服务器进行协商加解密的过程。
首先，浏览器会给服务器发送一个随机数client_random和一个加密的方法列表。
服务器接收后给浏览器返回另一个随机数server_random和加密方法。
现在，两者拥有三样相同的凭证: client_random、server_random和加密方法。
接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号。</p> <h3 id="各自应用的效果"><a href="#各自应用的效果" class="header-anchor">#</a> 各自应用的效果</h3> <p>如果用对称加密的方式，那么第三方可以在中间获取到client_random、server_random和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。
既然对称加密这么不堪一击，我们就来试一试非对称加密。在这种加密方式中，服务器手里有两把钥匙，一把是公钥，也就是说每个人都能拿到，是公开的，另一把是私钥，这把私钥只有服务器自己知道。
好，现在开始传输。
浏览器把client_random和加密方法列表传过来，服务器接收到，把server_random、加密方法和公钥传给浏览器。
现在两者拥有相同的client_random、server_random和加密方法。然后浏览器用公钥将client_random和server_random加密，生成与服务器通信的暗号。
这时候由于是非对称加密，公钥加密过的数据只能用私钥解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。
这难道一定就安全吗？聪明的小伙伴早就发现了端倪。回到非对称加密的定义，公钥加密的数据可以用私钥解密，那私钥加密的数据也可以用公钥解密呀！
服务器的数据只能用私钥进行加密(因为如果它用公钥那么浏览器也没法解密啦)，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的，因此我们暂且不采用这种方案。</p> <p>##对称加密和非对称加密的结合</p> <p>可以发现，对称加密和非对称加密，单独应用任何一个，都会存在安全隐患。那我们能不能把两者结合，进一步保证安全呢？
其实是可以的，演示一下整个流程：</p> <p>1.浏览器向服务器发送client_random和加密方法列表。
2.服务器接收到，返回server_random、加密方法以及公钥。
3.浏览器接收，接着生成另一个随机数pre_random, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)
4.服务器用私钥解密这个被加密后的pre_random。</p> <p>现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。
然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。
这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而拿不到pre_random，也就无法生成最终的密钥了。
回头比较一下和单纯的使用非对称加密, 这种方式做了什么改进呢？本质上是防止了私钥加密的数据外传。单独使用非对称加密，最大的漏洞在于服务器传数据给浏览器只能用私钥加密，这是危险产生的根源。利用对称和非对称加密结合的方式，就防止了这一点，从而保证了安全。</p> <p>##添加数字证书</p> <p>尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。
事实上HTTPS在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。</p> <h3 id="传输过程"><a href="#传输过程" class="header-anchor">#</a> 传输过程</h3> <p>为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫CA(Certificate Authority), 认证通过后 CA 会给服务器颁发数字证书。
这个数字证书有两个作用:</p> <p>服务器向浏览器证明自己的身份。
把公钥传给浏览器。</p> <p>这个验证的过程发生在什么时候呢？
当服务器传送server_random、加密方法的时候，顺便会带上数字证书(包含了公钥), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。</p> <p>现在我们来梳理一下HTTPS最终的加解密过程:</p> <p><img src="/vuepress-blogassets/img/08.89f25f8c.png" alt=""></p> <h3 id="认证过程"><a href="#认证过程" class="header-anchor">#</a> 认证过程</h3> <p>浏览器拿到数字证书后，如何来对证书进行认证呢？
首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 Hash 函数，来这个函数来计算明文内容得到信息A，然后用公钥解密明文内容得到信息B，两份信息做比对，一致则表示认证合法。
当然有时候对于浏览器而言，它不知道哪些 CA 是值得信任的，因此会继续查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性。一般根级的 CA 会内置在操作系统当中，当然如果向上找没有找到根级的 CA，那么将被视为不合法。</p> <h2 id="总结-7"><a href="#总结-7" class="header-anchor">#</a> 总结</h2> <p>HTTPS并不是一个新的协议, 它在HTTP和TCP的传输中建立了一个安全层，利用对称加密和非对称加密结合数字证书认证的方式，让传输过程的安全性大大提高。</p> <h1 id="第10篇-能不能实现事件的防抖和节流"><a href="#第10篇-能不能实现事件的防抖和节流" class="header-anchor">#</a> 第10篇: 能不能实现事件的防抖和节流？</h1> <h2 id="节流"><a href="#节流" class="header-anchor">#</a> 节流</h2> <p>节流的核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。这就好比公交车，10 分钟一趟，10 分钟内有多少人在公交站等我不管，10 分钟一到我就要发车走人！</p> <p>代码如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> throttle<span class="token punctuation">(</span>fn, interval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token builtin class-name">return</span> function<span class="token punctuation">(</span><span class="token punctuation">..</span>.args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> context <span class="token operator">=</span> this<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      fn.apply<span class="token punctuation">(</span>context, args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>, interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>写成下面的方式也是表达一样的意思:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const throttle <span class="token operator">=</span> function<span class="token punctuation">(</span>fn, interval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token builtin class-name">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> context <span class="token operator">=</span> this<span class="token punctuation">;</span>
    <span class="token builtin class-name">let</span> now <span class="token operator">=</span> +new Date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    // 还没到时间
    if<span class="token punctuation">(</span>now - last <span class="token operator">&lt;</span> interval<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
    last <span class="token operator">=</span> now<span class="token punctuation">;</span>
    fn.apply<span class="token punctuation">(</span>this, args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="防抖"><a href="#防抖" class="header-anchor">#</a> 防抖</h2> <p>核心思想: 每次事件触发则删除原来的定时器，建立新的定时器。跟王者荣耀的回城功能类似，你反复触发回城功能，那么只认最后一次，从最后一次触发开始计时。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> debounce<span class="token punctuation">(</span>fn, delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> timer <span class="token operator">=</span> null<span class="token punctuation">;</span>
  <span class="token builtin class-name">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> context <span class="token operator">=</span> this<span class="token punctuation">;</span>
    if<span class="token punctuation">(</span>timer<span class="token punctuation">)</span> clearTimeout<span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer <span class="token operator">=</span> setTimeout<span class="token punctuation">(</span><span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fn.apply<span class="token punctuation">(</span>context, args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>, delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="双剑合璧-加强版节流"><a href="#双剑合璧-加强版节流" class="header-anchor">#</a> 双剑合璧——加强版节流</h2> <p>现在我们可以把防抖和节流放到一起，为什么呢？因为防抖有时候触发的太频繁会导致一次响应都没有，我们希望到了固定的时间必须给用户一个响应，事实上很多前端库就是采取了这样的思路。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> throttle<span class="token punctuation">(</span>fn, delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> last <span class="token operator">=</span> <span class="token number">0</span>, timer <span class="token operator">=</span> null<span class="token punctuation">;</span>
  <span class="token builtin class-name">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> context <span class="token operator">=</span> this<span class="token punctuation">;</span>
    <span class="token builtin class-name">let</span> now <span class="token operator">=</span> new Date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    if<span class="token punctuation">(</span>now - last <span class="token operator">&lt;</span> delay<span class="token punctuation">)</span><span class="token punctuation">{</span>
      clearTimeout<span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
      setTimeout<span class="token punctuation">(</span><span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        last <span class="token operator">=</span> now<span class="token punctuation">;</span>
        fn.apply<span class="token punctuation">(</span>context, args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>, delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      // 这个时候表示时间到了，必须给响应
      last <span class="token operator">=</span> now<span class="token punctuation">;</span>
      fn.apply<span class="token punctuation">(</span>context, args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="第11篇-能不能实现图片懒加载"><a href="#第11篇-能不能实现图片懒加载" class="header-anchor">#</a> 第11篇: 能不能实现图片懒加载？</h1> <h2 id="方案一-clientheight、scrolltop-和-offsettop"><a href="#方案一-clientheight、scrolltop-和-offsettop" class="header-anchor">#</a> 方案一:clientHeight、scrollTop 和 offsetTop</h2> <p>首先给图片一个占位资源:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>img <span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token string">&quot;default.jpg&quot;</span> data-src<span class="token operator">=</span><span class="token string">&quot;http://www.xxx.com/target.jpg&quot;</span> /<span class="token operator">&gt;</span>
</code></pre></div><p>接着，通过监听 scroll 事件来判断图片是否到达视口:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> img <span class="token operator">=</span> document.getElementsByTagName<span class="token punctuation">(</span><span class="token string">&quot;img&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> num <span class="token operator">=</span> img.length<span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>//计数器，从第一张图片开始计

lazyload<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//首次加载别忘了显示图片

window.addEventListener<span class="token punctuation">(</span><span class="token string">'scroll'</span>, lazyload<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function-name function">lazyload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> viewHeight <span class="token operator">=</span> document.documentElement.clientHeight<span class="token punctuation">;</span>//视口高度
  <span class="token builtin class-name">let</span> scrollTop <span class="token operator">=</span> document.documentElement.scrollTop <span class="token operator">||</span> document.body.scrollTop<span class="token punctuation">;</span>//滚动条卷去的高度
  for<span class="token punctuation">(</span>let i <span class="token operator">=</span> count<span class="token punctuation">;</span> i <span class="token operator">&lt;</span>num<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    // 元素现在已经出现在视口中
    if<span class="token punctuation">(</span>img<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.offsetTop <span class="token operator">&lt;</span> scrollHeight + viewHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      if<span class="token punctuation">(</span>img<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.getAttribute<span class="token punctuation">(</span><span class="token string">&quot;src&quot;</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token operator">=</span> <span class="token string">&quot;default.jpg&quot;</span><span class="token punctuation">)</span> <span class="token builtin class-name">continue</span><span class="token punctuation">;</span>
      img<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.src <span class="token operator">=</span> img<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.getAttribute<span class="token punctuation">(</span><span class="token string">&quot;data-src&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      count ++<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然，最好对 scroll 事件做节流处理，以免频繁触发:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// throttle函数我们上节已经实现
window.addEventListener<span class="token punctuation">(</span><span class="token string">'scroll'</span>, throttle<span class="token punctuation">(</span>lazyload, <span class="token number">200</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="方案二-getboundingclientrect"><a href="#方案二-getboundingclientrect" class="header-anchor">#</a> 方案二：getBoundingClientRect</h2> <p>现在我们用另外一种方式来判断图片是否出现在了当前视口, 即 DOM 元素的 getBoundingClientRect API。</p> <p>上述的 lazyload 函数改成下面这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> <span class="token function-name function">lazyload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  for<span class="token punctuation">(</span>let i <span class="token operator">=</span> count<span class="token punctuation">;</span> i <span class="token operator">&lt;</span>num<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    // 元素现在已经出现在视口中
    if<span class="token punctuation">(</span>img<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.getBoundingClientRect<span class="token punctuation">(</span><span class="token punctuation">)</span>.top <span class="token operator">&lt;</span> document.documentElement.clientHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      if<span class="token punctuation">(</span>img<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.getAttribute<span class="token punctuation">(</span><span class="token string">&quot;src&quot;</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token operator">=</span> <span class="token string">&quot;default.jpg&quot;</span><span class="token punctuation">)</span> <span class="token builtin class-name">continue</span><span class="token punctuation">;</span>
      img<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.src <span class="token operator">=</span> img<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.getAttribute<span class="token punctuation">(</span><span class="token string">&quot;data-src&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      count ++<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="方案三-intersectionobserver"><a href="#方案三-intersectionobserver" class="header-anchor">#</a> 方案三: IntersectionObserver</h2> <p>这是浏览器内置的一个API，实现了监听window的scroll事件、判断是否在视口中以及节流三大功能。</p> <p>我们来具体试一把：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> img <span class="token operator">=</span> document.getElementsByTagName<span class="token punctuation">(</span><span class="token string">&quot;img&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

const observer <span class="token operator">=</span> new IntersectionObserver<span class="token punctuation">(</span>changes <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  //changes 是被观察的元素集合
  for<span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span>, len <span class="token operator">=</span> changes.length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> change <span class="token operator">=</span> changes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    // 通过这个属性判断是否在视口中
    if<span class="token punctuation">(</span>change.isIntersecting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      const imgElement <span class="token operator">=</span> change.target<span class="token punctuation">;</span>
      imgElement.src <span class="token operator">=</span> imgElement.getAttribute<span class="token punctuation">(</span><span class="token string">&quot;data-src&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      observer.unobserve<span class="token punctuation">(</span>imgElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
Array.from<span class="token punctuation">(</span>img<span class="token punctuation">)</span>.forEach<span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">&gt;</span> observer.observe<span class="token punctuation">(</span>item<span class="token punctuation">))</span><span class="token punctuation">;</span>
</code></pre></div><p>这样就很方便地实现了图片懒加载，当然这个IntersectionObserver也可以用作其他资源的预加载，功能非常强大。</p> <p><font color="#ff502c">申明：此篇文章转载于</font><a href="https://juejin.im/post/6844904021308735502" target="_blank" rel="noopener noreferrer">此处<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><font color="#ff502c">，如有侵权，请联系删除，谢谢！</font></p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#强缓存" class="sidebar-link reco-side-强缓存" data-v-b57cc07c>强缓存</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#expires" class="sidebar-link reco-side-expires" data-v-b57cc07c>Expires</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#cache-control" class="sidebar-link reco-side-cache-control" data-v-b57cc07c>Cache-Control</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#协商缓存" class="sidebar-link reco-side-协商缓存" data-v-b57cc07c>协商缓存</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#last-modified" class="sidebar-link reco-side-last-modified" data-v-b57cc07c>Last-Modified</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#etag" class="sidebar-link reco-side-etag" data-v-b57cc07c>ETag</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#两者对比" class="sidebar-link reco-side-两者对比" data-v-b57cc07c>两者对比</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#缓存位置" class="sidebar-link reco-side-缓存位置" data-v-b57cc07c>缓存位置</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#service-worker" class="sidebar-link reco-side-service-worker" data-v-b57cc07c>Service Worker</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#memory-cache-和-disk-cache" class="sidebar-link reco-side-memory-cache-和-disk-cache" data-v-b57cc07c>Memory Cache 和 Disk Cache</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#push-cache" class="sidebar-link reco-side-push-cache" data-v-b57cc07c>Push Cache</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#总结" class="sidebar-link reco-side-总结" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#cookie" class="sidebar-link reco-side-cookie" data-v-b57cc07c>Cookie</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#localstorage" class="sidebar-link reco-side-localstorage" data-v-b57cc07c>localStorage</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#和cookie异同" class="sidebar-link reco-side-和cookie异同" data-v-b57cc07c>和Cookie异同</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#操作方式" class="sidebar-link reco-side-操作方式" data-v-b57cc07c>操作方式</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#应用场景" class="sidebar-link reco-side-应用场景" data-v-b57cc07c>应用场景</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#sessionstorage" class="sidebar-link reco-side-sessionstorage" data-v-b57cc07c>sessionStorage</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#特点" class="sidebar-link reco-side-特点" data-v-b57cc07c>特点</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#应用场景-2" class="sidebar-link reco-side-应用场景-2" data-v-b57cc07c>应用场景</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#indexeddb" class="sidebar-link reco-side-indexeddb" data-v-b57cc07c>IndexedDB</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#总结-2" class="sidebar-link reco-side-总结-2" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#网络请求" class="sidebar-link reco-side-网络请求" data-v-b57cc07c>网络请求</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_1-构建请求" class="sidebar-link reco-side-_1-构建请求" data-v-b57cc07c>1. 构建请求</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_2-查找强缓存" class="sidebar-link reco-side-_2-查找强缓存" data-v-b57cc07c>2. 查找强缓存</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_3-dns解析" class="sidebar-link reco-side-_3-dns解析" data-v-b57cc07c>3. DNS解析</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_4-建立-tcp-连接" class="sidebar-link reco-side-_4-建立-tcp-连接" data-v-b57cc07c>4. 建立 TCP 连接</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_5-发送-http-请求" class="sidebar-link reco-side-_5-发送-http-请求" data-v-b57cc07c>5.发送 HTTP 请求</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#网络响应" class="sidebar-link reco-side-网络响应" data-v-b57cc07c>网络响应</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#总结-3" class="sidebar-link reco-side-总结-3" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#构建-dom-树" class="sidebar-link reco-side-构建-dom-树" data-v-b57cc07c>构建 DOM 树</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#html文法的本质" class="sidebar-link reco-side-html文法的本质" data-v-b57cc07c>HTML文法的本质</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#解析算法" class="sidebar-link reco-side-解析算法" data-v-b57cc07c>解析算法</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#样式计算" class="sidebar-link reco-side-样式计算" data-v-b57cc07c>样式计算</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#格式化样式表" class="sidebar-link reco-side-格式化样式表" data-v-b57cc07c>格式化样式表</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#标准化样式属性" class="sidebar-link reco-side-标准化样式属性" data-v-b57cc07c>标准化样式属性</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#计算每个节点的具体样式" class="sidebar-link reco-side-计算每个节点的具体样式" data-v-b57cc07c>计算每个节点的具体样式</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#生成布局树" class="sidebar-link reco-side-生成布局树" data-v-b57cc07c>生成布局树</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#总结-4" class="sidebar-link reco-side-总结-4" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#一、建图层树" class="sidebar-link reco-side-一、建图层树" data-v-b57cc07c>一、建图层树</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#显式合成" class="sidebar-link reco-side-显式合成" data-v-b57cc07c>显式合成</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#隐式合成" class="sidebar-link reco-side-隐式合成" data-v-b57cc07c>隐式合成</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#二、生成绘制列表" class="sidebar-link reco-side-二、生成绘制列表" data-v-b57cc07c>二、生成绘制列表</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#三、生成图块和生成位图" class="sidebar-link reco-side-三、生成图块和生成位图" data-v-b57cc07c>三、生成图块和生成位图</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#四、显示器显示内容" class="sidebar-link reco-side-四、显示器显示内容" data-v-b57cc07c>四、显示器显示内容</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#总结-5" class="sidebar-link reco-side-总结-5" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#回流" class="sidebar-link reco-side-回流" data-v-b57cc07c>回流</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#触发条件" class="sidebar-link reco-side-触发条件" data-v-b57cc07c>触发条件</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#回流过程" class="sidebar-link reco-side-回流过程" data-v-b57cc07c>回流过程</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#重绘" class="sidebar-link reco-side-重绘" data-v-b57cc07c>重绘</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#触发条件-2" class="sidebar-link reco-side-触发条件-2" data-v-b57cc07c>触发条件</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#重绘过程" class="sidebar-link reco-side-重绘过程" data-v-b57cc07c>重绘过程</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#合成" class="sidebar-link reco-side-合成" data-v-b57cc07c>合成</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#gpu加速的原因" class="sidebar-link reco-side-gpu加速的原因" data-v-b57cc07c>GPU加速的原因</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#实践意义" class="sidebar-link reco-side-实践意义" data-v-b57cc07c>实践意义</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#什么是-xss-攻击" class="sidebar-link reco-side-什么是-xss-攻击" data-v-b57cc07c>什么是 XSS 攻击？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#存储型" class="sidebar-link reco-side-存储型" data-v-b57cc07c>存储型</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#反射型" class="sidebar-link reco-side-反射型" data-v-b57cc07c>反射型</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#文档型" class="sidebar-link reco-side-文档型" data-v-b57cc07c>文档型</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#防范措施" class="sidebar-link reco-side-防范措施" data-v-b57cc07c>防范措施</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#一个信念" class="sidebar-link reco-side-一个信念" data-v-b57cc07c>一个信念</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#利用-csp" class="sidebar-link reco-side-利用-csp" data-v-b57cc07c>利用 CSP</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#利用-httponly" class="sidebar-link reco-side-利用-httponly" data-v-b57cc07c>利用 HttpOnly</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#什么是csrf攻击" class="sidebar-link reco-side-什么是csrf攻击" data-v-b57cc07c>什么是CSRF攻击？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_1-自动发-get-请求" class="sidebar-link reco-side-_1-自动发-get-请求" data-v-b57cc07c>1.自动发 GET 请求</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_2-自动发-post-请求" class="sidebar-link reco-side-_2-自动发-post-请求" data-v-b57cc07c>2.自动发 POST 请求</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_3-诱导点击发送-get-请求" class="sidebar-link reco-side-_3-诱导点击发送-get-请求" data-v-b57cc07c>3.诱导点击发送 GET 请求</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#防范措施-2" class="sidebar-link reco-side-防范措施-2" data-v-b57cc07c>防范措施</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_1-利用cookie的samesite属性" class="sidebar-link reco-side-_1-利用cookie的samesite属性" data-v-b57cc07c>1.利用Cookie的SameSite属性</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_2-验证来源站点" class="sidebar-link reco-side-_2-验证来源站点" data-v-b57cc07c>2.验证来源站点</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#_3-csrf-token" class="sidebar-link reco-side-_3-csrf-token" data-v-b57cc07c>3.CSRF Token</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#总结-6" class="sidebar-link reco-side-总结-6" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#对称加密和非对称加密" class="sidebar-link reco-side-对称加密和非对称加密" data-v-b57cc07c>对称加密和非对称加密</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#加解密过程" class="sidebar-link reco-side-加解密过程" data-v-b57cc07c>加解密过程</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#各自应用的效果" class="sidebar-link reco-side-各自应用的效果" data-v-b57cc07c>各自应用的效果</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#传输过程" class="sidebar-link reco-side-传输过程" data-v-b57cc07c>传输过程</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#认证过程" class="sidebar-link reco-side-认证过程" data-v-b57cc07c>认证过程</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#总结-7" class="sidebar-link reco-side-总结-7" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#节流" class="sidebar-link reco-side-节流" data-v-b57cc07c>节流</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#防抖" class="sidebar-link reco-side-防抖" data-v-b57cc07c>防抖</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#双剑合璧-加强版节流" class="sidebar-link reco-side-双剑合璧-加强版节流" data-v-b57cc07c>双剑合璧——加强版节流</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#方案一-clientheight、scrolltop-和-offsettop" class="sidebar-link reco-side-方案一-clientheight、scrolltop-和-offsettop" data-v-b57cc07c>方案一:clientHeight、scrollTop 和 offsetTop</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#方案二-getboundingclientrect" class="sidebar-link reco-side-方案二-getboundingclientrect" data-v-b57cc07c>方案二：getBoundingClientRect</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/brower.html#方案三-intersectionobserver" class="sidebar-link reco-side-方案三-intersectionobserver" data-v-b57cc07c>方案三: IntersectionObserver</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/media/starsky.m4a" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:20px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/media/starsky.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/media/starsky.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>Star Sky</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>Two Steps From Hell</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/vuepress-blog/assets/js/app.5d9f3e6e.js" defer></script><script src="/vuepress-blog/assets/js/7.52cd3cfd.js" defer></script><script src="/vuepress-blog/assets/js/2.5e77f0d2.js" defer></script><script src="/vuepress-blog/assets/js/1.c3e4b76d.js" defer></script><script src="/vuepress-blog/assets/js/34.5977256e.js" defer></script>
  </body>
</html>
