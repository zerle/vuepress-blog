<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue2原理解析 | 张垒的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="记录好的技术文档">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.3d11a1f1.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.d7c20d16.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/7.52cd3cfd.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.5e77f0d2.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/1.c3e4b76d.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/17.d2f8beac.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.fce7151c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.665820a8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.93e60e41.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.06542fc4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.b75b2a2c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.3dbe40f4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.a0f84501.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.8cf233fc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.dc553e85.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.3f0558f8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.c6cd4af0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.6e5b88ce.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.e8704ed0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.ea2f5a39.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.87921c42.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.f31d39ff.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.5c2c99a1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.eff7fee9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.b375e77b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.f9c89aba.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.82fe56b9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.c7707b2a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.86e919c8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.7648c433.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.0d04e6fc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.f85a8b69.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.a49efe7f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.98053ef4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.15d7a48b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.a1d0539b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.877bc118.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.8364ac82.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.0102712f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.fc0cf83d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.3165fae7.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.37997938.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.5cfca3d0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.d70d2f6c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/49.80d9cea6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.fb9624e5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/50.0c550db3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/51.95b61c9e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/52.7f08f076.js"><link rel="prefetch" href="/vuepress-blog/assets/js/53.2a888b74.js"><link rel="prefetch" href="/vuepress-blog/assets/js/54.b39c22d6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/55.bf49caf4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/56.c7500a61.js"><link rel="prefetch" href="/vuepress-blog/assets/js/57.af85ad1c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/58.b21e620f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/59.f774584a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.09f6a933.js"><link rel="prefetch" href="/vuepress-blog/assets/js/60.993a0809.js"><link rel="prefetch" href="/vuepress-blog/assets/js/61.07c3a9a6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/62.13e7ddc1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/63.2490424e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/64.45eaa646.js"><link rel="prefetch" href="/vuepress-blog/assets/js/65.7bbae9b3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/66.97ef0021.js"><link rel="prefetch" href="/vuepress-blog/assets/js/67.615bec9f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/68.e3587494.js"><link rel="prefetch" href="/vuepress-blog/assets/js/69.0e54693e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/70.017b9424.js"><link rel="prefetch" href="/vuepress-blog/assets/js/71.d7f6b53f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.0899600d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.1f42c771.js"><link rel="prefetch" href="/vuepress-blog/assets/js/vendors~docsearch.680926dd.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.3d11a1f1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>张垒的博客</h3> <p class="description" data-v-59e6cb88>记录好的技术文档</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">张垒的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/vuepress-blog/me.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>33</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>31</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Vue2原理解析</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Vue2原理解析</h1> <div data-v-8a445198><!----> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2021/1/17</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>Vue2原理解析</span></i></div></div> <div class="theme-reco-content content__default"><p>Vue，现在前端的当红炸子鸡，随着热度指数上升，实在是有必要从源码的角度，对它功能的实现原理一窥究竟。个人觉得看源码主要是看两样东西，从宏观上来说是它的设计思想和实现原理；微观上来说就是编程技巧，也就是俗称的骚操作。我们这次的侧重点是它的实现原理。好吧，让我们推开它那神秘的大门，进入Vue的世界~</p> <h2 id="vue原理解析-一-vue到底是什么"><a href="#vue原理解析-一-vue到底是什么" class="header-anchor">#</a> Vue原理解析（一）：Vue到底是什么？</h2> <h3 id="vue是什么"><a href="#vue是什么" class="header-anchor">#</a> vue是什么？</h3> <p>vue究竟是什么？为什么就能实现这么多酷炫的功能，不知道大家有没有思考过这个问题。其实在每次初始化vue，使用new Vue({...})时，不难发现vue其实是一个类。不过即使在ES6已经如此普及的今天，vue的定义却是普通构造函数定义的，为什么没有采用ES6的class呢？这个我们稍后回答，通过层层追踪终于找到了vue被定义的地方：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> Vue<span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  this._init<span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为是原理解析，flow的类型检测及一些边界情况，如使用方式不对或参数不对或不是主要逻辑的代码我们就省略掉吧。比如省略号这里边界情况是使用时必须是new Vue()的形式，否则会报错。</p> <p>其实vue源码就像一棵树，我们看之前最好要确定看什么功能，然后避开那些分叉逻辑，我们接下来的目标就是以new Vue()开始，走完一整条从初始化、数据、模板到真实Dom的这整个流程。</p> <p>这就是vue最初始被定义的地方，你没看错，就是这么简单。当执行new Vue时，内部会执行一个方法 this._init(options)，将初始化的参数传入。</p> <p>这里需要说明一点，在vue的内部，_符号开头定义的变量是供内部私有使用的，而$ 符号定义的变量是供用户使用的，而且用户自定义的变量不能以_或$开头，以防止内部冲突。我们接着看：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">import</span> <span class="token punctuation">{</span> initMixin <span class="token punctuation">}</span> from <span class="token string">'./init'</span>
<span class="token function">import</span> <span class="token punctuation">{</span> stateMixin <span class="token punctuation">}</span> from <span class="token string">'./state'</span>
<span class="token function">import</span> <span class="token punctuation">{</span> renderMixin <span class="token punctuation">}</span> from <span class="token string">'./render'</span>
<span class="token function">import</span> <span class="token punctuation">{</span> eventsMixin <span class="token punctuation">}</span> from <span class="token string">'./events'</span>
<span class="token function">import</span> <span class="token punctuation">{</span> lifecycleMixin <span class="token punctuation">}</span> from <span class="token string">'./lifecycle'</span>

<span class="token keyword">function</span> Vue<span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  this._init<span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

initMixin<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>
stateMixin<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>
eventsMixin<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>
lifecycleMixin<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>
renderMixin<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>
</code></pre></div><p>现在可以回答之前的问题了，为什么不采用ES6的class来定义，因为这样可以方便的把vue的功能拆分到不同的目录中去维护，将vue的构造函数传入到以下方法内：</p> <ul><li>initMixin(Vue)：定义_init方法。</li> <li>stateMixin(Vue)：定义数据相关的方法$set,$delete,$watch方法。</li> <li>eventsMixin(Vue)：定义事件相关的方法$on，$once，$off，$emit。</li> <li>lifecycleMixin(Vue)：定义_update，及生命周期相关的$forceUpdate和$destroy。</li> <li>renderMixin(Vue)：定义$nextTick，_render将render函数转为vnode。</li></ul> <p>这些方法都是在各自的文件内维护的，从而让代码结构更加清晰易懂可维护。如this._init方法被定义在：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initMixin<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Vue.prototype._init <span class="token operator">=</span> function<span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">..</span>.当执行new Vue时，进行一系列初始化并挂载
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再这些xxxMixin完成后，接着会定义一些全局的API：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initGlobalAPI<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Vue.set方法
  Vue.delete方法
  Vue.nextTick方法
  
  <span class="token punctuation">..</span>.
  
  内置组件：
  keep-alive
  transition
  transition-group
  
  <span class="token punctuation">..</span>.
  
  initUse<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>：Vue.use方法
  initMixin<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>：Vue.mixin方法
  initExtend<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>：Vue.extend方法
  initAssetRegisters<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>：Vue.component，Vue.directive，Vue.filter方法
<span class="token punctuation">}</span>
</code></pre></div><p>这里有部分API和xxxMixin定义的原型方法功能是类似或相同的，如this.$set和Vue.set他们都是使用set这样一个内部定义的方法。</p> <p>这里需要提一下vue的架构设计，它的架构是分层式的。最底层是一个ES5的构造函数，再上层在原型上会定义一些_init、$watch、_render等这样的方法，再上层会在构造函数自身定义全局的一些API，如set、nextTick、use等(以上这些是不区分平台的核心代码)，接着是跨平台和服务端渲染(这些暂时不在讨论范围)及编译器。将这些属性方法都定义好了之后，最后会导出一个完整的构造函数给到用户使用，而new Vue就是启动的钥匙。这就是我们陌生且又熟悉的vue，至于Vue.prototype._init内部做了啥？我们下章节再说吧，因为还有很多其他的要补充。</p> <h3 id="目录结构"><a href="#目录结构" class="header-anchor">#</a> 目录结构</h3> <p>刚才是从比较微观的角度近距离的观察了vue，现在我们从宏观角度来了解它内部的代码结构是如何组建起来的。
目录如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">|</span>-- dist  打包后的vue版本
<span class="token operator">|</span>-- flow  类型检测，3.0换了typeScript
<span class="token operator">|</span>-- script  构建不同版本vue的相关配置
<span class="token operator">|</span>-- src  源码
    <span class="token operator">|</span>-- compiler  编译器
    <span class="token operator">|</span>-- core  不区分平台的核心代码
        <span class="token operator">|</span>-- components  通用的抽象组件
        <span class="token operator">|</span>-- global-api  全局API
        <span class="token operator">|</span>-- instance  实例的构造函数和原型方法
        <span class="token operator">|</span>-- observer  数据响应式
        <span class="token operator">|</span>-- util  常用的工具方法
        <span class="token operator">|</span>-- vdom  虚拟dom相关
    <span class="token operator">|</span>-- platforms  不同平台不同实现
    <span class="token operator">|</span>-- server  服务端渲染
    <span class="token operator">|</span>-- sfc  .vue单文件组件解析
    <span class="token operator">|</span>-- shared  全局通用工具方法
<span class="token operator">|</span>-- <span class="token builtin class-name">test</span> 测试
</code></pre></div><ul><li><p>flow：javaScript是弱类型语言，使用flow以定义类型和检测类型，增加代码的健壮性。</p></li> <li><p>src/compiler：将template模板编译为render函数。</p></li> <li><p>src/core：与平台无关通用的逻辑，可以运行在任何javaScript环境下，如web、Node.js、weex嵌入原生应用中。</p></li> <li><p>src/platforms：针对web平台和weex平台分别的实现，并提供统一的API供调用。</p></li> <li><p>src/observer：vue检测数据数据变化改变视图的代码实现。</p></li> <li><p>src/vdom：将render函数转为vnode从而patch为真实dom以及diff算法的代码实现。</p></li> <li><p>dist：存放着针对不同使用方式的不同的vue版本。</p></li></ul> <h3 id="vue版本"><a href="#vue版本" class="header-anchor">#</a> vue版本</h3> <p>vue使用的是rollup构建的，具体怎么构建的不重要，总之会构建出很多不同版本的vue。按照使用方式的不同，可以分为以下三类：</p> <ul><li>UMD：通过&lt;script&gt;标签直接在浏览器中使用。</li> <li>CommonJS：使用比较旧的打包工具使用，如webpack1。</li> <li>ES Module：配合现代打包工具使用，如webpack2及以上。</li></ul> <p>而每个使用方式内又分为了完整版和运行时版本，这里主要以ES Module为例，有了官方脚手架其他两类应该没多少人用了。再说明这两个版本的区别之前，抱歉我又要补充点其他的。在vue的内部是只认render函数的，我们来自己定义一个render函数，也就是这么个东西:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
  data: <span class="token punctuation">{</span>
    msg: <span class="token string">'hello Vue!'</span>
  <span class="token punctuation">}</span>,
  render<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> h<span class="token punctuation">(</span><span class="token string">'span'</span>, this.msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.<span class="token variable">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可能有人会纳闷了，既然只认render函数，同时我们开发好像从来并没有写过render函数，而是使用的template模板。这是因为有vue-loader，它会将我们在template内定义的内容编译为render函数，而这个编译就是区分完整版和运行时版本的关键所在，完整版就自带这个编译器，而运行时版本就没有，如下面这段代码如果是在运行时版本环境下就会报错了：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
  data: <span class="token punctuation">{</span>
    msg: <span class="token string">'hello Vue!'</span>  
  <span class="token punctuation">}</span>,
  template: <span class="token variable"><span class="token variable">`</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span><span class="token variable">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>vue-cli默认是使用运行时版本的，更改或覆盖脚手架内的默认配置，将其更改为完整版即可通过编译：'vue$': 'vue/dist/vue.esm.js'，推荐还是使用运行时版本。好吧，具体区别最后我们以一个面试时经常会被问到的问题作为本章节的结束。</p> <p>面试官微笑而又不失礼貌的问到：</p> <ul><li>请问runtime和runtime-only这两个版本的区别？</li></ul> <p>怼回去：</p> <ul><li>主要是两点不同：</li></ul> <ol><li>最明显的就是大小的区别，带编译器会比不带的版本大6kb。</li> <li>编译的时机不同，编译器是运行时编译，性能会有一定的损耗；运行时版本是借助loader做的离线编译，运行性能更高。</li></ol> <h2 id="vue原理解析-二-快速搞懂new-vue-时到底做了什么-上"><a href="#vue原理解析-二-快速搞懂new-vue-时到底做了什么-上" class="header-anchor">#</a> Vue原理解析（二）：快速搞懂new Vue()时到底做了什么？（上）</h2> <p>上一章节我们知道了在new Vue()时，内部会执行一个this._init()方法，这个方法是在initMixin(Vue)内定义的:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initMixin<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Vue.prototype._init <span class="token operator">=</span> function<span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当执行new Vue()执行后，触发的一系列初始化都在_init方法中启动，它的实现如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> uid <span class="token operator">=</span> <span class="token number">0</span>

Vue.prototype._init <span class="token operator">=</span> function<span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  const vm <span class="token operator">=</span> this
  vm._uid <span class="token operator">=</span> uid++  // 唯一标识
  
  vm.<span class="token variable">$options</span> <span class="token operator">=</span> mergeOptions<span class="token punctuation">(</span>  // 合并options
    resolveConstructorOptions<span class="token punctuation">(</span>vm.constructor<span class="token punctuation">)</span>,
    options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,
    vm
  <span class="token punctuation">)</span>
  <span class="token punctuation">..</span>.
  initLifecycle<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> // 开始一系列的初始化
  initEvents<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  initRender<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  callHook<span class="token punctuation">(</span>vm, <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
  initInjections<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  initState<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  initProvide<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  callHook<span class="token punctuation">(</span>vm, <span class="token string">'created'</span><span class="token punctuation">)</span>
  <span class="token punctuation">..</span>.
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm.<span class="token variable">$options</span>.el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm.<span class="token variable">$mount</span><span class="token punctuation">(</span>vm.<span class="token variable">$options</span>.el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>先需要交代下，每一个组件都是一个Vue构造函数的子类，这个之后会说明为何如此。从上往下我们一步步看，首先会定义_uid属性，这是为每个组件每一次初始化时做的一个唯一的私有属性标识，有时候会有些作用。</p> <p>有一个使用它的小例子，找到一个组件所有的兄弟组件并剔除自己：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">..</span>.
  <span class="token operator">&lt;</span>child-components /<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>child-components /<span class="token operator">&gt;</span>  // 找到它的兄弟组件
  <span class="token punctuation">..</span>. 其他组件
  <span class="token operator">&lt;</span>child-components /<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
</code></pre></div><p>首先要找的组件需要定义name属性，当然定义name属性也是一个好的书写习惯。首先通过自己的父组件($parent)的所有子组件($children)过滤出相同name集合的组件，这个时候他们就是同一个组件了，虽然它们name相同，但是_uid不同，最后在集合内根据_uid剔除掉自己即可。</p> <h3 id="合并options配置"><a href="#合并options配置" class="header-anchor">#</a> 合并options配置</h3> <p>回到主线任务，接着会合并options并在实例上挂载一个$options属性。合并什么东西了？这里是分两种情况的：</p> <p>初始化new Vue
在执行new Vue构造函数时，参数就是一个对象，也就是用户的自定义配置；会将它和vue之前定义的原型方法，全局API属性；还有全局的Vue.mixin内的参数，将这些都合并成为一个新的options，最后赋值给一个的新的属性$options。</p> <p>子组件初始化
如果是子组件初始化，除了合并以上那些外，还会将父组件的参数进行合并，如有父组件定义在子组件上的event、props等等。</p> <p>经过合并之后就可以通过this.$options.data访问到用户定义的data函数，this.$options.name访问到用户定义的组件名称，这个合并后的属性很重要，会被经常使用到。</p> <p>接下里会顺序的执行一堆初始化方法，首先是这三个：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">1</span>. initLifecycle<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token number">2</span>. initEvents<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token number">3</span>. initRender<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
</code></pre></div><h4 id="_1-initlifecycle-vm-主要作用是确认组件的父子关系和初始化某些实例属性。"><a href="#_1-initlifecycle-vm-主要作用是确认组件的父子关系和初始化某些实例属性。" class="header-anchor">#</a> 1. initLifecycle(vm): 主要作用是确认组件的父子关系和初始化某些实例属性。</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initLifecycle<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const options <span class="token operator">=</span> vm.<span class="token variable">$options</span>  // 之前合并的属性
  
  <span class="token builtin class-name">let</span> parent <span class="token operator">=</span> options.parent<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options.abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span> //  找到第一个非抽象父组件
    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent.<span class="token variable">$options</span>.abstract <span class="token operator">&amp;&amp;</span> parent.<span class="token variable">$parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> parent.<span class="token variable">$parent</span>
    <span class="token punctuation">}</span>
    parent.<span class="token variable">$children</span>.push<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  vm.<span class="token variable">$parent</span> <span class="token operator">=</span> parent  // 找到后赋值
  vm.<span class="token variable">$root</span> <span class="token operator">=</span> parent ? parent.<span class="token variable">$root</span> <span class="token builtin class-name">:</span> vm  // 让每一个子组件的<span class="token variable">$root</span>属性都是根组件
  
  vm.<span class="token variable">$children</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  vm.<span class="token variable">$refs</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  vm._watcher <span class="token operator">=</span> null
  <span class="token punctuation">..</span>.
  vm._isDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
  vm._isBeingDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>vue是组件式开发的，所以当前实例可能会是其他组件的子组件的同时也可能是其他组件的父组件。</p> <p>首先会找到当前组件第一个非抽象类型的父组件，所以如果当前组件有父级且当前组件不是抽象组件就一直向上查找，直至找到后将找到的父级赋值给实例属性vm.$parent，然后将当前实例push到找到的父级的$children实例属性内，从而建立组件的父子关系。接下来的一些_开头是私有实例属性我们记住是在这里定义的即可，具体意思也是以后用到的时候再做说明。</p> <h4 id="_2-initevents-vm-主要作用是将父组件在使用v-on或-注册的自定义事件添加到子组件的事件中心中。"><a href="#_2-initevents-vm-主要作用是将父组件在使用v-on或-注册的自定义事件添加到子组件的事件中心中。" class="header-anchor">#</a> 2. initEvents(vm): 主要作用是将父组件在使用v-on或@注册的自定义事件添加到子组件的事件中心中。</h4> <p>首先看下这个方法定义的地方：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initEvents <span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm._events <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span>  // 事件中心
  <span class="token punctuation">..</span>.
  const listeners <span class="token operator">=</span> vm.<span class="token variable">$options</span>._parentListeners  // 经过合并options得到的
  <span class="token keyword">if</span> <span class="token punctuation">(</span>listeners<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    updateComponentListeners<span class="token punctuation">(</span>vm, listeners<span class="token punctuation">)</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们首先要知道在vue中事件分为两种，他们的处理方式也各有不同：</p> <h5 id="_2-1-原生事件"><a href="#_2-1-原生事件" class="header-anchor">#</a> 2.1 原生事件</h5> <p>在执行initEvents之前的模板编译阶段，会判断遇到的是html标签还是组件名，如果是html标签会在转为真实dom之后使用addEventListener注册浏览器原生事件。绑定事件是挂载dom的最后阶段，这里只是初始化阶段，这里主要是处理自定义事件相关，也就是另外一种，这里声明下，大家不要理会错了执行顺序。</p> <h5 id="_2-2-自定义事件"><a href="#_2-2-自定义事件" class="header-anchor">#</a> 2.2 自定义事件</h5> <p>在经历过合并options阶段后，子组件就可以从vm.$options._parentListeners读取到父组件传过来的自定义事件：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>child-components @select<span class="token operator">=</span><span class="token string">'handleSelect'</span> /<span class="token operator">&gt;</span>
</code></pre></div><p>传过来的事件数据格式是{select:function(){}}这样的，在initEvents方法内定义vm._events用来存储传过来的事件集合。</p> <p>内部执行的方法updateComponentListeners(vm, listeners)主要是执行updateListeners方法。这个方法有两个执行时机，首先是现在的初始化阶段，还一个就是最后patch时的原生事件也会用到。它的作用是比较新旧事件的列表来确定事件的添加和移除以及事件修饰符的处理，现在主要看自定义事件的添加，它的作用是借助之前定义的$on，$emit方法，完成父子组件事件的通信。首先使用$on往vm.events事件中心下创建一个自定义事件名的数组集合项，数组内的每一项都是对应事件名的回调函数，例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vm._events.select <span class="token operator">=</span> <span class="token punctuation">[</span>function <span class="token function-name function">handleSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>, <span class="token punctuation">..</span>.<span class="token punctuation">]</span>  // 可以有多个
</code></pre></div><p>注册完成之后，使用$emit方法执行事件：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>this.<span class="token variable">$emit</span><span class="token punctuation">(</span><span class="token string">'select'</span><span class="token punctuation">)</span>
</code></pre></div><p>首先会读取到事件中心内$emit方法第一个参数select的对象的数组集合，然后将数组内每个回调函数顺序执行一遍即完成了$emit做的事情。</p> <p>不知道大家有没有注意到this.$emit这个方法是在当前组件实例触发的，所以事件的原理可能跟大部分人理解的不一样，并不是父组件监听，子组件往父组件去派发事件。</p> <p>而是子组件往自身的实例上派发事件，只是因为回调函数是在父组件的作用域下定义的，所以执行了父组件内定义的方法，就造成了父子之间事件通信的假象。知道这个原理特性后，我们可以做一些更cool的事情，例如</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>parent-component<span class="token operator">&gt;</span>  // <span class="token variable">$on</span>添加事件
    <span class="token operator">&lt;</span>child-component-<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>
      <span class="token operator">&lt;</span>child-component-<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
        <span class="token operator">&lt;</span>child-component-3 /<span class="token operator">&gt;</span>  // <span class="token variable">$emit</span>触发事件
      <span class="token operator">&lt;</span>/child-component-<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
    <span class="token operator">&lt;</span>/child-components-<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>
  <span class="token operator">&lt;</span>/parent-component<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
</code></pre></div><p>我们可不可以在parent-component内使用$on添加事件到当前实例的事件中心，而在child-components-3内找到parent-component的组件实例并在它的事件中心触发对应的事件实现跨组件通信了，答案是可以了！这一原理发现再开发组件库时会有一定帮助。</p> <h4 id="_3-initrender-vm-主要作用是挂载可以将render函数转为vnode的方法。"><a href="#_3-initrender-vm-主要作用是挂载可以将render函数转为vnode的方法。" class="header-anchor">#</a> 3. initRender(vm): 主要作用是挂载可以将render函数转为vnode的方法。</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initRender<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm._vnode <span class="token operator">=</span> null
  <span class="token punctuation">..</span>.
  vm._c <span class="token operator">=</span> <span class="token punctuation">(</span>a, b, c, d<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> createElement<span class="token punctuation">(</span>vm, a, b, c, d, <span class="token boolean">false</span><span class="token punctuation">)</span>  //转化编译器的
  vm.<span class="token variable">$createElement</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a, b, c, d<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> createElement<span class="token punctuation">(</span>vm, a, b, c, d, <span class="token boolean">true</span><span class="token punctuation">)</span>  // 转化手写的
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>主要作用是挂载vm._c和vm.$createElement两个方法，它们只是最后一个参数不同，这两个方法都可以将render函数转为vnode，从命名大家应该可以看出区别，vm._c转换的是通过编译器将template转换而来的render函数；而vm.$createElement转换的是用户自定义的render函数，比如</p> <div class="language-bash extra-class"><pre class="language-bash"><code>new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
  data: <span class="token punctuation">{</span>
    msg: <span class="token string">'hello Vue!'</span>
  <span class="token punctuation">}</span>,
  render<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span> // 这里的 h 就是vm.<span class="token variable">$createElement</span>
    <span class="token builtin class-name">return</span> h<span class="token punctuation">(</span><span class="token string">'span'</span>, this.msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.<span class="token variable">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>render函数的参数h就是vm.$createElement方法，将内部定义的树形结构数据转为Vnode的实例</p> <h4 id="_4-callhook-vm-beforecreate"><a href="#_4-callhook-vm-beforecreate" class="header-anchor">#</a> 4. callHook(vm, 'beforeCreate')</h4> <p>终于我们要执行实例的第一个生命周期钩子beforeCreate，这里callHook的原理是怎样的，我们之后的生命周期章节会说明，现在这里只需要知道它会执行用户自定义的生命周期方法，如果有mixin混入的也一并执行。</p> <p>好吧，实例的第一个生命周期钩子阶段的初始化工作完成了，一句话来主要说明下他们做了什么事情：</p> <ul><li>initLifecycle(vm)：确认组件(也是vue实例)的父子关系</li> <li>initEvents(vm)：将父组件的自定义事件传递给子组件</li> <li>initRender(vm)：提供将render函数转为vnode的方法</li> <li>beforeCreate：执行组件的beforeCreate钩子函数</li></ul> <p>最后还是以一道vue容易被问道的面试题作为本章节的结束吧：</p> <h4 id="面试官微笑而又不失礼貌的问道"><a href="#面试官微笑而又不失礼貌的问道" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h4> <ul><li>请问可以在beforeCreate钩子内通过this访问到data中定义的变量么，为什么以及请问这个钩子可以做什么？</li></ul> <h4 id="怼回去"><a href="#怼回去" class="header-anchor">#</a> 怼回去：</h4> <ul><li>是不可以访问的，因为在vue初始化阶段，这个时候data中的变量还没有被挂载到this上，这个时候访问值会是undefined。beforeCreate这个钩子在平时业务开发中用的比较少，而像插件内部的instanll方法通过Vue.use方法安装时一般会选在beforeCreate这个钩子内执行，vue-router和vuex就是这么干的。</li></ul> <h2 id="vue原理解析-三-快速搞懂new-vue-时到底做了什么-下"><a href="#vue原理解析-三-快速搞懂new-vue-时到底做了什么-下" class="header-anchor">#</a> Vue原理解析（三）：快速搞懂new Vue()时到底做了什么？（下）</h2> <p>让我们继续this._init()的初始化之旅，接下来又会执行这样的三个初始化方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>initInjections<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
initState<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
initProvide<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
</code></pre></div><h3 id="_5-initinjections-vm-主要作用是初始化inject-可以访问到对应的依赖。"><a href="#_5-initinjections-vm-主要作用是初始化inject-可以访问到对应的依赖。" class="header-anchor">#</a> 5. initInjections(vm): 主要作用是初始化inject，可以访问到对应的依赖。</h3> <p>inject和provide这里需要简单的提一下，这是vue@2.2版本添加的一对需要一起使用的API，它允许父级组件向它之后的所有子孙组件提供依赖，让子孙组件无论嵌套多深都可以访问到，很cool有木有~</p> <ul><li>provide：提供一个对象或是返回一个对象的函数。</li> <li>inject：是一个字符串数组或对象。</li></ul> <p>这一对API在vue官网有给出两条食用提示：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。
</code></pre></div><ul><li>大概是因为会让组件数据层级关系变的混乱的缘故，但在开发组件库时会很好使。</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。
</code></pre></div><ul><li>有个小技巧，这里可以将根组件data内定义的属性提供给子孙组件，这样在不借助vuex的情况下就可以实现简单的全局状态管理，还是很cool的~</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>app.vue 根组件

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      app: this
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      info: <span class="token string">'hello world!'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

child.vue 子孙组件

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  inject: <span class="token punctuation">[</span><span class="token string">'app'</span><span class="token punctuation">]</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.app.info <span class="token operator">=</span> <span class="token string">'hello vue!'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一但触发handleClick事件之后，无论嵌套多深的子孙组件只要是使用了inject注入this.app.info变量的地方都会被响应，这就完成了简易的vuex。更多的示例大家可以去vue的官网翻阅，这里就不码字了，现在我们来分析下这么cool的功能它究竟是怎么实现的~</p> <p>虽然inject和provide是成对使用的，但是二者在内部是分开初始化的。从上面三个初始化方法就能看出，先初始化inject，然后初始化props/data状态相关，最后初始化provide。这样做的目的是可以在props/data中使用inject内所注入的内容。</p> <p>我们首先来看一下初始化inject时的方法定义</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initInjections<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const result <span class="token operator">=</span> resolveInject<span class="token punctuation">(</span>vm.<span class="token variable">$options</span>.inject, vm<span class="token punctuation">)</span> // 找结果
  
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>vm.$options.inject为之前合并后得到的用户自定义的inject，然后使用resolveInject方法找到我们想要的结果,我们看下resolveInject方法的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> resolveInject <span class="token punctuation">(</span>inject, vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>inject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const result <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span>
    const keys <span class="token operator">=</span> Object.keys<span class="token punctuation">(</span>inject<span class="token punctuation">)</span>  //省略Symbol情况

    <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      const key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      const provideKey <span class="token operator">=</span> inject<span class="token punctuation">[</span>key<span class="token punctuation">]</span>.from
      <span class="token builtin class-name">let</span> <span class="token builtin class-name">source</span> <span class="token operator">=</span> vm
      <span class="token keyword">while</span> <span class="token punctuation">(</span>source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>source._provided <span class="token operator">&amp;&amp;</span> hasOwn<span class="token punctuation">(</span>source._provided, provideKey<span class="token punctuation">))</span> <span class="token punctuation">{</span> //hasOwn为是否有
          result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> source._provided<span class="token punctuation">[</span>provideKey<span class="token punctuation">]</span>
          <span class="token builtin class-name">break</span>
        <span class="token punctuation">}</span>
        <span class="token builtin class-name">source</span> <span class="token operator">=</span> source.<span class="token variable">$parent</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">..</span>. vue@2.5后新增设置inject默认参数相关逻辑
    <span class="token punctuation">}</span>
    <span class="token builtin class-name">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先定义一个result返回找到的结果。接下来使用双循环查找，外层的for循环会遍历inject的每一项，然后再内层使用while循环自底向上的查找inject该项的父级是否有提供对应的依赖。</p> <p>Ps:这里可能有人会有疑问，之前inject的定义明明是数组，这里怎么可以通过Object.keys取值？这是因为上一章再做options合并时，也会对参数进行格式化，如props的格式，定义为数组也会被转为对象格式，inject被定义时是这样的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>定义时：
<span class="token punctuation">{</span>
  inject: <span class="token punctuation">[</span><span class="token string">'app'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

格式化后：
<span class="token punctuation">{</span>
  inject: <span class="token punctuation">{</span>
    app: <span class="token punctuation">{</span>
      from: <span class="token string">'app'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>书接上文，source就是当前的实例，而source._provided内保存的就是当前provide提供的值。首先从当前实例查找，接着将它的父组件实例赋值给source，在它的父组件查找。找到后使用break跳出循环，将搜索的结果赋值给result，接着查找下一个。</p> <p>Ps:可能有人又会有疑问，这个时候是先初始化的inject再初始化的provide，怎么访问父级的provide了？它根本就没初始化阿，这个时候我们就要再思考下了，因为vue是组件式的，首先就会初始化父组件，然后才是初始化子组件，所以这个时候是有source._provided属性的。</p> <p>找到了想到的结果之后，我们补全之前initInjections的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initInjections<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const result <span class="token operator">=</span> resolveInject<span class="token punctuation">(</span>vm.<span class="token variable">$options</span>.inject, vm<span class="token punctuation">)</span>

  if<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span> // 如果有结果
    toggleObserving<span class="token punctuation">(</span>false<span class="token punctuation">)</span>  // 刻意为之不被响应式
    Object.keys<span class="token punctuation">(</span>result<span class="token punctuation">)</span>.forEach<span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      <span class="token punctuation">..</span>.
      defineReactive<span class="token punctuation">(</span>vm, key, result<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    toggleObserving<span class="token punctuation">(</span>true<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果有搜索结果，首先会调用toggleObserving(false)，具体实现不用理会，只用知道这个方法的作用是设置一个标志位，将决定defineReactive()方法是否将它的第三个参数设置为响应式数据，也就是决定result[key]这个值是否会被设置为响应式数据，这里的参数为false，只是在vm下挂载key对应普通的值，不过这样就可以在当前实例使用this访问到inject内对应的依赖项了，设置完毕之后再调用toggleObserving(true)，改变标志位，让defineReactive()可以设置第三个参数为响应式数据（defineReactive是响应式原理很重要的方法，这里了解即可），也就是它该有的样子。以上就是inject实现的相关原理，一句话来说就是，首先遍历每一项，然后挨个遍历每一项父级是否有依赖。</p> <h3 id="_6-initstate-vm-初始化会被使用到的状态-状态包括props-methods-data-computed-watch五个选项。"><a href="#_6-initstate-vm-初始化会被使用到的状态-状态包括props-methods-data-computed-watch五个选项。" class="header-anchor">#</a> 6. initState(vm): 初始化会被使用到的状态，状态包括props，methods，data，computed，watch五个选项。</h3> <p>首先看下initState(vm)方法的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initState<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  const opts <span class="token operator">=</span> vm.<span class="token variable">$options</span>
  if<span class="token punctuation">(</span>opts.props<span class="token punctuation">)</span> initProps<span class="token punctuation">(</span>vm, opts.props<span class="token punctuation">)</span>
  if<span class="token punctuation">(</span>opts.methods<span class="token punctuation">)</span> initMethods<span class="token punctuation">(</span>vm, opts.methods<span class="token punctuation">)</span>
  if<span class="token punctuation">(</span>opts.data<span class="token punctuation">)</span> initData<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">..</span>.
  if<span class="token punctuation">(</span>opts.computed<span class="token punctuation">)</span> initComputed<span class="token punctuation">(</span>vm, opts.computed<span class="token punctuation">)</span>
  if<span class="token punctuation">(</span>opts.watch <span class="token operator">&amp;&amp;</span> opts.watch <span class="token operator">!=</span><span class="token operator">=</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    initWatch<span class="token punctuation">(</span>vm, opts.watch<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在这里的话只会介绍前面三类状态的初始化做了什么，也就是props，methods，data，因为computed和watch会涉及到响应式相关的watcher，这里先略过。接下来我们依次有请这三位的初始化方法登场</p> <h4 id="_6-1-initprops-vm-propsoptions"><a href="#_6-1-initprops-vm-propsoptions" class="header-anchor">#</a> 6.1 initProps (vm, propsOptions)：</h4> <ul><li>主要作用是检测子组件接受的值是否符合规则，以及让对应的值可以用this直接访问。</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> initProps<span class="token punctuation">(</span>vm, propsOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 第二个参数为验证规则
  const propsData <span class="token operator">=</span> vm.<span class="token variable">$options</span>.propsData <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  // props具体的值
  const props <span class="token operator">=</span> vm._props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  // 存放props
  const isRoot <span class="token operator">=</span> <span class="token operator">!</span>vm.<span class="token variable">$parent</span> // 是否是根节点
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    toggleObserving<span class="token punctuation">(</span>false<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>const key <span class="token keyword">in</span> propsOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const value <span class="token operator">=</span> validateProp<span class="token punctuation">(</span>key, propsOptions, propsData, vm<span class="token punctuation">)</span>
    defineReactive<span class="token punctuation">(</span>props, key, value<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      proxy<span class="token punctuation">(</span>vm, <span class="token variable"><span class="token variable">`</span>_props<span class="token variable">`</span></span>, key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  toggleObserving<span class="token punctuation">(</span>true<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们知道props是作为父组件向子组件通信的重要方式，而initProps内的第二个参数propsOptions，就是当前实例也就是通信角色里的子组件，它所定义的接受参数的规则。子组件的props规则是可以使用数组形式的定义的，不过再经过合并options之后会被格式化为对象的形式：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>定义时：
<span class="token punctuation">{</span>
  props: <span class="token punctuation">[</span><span class="token string">'name'</span>, <span class="token string">'age'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

格式化后：
<span class="token punctuation">{</span>
  name: <span class="token punctuation">{</span>
    type: null
  <span class="token punctuation">}</span>,
  age: <span class="token punctuation">{</span>
    type: null
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以在定义props规则时，直接使用对象格式吧，这也是更好的书写规范。</p> <p>知道了规则之后，接下来需要知道父组件传递给子组件具体的值，它以对象的格式被放在vm.$options.propsData内，这也是合并options时得到的。接下来在实例下定义了一个空对象vm._props，它的作用是将符合规格的值挂载到它下面。isRoot的作用是判断当前组件是否是根组件，如果不是就不将props的转为响应式数据。</p> <p>接下来遍历格式化后的props验证规则，通过validateProp方法验证规则并得到相应的值，将得到的值挂载到vm._props下。这个时候就可以通过this._props访问到props内定义的值了：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>props: <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span>,
methods: <span class="token punctuation">{</span>
  <span class="token function-name function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console.log<span class="token punctuation">(</span>this._props.name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过直接访问内部的私有变量这种方式并不友好，所以vue内部做了一层代理，将对this.name的访问转而为对this._props.name的访问。这里的proxy需要介绍下，因为之后的data也会使用到，看下它的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>格式化了一下：
<span class="token builtin class-name">export</span> <span class="token keyword">function</span> proxy<span class="token punctuation">(</span>target, sourceKey, key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object.defineProperty<span class="token punctuation">(</span>target, key, <span class="token punctuation">{</span>
    enumerable: true,
    configurable: true,
    get: <span class="token function-name function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token builtin class-name">return</span> this<span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>,
    set: <span class="token function-name function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this<span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实很简单，只是定义一个对象值的get方法，读取时让其返回另外的一个值，这里就完成了props的初始化。</p> <h4 id="_6-2-initmethods-vm-methods"><a href="#_6-2-initmethods-vm-methods" class="header-anchor">#</a> 6.2 initMethods (vm, methods)：</h4> <p>主要作用是将methods内的方法挂载到this下。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> initMethods<span class="token punctuation">(</span>vm, methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const props <span class="token operator">=</span> vm.<span class="token variable">$options</span>.props
  for<span class="token punctuation">(</span>const key <span class="token keyword">in</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    if<span class="token punctuation">(</span>methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">==</span><span class="token operator">=</span> null <span class="token operator">||</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">==</span><span class="token operator">=</span> undefined 的简写
      warn<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>只定义了key而没有相应的value<span class="token variable">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    if<span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> hasOwn<span class="token punctuation">(</span>props, key<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      warn<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>方法名和props的key重名了<span class="token variable">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span><span class="token variable"><span class="token punctuation">((</span>key in vm<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> isReserved<span class="token punctuation">(</span>key<span class="token punctuation">))</span></span> <span class="token punctuation">{</span>
      warn<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>方法名已经存在而且以_或$开头<span class="token variable">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">==</span> null
      ? noop  // 空函数
      <span class="token builtin class-name">:</span> bind<span class="token punctuation">(</span>methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span>, vm<span class="token punctuation">)</span>  //  相当于methods<span class="token punctuation">[</span>key<span class="token punctuation">]</span>.bind<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>methods的初始化相较而言就简单了很多。不过它也有很多边界情况，如只定义了key而没有方法具体的实现、key和props重名了、key已经存在且命名不规范，以_或$开头，至于为什么不行，我们第一章的时候有说明了。最后将methods内的方法挂载到this下，就完成了methods的初始化。</p> <h4 id="_6-3-initdata-vm"><a href="#_6-3-initdata-vm" class="header-anchor">#</a> 6.3 initData (vm)：</h4> <ul><li>主要作用是初始化data，还是老套路，挂载到this下。有个重要的点，之所以data内的数据是响应式的，是在这里初始化的，这个大家得有个印象~。</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> initData <span class="token punctuation">(</span>vm: Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> data <span class="token operator">=</span> vm.<span class="token variable">$options</span>.data
  data <span class="token operator">=</span> vm._data <span class="token operator">=</span> typeof data <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'function'</span>
    ? getData<span class="token punctuation">(</span>data, vm<span class="token punctuation">)</span> // 通过data.call<span class="token punctuation">(</span>vm, vm<span class="token punctuation">)</span>得到返回的对象
    <span class="token builtin class-name">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isPlainObject<span class="token punctuation">(</span>data<span class="token punctuation">))</span> <span class="token punctuation">{</span> // 如果不是一个对象格式
    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    warn<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>data得是一个对象<span class="token variable">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  const keys <span class="token operator">=</span> Object.keys<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  const props <span class="token operator">=</span> vm.<span class="token variable">$options</span>.props  // 得到props
  const methods <span class="token operator">=</span> vm.<span class="token variable">$options</span>.methods  // 得到methods
  <span class="token builtin class-name">let</span> i <span class="token operator">=</span> keys.length
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i--<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> hasOwn<span class="token punctuation">(</span>methods, key<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      warn<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>和methods内的方法重名了<span class="token variable">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> hasOwn<span class="token punctuation">(</span>props, key<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      warn<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>和props内的key重名了<span class="token variable">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isReserved<span class="token punctuation">(</span>key<span class="token punctuation">))</span> <span class="token punctuation">{</span> // key不能以_或$开头
      proxy<span class="token punctuation">(</span>vm, <span class="token variable"><span class="token variable">`</span>_data<span class="token variable">`</span></span>, key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  observe<span class="token punctuation">(</span>data, <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先通过vm.$options.data得到用户定义的data，如果是function格式就执行它，并返回执行之后的结果，否则返回data或{}，将结果赋值给vm._data这个私有属性。和props一样的套路，最后用来做一层代理，如果得到的结果不是对象格式就是报错了。</p> <p>然后遍历data内的每一项，不能和methods以及props内的key重名，然后使用proxy做一层代理。注意最后会执行一个方法observe(data, true)，它的作用了是递归的让data内的每一项数据都变成响应式的。</p> <p>其实不难发现它们仨主要做的事情差不多，首先不要相互之间有重名，然后可以被this直接访问到。</p> <h3 id="_7-initprovide-vm-主要作用是初始化provide为子组件提供依赖。"><a href="#_7-initprovide-vm-主要作用是初始化provide为子组件提供依赖。" class="header-anchor">#</a> 7. initProvide(vm): 主要作用是初始化provide为子组件提供依赖。</h3> <p>provide选项应该是一个对象或是函数，所以对它取值即可，就像取data内的值类似，看下它的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initProvide <span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const provide <span class="token operator">=</span> vm.<span class="token variable">$options</span>.provide
  <span class="token keyword">if</span> <span class="token punctuation">(</span>provide<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm._provided <span class="token operator">=</span> typeof provide <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'function'</span>
      ? provide.call<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
      <span class="token builtin class-name">:</span> provide
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先通过vm.$options.provide取得用户定义的provide选项，如果是一个function类型就执行一下，得到返回后的结果，将其赋值给了vm._provided私有属性，所以子组件在初始化inject时就可以访问到父组件提供的依赖了；如果不是function类型就直接返回定义的provide。</p> <h3 id="_8-callhook-vm-created-执行用户定义的created钩子函数-有mixin混入的也一并执行。"><a href="#_8-callhook-vm-created-执行用户定义的created钩子函数-有mixin混入的也一并执行。" class="header-anchor">#</a> 8. callHook(vm, 'created'): 执行用户定义的created钩子函数，有mixin混入的也一并执行。</h3> <p>终于我们越过了created钩子函数，还是分别用一句话来介绍它们主要都干了什么事：</p> <ul><li>initInjections(vm)：让子组件inject的项可以访问到正确的值</li> <li>initState(vm)：将组件定义的状态挂载到this下。</li> <li>initProvide(vm)：初始化父组件提供的provide依赖。</li> <li>created：执行组件的created钩子函数</li></ul> <p>初始化的阶段算是告一段落了，接下来我们会进入组件的挂载阶段。按照惯例我们还是以一道vue容易被问道的面试题作为本章的结束吧~：</p> <h3 id="面试官微笑而又不失礼貌的问道-2"><a href="#面试官微笑而又不失礼貌的问道-2" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h3> <ul><li>请问methods内的方法可以使用箭头函数么，会造成什么样的结果？</li></ul> <h3 id="怼回去-2"><a href="#怼回去-2" class="header-anchor">#</a> 怼回去：</h3> <ul><li>是不可以使用箭头函数的，因为箭头函数的this是定义时就绑定的。在vue的内部，methods内每个方法的上下文是当前的vm组件实例，methods[key].bind(vm)，而如果使用使用箭头函数，函数的上下文就变成了父级的上下文，也就是undefined了，结果就是通过undefined访问任何变量都会报错。</li></ul> <h2 id="vue原理解析-四-你知道被大家聊烂了的虚拟dom是怎么生成的吗"><a href="#vue原理解析-四-你知道被大家聊烂了的虚拟dom是怎么生成的吗" class="header-anchor">#</a> Vue原理解析（四）：你知道被大家聊烂了的虚拟Dom是怎么生成的吗？</h2> <p>在经过初始化阶段之后，即将开始组件的挂载，不过在挂载之前很有必要提一下虚拟Dom的概念。这个想必大家有所耳闻，我们知道vue@2.0开始引入了虚拟Dom，主要解决的问题是，大部分情况下可以降低使用JavaScript去操作跨线程的庞大Dom所需要的昂贵性能，让Dom操作的性能更高；以及虚拟Dom可以用于SSR以及跨端使用。虚拟Dom，顾名思义并不是真实的Dom，而是使用JavaScript的对象来对真实Dom的一个描述。一个真实的Dom也无非是有标签名，属性，子节点等这些来描述它，如页面中的真实Dom是这样的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>div <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">'app'</span> <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">'wrap'</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
    hello
  <span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
</code></pre></div><p>我们可以在render函数内这样描述它：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
  render<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> h<span class="token punctuation">(</span><span class="token string">'div'</span>, <span class="token punctuation">{</span>
      attrs: <span class="token punctuation">{</span>
        id: <span class="token string">'app'</span>,
        class: <span class="token string">'wrap'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>, <span class="token punctuation">[</span>
      h<span class="token punctuation">(</span><span class="token string">'h2'</span>, <span class="token string">'hello'</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这个时候它并不是用对象来描述的，使用的是render函数内的数据结构去描述的真实Dom，而现在我们需要将这段描述转为用对象的形式，render函数使用的是参数h方法并用VNode这个类来实例化它们，所以我们再了解h的实现原理前，首先来看下VNode类是什么，找到它定义的地方：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default class VNode <span class="token punctuation">{</span>
  constructor <span class="token punctuation">(</span>
    tag
    data
    children
    text
    elm
    context
    componentOptions
    asyncFactory
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.tag <span class="token operator">=</span> tag  // 标签名
    this.data <span class="token operator">=</span> data  // 属性 如id/class
    this.children <span class="token operator">=</span> children  // 子节点
    this.text <span class="token operator">=</span> text  // 文本内容
    this.elm <span class="token operator">=</span> elm  // 该VNode对应的真实节点
    this.ns <span class="token operator">=</span> undefined  // 节点的namespace
    this.context <span class="token operator">=</span> context  // 该VNode对应实例
    this.fnContext <span class="token operator">=</span> undefined  // 函数组件的上下文
    this.fnOptions <span class="token operator">=</span> undefined  // 函数组件的配置
    this.fnScopeId <span class="token operator">=</span> undefined  // 函数组件的ScopeId
    this.key <span class="token operator">=</span> data <span class="token operator">&amp;&amp;</span> data.key  // 节点绑定的key 如v-for
    this.componentOptions <span class="token operator">=</span> componentOptions  //  组件VNode的options
    this.componentInstance <span class="token operator">=</span> undefined  // 组件的实例
    this.parent <span class="token operator">=</span> undefined  // vnode组件的占位符节点
    this.raw <span class="token operator">=</span> <span class="token boolean">false</span>  // 是否为平台标签或文本
    this.isStatic <span class="token operator">=</span> <span class="token boolean">false</span>  // 静态节点
    this.isRootInsert <span class="token operator">=</span> <span class="token boolean">true</span>  // 是否作为根节点插入
    this.isComment <span class="token operator">=</span> <span class="token boolean">false</span>  // 是否是注释节点
    this.isCloned <span class="token operator">=</span> <span class="token boolean">false</span>  // 是否是克隆节点
    this.isOnce <span class="token operator">=</span> <span class="token boolean">false</span>  // 是否是v-noce节点
    this.asyncFactory <span class="token operator">=</span> asyncFactory  // 异步工厂方法
    this.asyncMeta <span class="token operator">=</span> undefined  //  异步meta
    this.isAsyncPlaceholder <span class="token operator">=</span> <span class="token boolean">false</span>  // 是否为异步占位符
  <span class="token punctuation">}</span>

  get <span class="token function-name function">child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 别名
    <span class="token builtin class-name">return</span> this.componentInstance
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是VNode类定义的地方，挺吓人的，它支持一共最多八个参数，其实经常用到的并不多。如tag是元素节点的名称，children为它的子节点，text是文本节点内的文本。实例化后的对象就有二十三个属性作为在vue的内部一个节点的描述，它描述的是将它创建为一个怎样的真实Dom。大部分属性默认是false或undefined，而通过这些属性有效的值就可以组装出不同的描述，如真实的Dom中会有元素节点、文本节点、注释节点等。而通过这样一个VNode类，也可以描述出相应的节点，部分节点vue内部还做了相应的封装：</p> <h3 id="注释节点-↓"><a href="#注释节点-↓" class="header-anchor">#</a> 注释节点 ↓</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> const createEmptyVNode <span class="token operator">=</span> <span class="token punctuation">(</span>text <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  const <span class="token function">node</span> <span class="token operator">=</span> new VNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
  node.text <span class="token operator">=</span> text
  node.isComment <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token builtin class-name">return</span> <span class="token function">node</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>创建一个空的VNode，有效属性只有text和isComment来表示一个注释节点。</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>真实的注释节点：
<span class="token operator">&lt;</span><span class="token operator">!</span>-- 注释节点 --<span class="token operator">&gt;</span>

VNode描述：
createEmptyVNode <span class="token punctuation">(</span><span class="token string">'注释节点'</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  text: <span class="token string">'注释节点'</span>,
  isComment: <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="文本节点-↓"><a href="#文本节点-↓" class="header-anchor">#</a> 文本节点 ↓</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> createTextVNode <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> new VNode<span class="token punctuation">(</span>undefined, undefined, undefined, String<span class="token punctuation">(</span>val<span class="token punctuation">))</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>只是设置了text属性，描述的是标签内的文本</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>VNode描述：
createTextVNode<span class="token punctuation">(</span><span class="token string">'文本节点'</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  text: <span class="token string">'文本节点'</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="克隆节点-↓"><a href="#克隆节点-↓" class="header-anchor">#</a> 克隆节点 ↓</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> cloneVNode <span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const cloned <span class="token operator">=</span> new VNode<span class="token punctuation">(</span>
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  <span class="token punctuation">)</span>
  cloned.ns <span class="token operator">=</span> vnode.ns
  cloned.isStatic <span class="token operator">=</span> vnode.isStatic
  cloned.key <span class="token operator">=</span> vnode.key
  cloned.isComment <span class="token operator">=</span> vnode.isComment
  cloned.fnContext <span class="token operator">=</span> vnode.fnContext
  cloned.fnOptions <span class="token operator">=</span> vnode.fnOptions
  cloned.fnScopeId <span class="token operator">=</span> vnode.fnScopeId
  cloned.asyncMeta <span class="token operator">=</span> vnode.asyncMeta
  cloned.isCloned <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token builtin class-name">return</span> cloned
<span class="token punctuation">}</span>
</code></pre></div><ul><li>将一个现有的VNode节点拷贝一份，只是被拷贝节点的isCloned属性为false，而拷贝得到的节点的isCloned属性为true，除此之外它们完全相同。</li></ul> <h3 id="元素节点-↓"><a href="#元素节点-↓" class="header-anchor">#</a> 元素节点 ↓</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>真实的元素节点：
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  hello
  <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Vue<span class="token operator">!</span><span class="token operator">&lt;</span>/span<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>

VNode描述：
<span class="token punctuation">{</span>
  tag: <span class="token string">'div'</span>,
  children: <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      text: <span class="token string">'hello'</span>
    <span class="token punctuation">}</span>, 
    <span class="token punctuation">{</span>
      tag: <span class="token string">'span'</span>,
      children: <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          text: Vue<span class="token operator">!</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>,
<span class="token punctuation">}</span>
</code></pre></div><h3 id="组件节点-↓"><a href="#组件节点-↓" class="header-anchor">#</a> 组件节点 ↓</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>渲染App组件：
new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
  render<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> h<span class="token punctuation">(</span>App<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

VNode描述：
<span class="token punctuation">{</span>
  tag: <span class="token string">'vue-component-2'</span>,
  componentInstance: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
  componentOptions: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
  context: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
  data: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>组件的VNode会和元素节点相比会有两个特有的属性componentInstance和componentOptions。VNode的类型有很多，它们都是从这个VNode类中实例化出来的，只是属性不同。</p> <h3 id="开始挂载阶段"><a href="#开始挂载阶段" class="header-anchor">#</a> 开始挂载阶段</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>this._init<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法的最后：

<span class="token punctuation">..</span>. 初始化

<span class="token keyword">if</span> <span class="token punctuation">(</span>vm.<span class="token variable">$options</span>.el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm.<span class="token variable">$mount</span><span class="token punctuation">(</span>vm.<span class="token variable">$options</span>.el<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果用户有传入el属性，就执行vm.$mount方法并传入el开始挂载。这里的$mount方法在完整版和运行时版本又会有点不同，他们区别如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>运行时版本：
Vue.prototype.<span class="token variable">$mount</span> <span class="token operator">=</span> function<span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span> // 最初的定义
  <span class="token builtin class-name">return</span> mountComponent<span class="token punctuation">(</span>this, query<span class="token punctuation">(</span>el<span class="token punctuation">))</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

完整版：
const <span class="token function">mount</span> <span class="token operator">=</span> Vue.prototype.<span class="token variable">$mount</span>
Vue.prototype.<span class="token variable">$mount</span> <span class="token operator">=</span> function<span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 拓展编译后的

  if<span class="token punctuation">(</span><span class="token operator">!</span>this.<span class="token variable">$options</span>.render<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ---<span class="token operator">|</span>
    if<span class="token punctuation">(</span>this.<span class="token variable">$options</span>.template<span class="token punctuation">)</span> <span class="token punctuation">{</span>         ---<span class="token operator">|</span>
      <span class="token punctuation">..</span>.经过编译器转换后得到render函数  ---<span class="token operator">|</span>  编译阶段
    <span class="token punctuation">}</span>                                    ---<span class="token operator">|</span>
  <span class="token punctuation">}</span>                                      ---<span class="token operator">|</span>
  
  <span class="token builtin class-name">return</span> mount.call<span class="token punctuation">(</span>this, query<span class="token punctuation">(</span>el<span class="token punctuation">))</span>
<span class="token punctuation">}</span>

-----------------------------------------------

<span class="token builtin class-name">export</span> <span class="token keyword">function</span> query<span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 获取挂载的节点
  if<span class="token punctuation">(</span>typeof el <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 比如<span class="token comment">#app</span>
    const selected <span class="token operator">=</span> document.querySelector<span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    if<span class="token punctuation">(</span><span class="token operator">!</span>selected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token builtin class-name">return</span> document.createElement<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token builtin class-name">return</span> selected
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> el
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>完整版有一个骚操作，首先将$mount方法缓存到mount变量上，然后使用函数劫持的手段重新定义$mount函数，并在其内部增加编译相关的代码，最后还是使用原来定义的$mount方法挂载。所以核心是要了解最初定义$mount方法时内的mountComponent方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> mountComponent<span class="token punctuation">(</span>vm, el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm.<span class="token variable">$el</span> <span class="token operator">=</span> el
  <span class="token punctuation">..</span>.
  callHook<span class="token punctuation">(</span>vm, <span class="token string">'beforeMount'</span><span class="token punctuation">)</span>
  <span class="token punctuation">..</span>.
  const updateComponent <span class="token operator">=</span> <span class="token function-name function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm._update<span class="token punctuation">(</span>vm._render<span class="token punctuation">(</span><span class="token punctuation">))</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>首先将传入的el赋值给vm.$el，这个时候el是一个真实dom，接着会执行用户自己定义的beforeMount钩子。接下来会定义一个重要的函数变量updateComponent，它的内部首先会执行vm._render()方法，将返回的结果传入vm._update()内再执行。我们这章主要就来分析这个vm._render()方法做了什么事情，来看下它的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype._render <span class="token operator">=</span> <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const vm <span class="token operator">=</span> this
  const <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> vm.<span class="token variable">$options</span>

  const vnode <span class="token operator">=</span> render.call<span class="token punctuation">(</span>vm, vm.<span class="token variable">$createElement</span><span class="token punctuation">)</span>
  
  <span class="token builtin class-name">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div><p>首先会得到自定义的render函数，传入vm.$createElement这个方法(也就是上面例子内的h方法)，将执行的返回结果赋值给vnode，这里也就完成了render函数内数据结构转为vnode的操作。而这个vm.$createElement是在之前初始化initRender方法内挂载到vm实例下的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vm._c <span class="token operator">=</span> <span class="token punctuation">(</span>a, b, c, d<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> createElement<span class="token punctuation">(</span>vm, a, b, c, d, <span class="token boolean">false</span><span class="token punctuation">)</span>  // 编译
vm.<span class="token variable">$createElement</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a, b, c, d<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> createElement<span class="token punctuation">(</span>vm, a, b, c, d, <span class="token boolean">true</span><span class="token punctuation">)</span>  // 手写
</code></pre></div><p>无论是编译而来还是手写的render函数，它们都是返回了createElement这个函数，继续查找它的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const SIMPLE_NORMALIZE <span class="token operator">=</span> <span class="token number">1</span>
const ALWAYS_NORMALIZE <span class="token operator">=</span> <span class="token number">2</span>

<span class="token builtin class-name">export</span> default createElement<span class="token punctuation">(</span>
  context, 
  tag, 
  data, 
  children, 
  normalizationType, 
  alwaysNormalize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">||</span> isPrimitive<span class="token punctuation">(</span>data<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // data是数组或基础类型
    normalizationType <span class="token operator">=</span> children  --<span class="token operator">|</span>
    children <span class="token operator">=</span> data               --<span class="token operator">|</span> 参数移位
    data <span class="token operator">=</span> undefined              --<span class="token operator">|</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isTrue<span class="token punctuation">(</span>alwaysNormalize<span class="token punctuation">))</span> <span class="token punctuation">{</span> // 如果是手写render
    normalizationType <span class="token operator">=</span> ALWAYS_NORMALIZE
  <span class="token punctuation">}</span>
  
  <span class="token builtin class-name">return</span> _createElement<span class="token punctuation">(</span>contenxt, tag, data, children, normalizationType<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里是对传入的参数处理，如果第三个参数传入的是数组(子元素)或者是基础类型的值，就将参数位置改变。然后对传入的最后一个参数是true还是false做处理，这会决定之后对children属性的处理方式。这里又是对_createElement做的封装，所以我们还要继续看它的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> _createElement<span class="token punctuation">(</span>
  context, tag, data, children, normalizationType
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>normalizationType <span class="token operator">==</span><span class="token operator">=</span> ALWAYS_NORMALIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span> // 手写render函数
    children <span class="token operator">=</span> normalizeChildren<span class="token punctuation">(</span>children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>normalizationType <span class="token operator">==</span><span class="token operator">=</span> SIMPLE_NORMALIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span> //编译render函数
    children <span class="token operator">=</span> simpleNormalizeChildren<span class="token punctuation">(</span>children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  if<span class="token punctuation">(</span>typeof tag <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 标签
    <span class="token builtin class-name">let</span> vnode, Ctor
    if<span class="token punctuation">(</span>config.isReservedTag<span class="token punctuation">(</span>tag<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 如果是html标签
      vnode <span class="token operator">=</span> new VNode<span class="token punctuation">(</span>tag, data, children, undefined, undefined, context<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> // 就是组件了
    vnode <span class="token operator">=</span> createComponent<span class="token punctuation">(</span>tag, data, context, children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
  <span class="token builtin class-name">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div><p>首先我们会看到针对最后一个参数的布尔值对children做不同的处理，如果是编译的render函数，就将children格式化为一维数组：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> simpleNormalizeChildren<span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 编译render的处理函数
  <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>
      <span class="token builtin class-name">return</span> Array.prototype.concat.apply<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>, children<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> children
<span class="token punctuation">}</span>
</code></pre></div><p>我们现在主要看下手写的render函数是怎么处理的，从接下来的_createElement方法我们知道，转化VNode是分为两种情况的：</p> <h3 id="_1-普通的元素节点转化为vnode"><a href="#_1-普通的元素节点转化为vnode" class="header-anchor">#</a> 1. 普通的元素节点转化为VNode</h3> <p>以一段children是二维数组代码为示例，我们来说明普通元素是如何转VNode的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>render<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> h<span class="token punctuation">(</span>
    <span class="token string">&quot;div&quot;</span>,
    <span class="token punctuation">[</span>
      <span class="token punctuation">[</span>
        <span class="token punctuation">[</span>h<span class="token punctuation">(</span><span class="token string">&quot;h1&quot;</span>, <span class="token string">&quot;title h1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>,
        <span class="token punctuation">[</span>h<span class="token punctuation">(</span><span class="token string">'h2'</span>, <span class="token string">&quot;title h2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
      <span class="token punctuation">]</span>,
      <span class="token punctuation">[</span>
        h<span class="token punctuation">(</span><span class="token string">'h3'</span>, <span class="token string">'title h3'</span><span class="token punctuation">)</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为_createElement方法是对h方法的封装，所以h方法的第一个参数对应的就是_createElement方法内的tag，第二个参数对应的是data。又因为h方法是递归的，所以首先从h('h1', 'title h1')开始解析，经过参数上移之后children就是title h1这段文本了，所以会在normalizeChildren方法将它转为[createTextVNode(children)]一个文本的VNode节点：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> normalizeChildren<span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 手写<span class="token variable"><span class="token variable">`</span>render<span class="token variable">`</span></span>的处理函数
  <span class="token builtin class-name">return</span> isPrimitive<span class="token punctuation">(</span>children<span class="token punctuation">)</span>  //原始类型 typeof为string/number/symbol/boolean之一
    ? <span class="token punctuation">[</span>createTextVNode<span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">]</span>  // 转为数组的文本节点
    <span class="token builtin class-name">:</span> Array.isArray<span class="token punctuation">(</span>children<span class="token punctuation">)</span>  // 如果是数组
      ? normalizeArrayChildren<span class="token punctuation">(</span>children<span class="token punctuation">)</span>
      <span class="token builtin class-name">:</span> undefined
<span class="token punctuation">}</span>
</code></pre></div><p>接着会满足_createElement方法内的这个条件：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>if<span class="token punctuation">(</span>typeof tag <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">{</span> tag为h1标签
  if<span class="token punctuation">(</span>config.isReservedTag<span class="token punctuation">(</span>tag<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 是html标签
    vnode <span class="token operator">=</span> new VNode<span class="token punctuation">(</span>
      tag,  // h1
      data, // undefined
      children,  转为了 <span class="token punctuation">[</span><span class="token punctuation">{</span>text: <span class="token string">'title h1'</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
      undefined,
      undefined,
      context
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">..</span>.
<span class="token builtin class-name">return</span> vnode

返回的vnode结构为：
<span class="token punctuation">{</span>
  tag: h1,
  children: <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> text: title h1 <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后依次处理h('h2', &quot;title h2&quot;)，h('h3', 'title h3')会得到三个VNode实例的节点。接着会执行最外层的h(div, [[VNode,VNode],[VNode]])方法，注意它的结构是二维数组，这个时候它就满足normalizeChildren方法内的Array.isArray(children)这个条件了，会执行normalizeArrayChildren这个方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> normalizeArrayChildren<span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  // 存放结果
  
  for<span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 遍历每一项
    <span class="token builtin class-name">let</span> c <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    if<span class="token punctuation">(</span>isUndef<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">||</span> typeof c <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'boolean'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> // 如果是undefined 或 布尔值
      <span class="token builtin class-name">continue</span>  // 跳过
    <span class="token punctuation">}</span>
    
    if<span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>c<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 如果某一项是数组
      if<span class="token punctuation">(</span>c.length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c <span class="token operator">=</span> normalizeArrayChildren<span class="token punctuation">(</span>c<span class="token punctuation">)</span> // 递归结果赋值给c，结果就是<span class="token punctuation">[</span>VNode<span class="token punctuation">]</span>
        <span class="token punctuation">..</span>. 合并相邻的文本节点
        res.push.apply<span class="token punctuation">(</span>res, c<span class="token punctuation">)</span>  //小操作
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token punctuation">..</span>.
      res.push<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><p>如果children内的某一项是数组就递归调用自己，将自身传入并将返回的结果覆盖自身，递归内的结果就是res.push(c)得到的，这里c也是[VNode]数组结构。覆盖自己之后执行res.push.apply(res, c)，添加到res内。这里vue秀了一个小操作，在一个数组内push一个数组，本来应该是二维数组的，使用这个写法后res.push.apply(res, c)后，结果最后是就是一维数组了。res最后返回的结果[VNode, VNode, VNode]，这也是children最终的样子。接着执行h('div', [VNode, VNode, VNode])方法，又满足了之前同样的条件：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>config.isReservedTag<span class="token punctuation">(</span>tag<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 标签为div
  vnode <span class="token operator">=</span> new VNode<span class="token punctuation">(</span>
    tag, data, children, undefined, undefined, context
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
<span class="token builtin class-name">return</span> vnode
</code></pre></div><p>所以最终得到的vnode结构就是这样的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">{</span>
  tag: <span class="token string">'div'</span>,
  children: <span class="token punctuation">[</span>VNode, VNode, VNode<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上就是普通元素节点转VNode的具体过程。</p> <h3 id="_2-组件转化为vnode"><a href="#_2-组件转化为vnode" class="header-anchor">#</a> 2. 组件转化为VNode</h3> <p>接下来我们来了解组件VNode的创建过程，常见示例如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>main.js
new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
  render<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> h<span class="token punctuation">(</span>App<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

app.vue
<span class="token function">import</span> Child from <span class="token string">'@/pages/child'</span>
<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  name: <span class="token string">'app'</span>,
  components: <span class="token punctuation">{</span>
    Child
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不知道大家有将引入的组件直接打印出来过没有，我们在main.js内打印下App组件：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">{</span>
  beforeCreate: <span class="token punctuation">[</span>ƒ<span class="token punctuation">]</span>
  beforeDestroy: <span class="token punctuation">[</span>ƒ<span class="token punctuation">]</span>
  components: <span class="token punctuation">{</span>Child: <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">}</span>
  name: <span class="token string">&quot;app&quot;</span>
  render: ƒ <span class="token punctuation">(</span><span class="token punctuation">)</span>
  staticRenderFns: <span class="token punctuation">[</span><span class="token punctuation">]</span>
  __file: <span class="token string">&quot;src/App.vue&quot;</span>
  _compiled: <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们只是定义了name和components属性，打印出来为什么会多了这么多属性？这是vue-loader解析后添加的，例如render: ƒ ()就是将App组件的template模板转换而来的，我们记住这个一个组件对象即可。</p> <p>让我们简单看一眼之前_createElement函数：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> _createElement<span class="token punctuation">(</span>
  context, tag, data, children, normalizationType
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  if<span class="token punctuation">(</span>typeof tag <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 标签
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> // 就是组件了
    vnode <span class="token operator">=</span> createComponent<span class="token punctuation">(</span>
      tag,  // 组件对象
      data,  // undefined
      context,  // 当前vm实例
      children  // undefined
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
  <span class="token builtin class-name">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div><p>很明显这里的tag并不一个string，转而会调用createComponent()方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> createComponent <span class="token punctuation">(</span>  // 上
  Ctor, data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>, context, children, tag
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const baseCtor <span class="token operator">=</span> context.<span class="token variable">$options</span>._base
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isObject<span class="token punctuation">(</span>Ctor<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 组件对象
    Ctor <span class="token operator">=</span> baseCtor.extend<span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span>  // 转为Vue的子类
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>这里要补充一点，在new Vue()之前定义全局API时：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> initGlobalAPI<span class="token punctuation">(</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  Vue.options._base <span class="token operator">=</span> Vue
  Vue.extend <span class="token operator">=</span> function<span class="token punctuation">(</span>extendOptions<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>经过初始化合并options之后当前实例就有了context.$options._base这个属性，然后执行它的extend这个方法，传入我们的组件对象，看下extend方法的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.cid <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin class-name">let</span> cid <span class="token operator">=</span> <span class="token number">1</span>
Vue.extend <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>extendOptions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const Super <span class="token operator">=</span> this  // Vue基类构造函数
  const name <span class="token operator">=</span> extendOptions.name <span class="token operator">||</span> Super.options.name
  
  const Sub <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 定义构造函数
    this._init<span class="token punctuation">(</span>options<span class="token punctuation">)</span>  // _init继承而来
  <span class="token punctuation">}</span>
  
  Sub.prototype <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>Super.prototype<span class="token punctuation">)</span>  // 继承基类Vue初始化定义的原型方法
  Sub.prototype.constructor <span class="token operator">=</span> Sub  // 构造函数指向子类
  Sub.cid <span class="token operator">=</span> cid++
  Sub.options <span class="token operator">=</span> mergeOptions<span class="token punctuation">(</span> // 子类合并options
    Super.options,  // components, directives, filters, _base
    extendOptions  // 传入的组件对象
  <span class="token punctuation">)</span>
  Sub<span class="token punctuation">[</span><span class="token string">'super'</span><span class="token punctuation">]</span> <span class="token operator">=</span> Super // Vue基类

  // 将基类的静态方法赋值给子类
  Sub.extend <span class="token operator">=</span> Super.extend
  Sub.mixin <span class="token operator">=</span> Super.mixin
  Sub.use <span class="token operator">=</span> Super.use

  ASSET_TYPES.forEach<span class="token punctuation">(</span>function <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span> // <span class="token punctuation">[</span><span class="token string">'component'</span>, <span class="token string">'directive'</span>, <span class="token string">'filter'</span><span class="token punctuation">]</span>
    Sub<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> Super<span class="token punctuation">[</span>type<span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  让组件可以递归调用自己，所以一定要定义name属性
    Sub.options.components<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> Sub  // 将子类挂载到自己的components属性下
  <span class="token punctuation">}</span>

  Sub.superOptions <span class="token operator">=</span> Super.options
  Sub.extendOptions <span class="token operator">=</span> extendOptions

  <span class="token builtin class-name">return</span> Sub
<span class="token punctuation">}</span>
</code></pre></div><p>仔细观察extend这个方法不难发现，我们传入的组件对象相当于就是之前new Vue(options)里面的options，也就是用户自定义的配置，然后和vue之前就定义的原型方法以及全局API合并，然后返回一个新的构造函数，它拥有Vue完整的功能。让我们继续createComponent的其他逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> createComponent <span class="token punctuation">(</span>  // 中
  Ctor, data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>, context, children, tag
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  const listeners <span class="token operator">=</span> data.on  // 父组件v-on传递的事件对象格式
  data.on <span class="token operator">=</span> data.nativeOn  // 组件的原生事件
  
  installComponentHooks<span class="token punctuation">(</span>data<span class="token punctuation">)</span>  // 为组件添加钩子方法
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>之前说明初始化事件initEvents时，这里的data.on就是父组件传递给子组件的事件对象，赋值给变量listeners；data.nativeOn是绑定在组件上有native修饰符的事件。接着会执行一个组件比较重要的方法installComponentHooks，它的作用是往组件的data属性下挂载hook这个对象，里面有init，prepatch，insert，destroy四个方法，这四个方法会在之后的将VNode转为真实Dom的patch阶段会用到，当我们使用到时再来看它们的定义是什么。我们继续createComponent的其他逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> createComponent <span class="token punctuation">(</span>  // 下
  Ctor, data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>, context, children, tag
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  const name <span class="token operator">=</span> Ctor.options.name <span class="token operator">||</span> tag  // 拼接组件tag用
  
  const vnode <span class="token operator">=</span> new VNode<span class="token punctuation">(</span>  // 创建组件VNode
    <span class="token variable"><span class="token variable">`</span>vue-component-$<span class="token punctuation">{</span>Ctor.cid<span class="token punctuation">}</span>$<span class="token punctuation">{</span>name ? <span class="token variable">`</span></span>-<span class="token variable">${name}</span><span class="token variable"><span class="token variable">`</span> <span class="token builtin class-name">:</span> <span class="token string">''</span><span class="token punctuation">}</span><span class="token variable">`</span></span>,  // 对应tag属性
    data, // 有父组件传递自定义事件和挂载的hook对象
    undefined,  // 对应children属性
    undefined,   // 对应text属性
    undefined,   // 对应elm属性
    context,  // 当前实例
    <span class="token punctuation">{</span>  // 对应componentOptions属性
      Ctor,  // 子类构造函数
      propsData, // props具体值的对象集合
      listeners,   // 父组件传递自定义事件对象集合
      tag,  // 使用组件时的名称
      children // 插槽内的内容，也是VNode格式
    <span class="token punctuation">}</span>,  
    asyncFactory
  <span class="token punctuation">)</span>
  
  <span class="token builtin class-name">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div><p>组件生成的VNode如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">{</span>
  tag: <span class="token string">'vue-component-1-app'</span>,
  context: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
  componentOptions: <span class="token punctuation">{</span>
    Ctor: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
    propsData: undefined,
    children: undefined,
    tag: undefined,
    children: undefined
  <span class="token punctuation">}</span>,
  data: <span class="token punctuation">{</span>
    on: undefined,  // 为原生事件
    data: <span class="token punctuation">{</span>
      init: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
      insert: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
      prepatch: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
      destroy: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果看到tag属性是vue-component开头就是组件了，以上就组件VNode的初始化。简单理解就是如果h函数的参数是组件对象，就将它转为一个Vue的子类，虽然组件VNode的children，text，ele为undefined，但它的独有属性componentOptions保存了组件需要的相关信息。它们的VNode生成了，接下来的章节我们将使用它们，将它们变为真实的Dom~。</p> <p>最后我们还是以一道vue可能会被问到的面试题作为本章的结束吧~</p> <h3 id="面试官微笑而又不失礼貌的问道-3"><a href="#面试官微笑而又不失礼貌的问道-3" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h3> <h4 id="请问vue-2为什么要引入虚拟dom-谈谈对虚拟dom的理解"><a href="#请问vue-2为什么要引入虚拟dom-谈谈对虚拟dom的理解" class="header-anchor">#</a> 请问vue@2为什么要引入虚拟Dom，谈谈对虚拟Dom的理解？</h4> <ul><li><p>1.随着现代应用对页面的功能要求越复杂，管理的状态越多，如果还是使用之前的JavaScript线程去频繁操作GUI线程的硕大Dom，对性能会有很大的损耗，而且也会造成状态难以管理，逻辑混乱等情况。引入虚拟Dom后，在框架的内部就将虚拟Dom树形结构与真实Dom做了映射，让我们不用在命令式的去操作Dom，可以将重心转为去维护这棵树形结构内的状态即可，状态的变化就会驱动Dom发生改变，具体的Dom操作vue帮我们完成，而且这些大部分可以在JavaScript线程完成，性能更高。</p></li> <li><p>2.虚拟Dom只是一种数据结构，可以让它不仅仅使用在浏览器环境，还可以用与SSR以及Weex等场景。</p></li></ul> <h2 id="vue原理解析-五-彻底搞懂虚拟dom到真实dom的生成过程"><a href="#vue原理解析-五-彻底搞懂虚拟dom到真实dom的生成过程" class="header-anchor">#</a> Vue原理解析（五）：彻底搞懂虚拟Dom到真实Dom的生成过程</h2> <p>再有一棵树形结构的JavaScript对象后，我们现在需要做的就是将这棵树跟真实的Dom树形成映射关系，首先简单回顾之前遇到的mountComponent方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> mountComponent<span class="token punctuation">(</span>vm, el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm.<span class="token variable">$el</span> <span class="token operator">=</span> el
  <span class="token punctuation">..</span>.
  callHook<span class="token punctuation">(</span>vm, <span class="token string">'beforeMount'</span><span class="token punctuation">)</span>
  <span class="token punctuation">..</span>.
  const updateComponent <span class="token operator">=</span> <span class="token function-name function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm._update<span class="token punctuation">(</span>vm._render<span class="token punctuation">(</span><span class="token punctuation">))</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>我们已经执行完了vm._render方法拿到了VNode，现在将它作为参数传给vm._update方法并执行。vm._update这个方法的作用就是就是将VNode转为真实的Dom，不过它有两个执行的时机：</p> <h3 id="首次渲染"><a href="#首次渲染" class="header-anchor">#</a> 首次渲染</h3> <ul><li>当执行new Vue到此时就是首次渲染了，会将传入的VNode对象映射为真实的Dom。</li></ul> <h3 id="更新页面"><a href="#更新页面" class="header-anchor">#</a> 更新页面</h3> <ul><li>数据变化会驱动页面发生变化，这也是vue最独特的特性之一，数据改变之前和之后会生成两份VNode进行比较，而怎么样在旧的VNode上做最小的改动去渲染页面，这样一个diff算法还是挺复杂的。如再没有先说清楚数据响应式是怎么回事之前，而直接讲diff对理解vue的整体流程并不太好。所以我们这章分析完首次渲染后，下一章就是数据响应式，之后才是diff比对，如此排序，万望理解。</li></ul> <p>我们现在先来看下vm._update方法的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype._update <span class="token operator">=</span> function<span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>. 首次渲染
  vm.<span class="token variable">$el</span> <span class="token operator">=</span> vm.__patch__<span class="token punctuation">(</span>vm.<span class="token variable">$el</span>, vnode<span class="token punctuation">)</span>  // 覆盖原来的vm.<span class="token variable">$el</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>这里的vm.$el是之前在mountComponent方法内就挂载的，一个真实Dom元素。首次渲染会传入vm.$el以及得到的VNode，所以看下vm.__patch__定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype.__patch__ <span class="token operator">=</span> createPatchFunction<span class="token punctuation">(</span><span class="token punctuation">{</span> nodeOps, modules <span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre></div><p>__patch__是createPatchFunction方法内部返回的一个方法，它接受一个对象：</p> <p>nodeOps属性：封装了操作原生Dom的一些方法的集合，如创建、插入、移除这些，再使用到的地方再详解。</p> <p>modules属性：创建真实Dom也需要生成它的如class/attrs/style等属性。modules是一个数组集合，数组的每一项都是这些属性对应的钩子方法，这些属性的创建、更新、销毁等都有对应钩子方法，当某一时刻需要做某件事，执行对应的钩子即可。比如它们都有create这个钩子方法，如将这些create钩子收集到一个数组内，需要在真实Dom上创建这些属性时，依次执行数组的每一项，也就是依次创建了它们。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Ps: 这里modules属性内的钩子方法是区分平台的，web、weex以及SSR它们调用VNode方法方式并不相同，所以vue在这里又使用了函数柯里化这个骚操作，在createPatchFunction内将平台的差异化抹平，从而__patch__方法只用接收新旧node即可。
</code></pre></div><h3 id="生成dom"><a href="#生成dom" class="header-anchor">#</a> 生成Dom</h3> <p>这里大家记住一句话即可，无论VNode是什么类型的节点，只有三种类型的节点会被创建并插入到的Dom中：元素节点、注释节点、和文本节点。</p> <p>我们接着来看下createPatchFunction它究竟返回一个什么样的方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> createPatchFunction<span class="token punctuation">(</span>backend<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  const <span class="token punctuation">{</span> modules, nodeOps <span class="token punctuation">}</span> <span class="token operator">=</span> backend  // 解构出传入的集合
  
  <span class="token builtin class-name">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>oldVnode, vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 接收新旧vnode
    <span class="token punctuation">..</span>.
    
    const isRealElement <span class="token operator">=</span> isDef<span class="token punctuation">(</span>oldVnode.nodeType<span class="token punctuation">)</span> // 是否是真实Dom
    if<span class="token punctuation">(</span>isRealElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // <span class="token variable">$el</span>是真实Dom
      oldVnode <span class="token operator">=</span> emptyNodeAt<span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span>  // 转为VNode格式覆盖自己
    <span class="token punctuation">}</span>
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首次渲染时没有oldVnode，oldVnode就是$el，一个真实的dom，经过emptyNodeAt(oldVnode)方法包装</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> emptyNodeAt<span class="token punctuation">(</span>elm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> new VNode<span class="token punctuation">(</span>
    nodeOps.tagName<span class="token punctuation">(</span>elm<span class="token punctuation">)</span>.toLowerCase<span class="token punctuation">(</span><span class="token punctuation">)</span>, // 对应tag属性
    <span class="token punctuation">{</span><span class="token punctuation">}</span>,  // 对应data
    <span class="token punctuation">[</span><span class="token punctuation">]</span>,   // 对应children
    undefined,  //对应text
    elm  // 真实dom赋值给了elm属性
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

包装后的：
<span class="token punctuation">{</span>
  tag: <span class="token string">'div'</span>,
  elm: <span class="token string">'&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;'</span> // 真实dom
<span class="token punctuation">}</span>

-------------------------------------------------------

nodeOps：
<span class="token builtin class-name">export</span> <span class="token keyword">function</span> tagName <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 返回节点的标签名
  <span class="token builtin class-name">return</span> node.tagName  
<span class="token punctuation">}</span>
</code></pre></div><p>再将传入的$el属性转为了VNode格式之后，我们继续：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> createPatchFunction<span class="token punctuation">(</span>backend<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token punctuation">..</span>.
  
  <span class="token builtin class-name">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>oldVnode, vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 接收新旧vnode
  
    const insertedVnodeQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">..</span>.
    const oldElm <span class="token operator">=</span> oldVnode.elm  //包装后的真实Dom <span class="token operator">&lt;</span>div <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">'app'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
    const parentElm <span class="token operator">=</span> nodeOps.parentNode<span class="token punctuation">(</span>oldElm<span class="token punctuation">)</span>  // 首次父节点为<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
    
    createElm<span class="token punctuation">(</span>  // 创建真实Dom
      vnode, // 第二个参数
      insertedVnodeQueue,  // 空数组
      parentElm,  // <span class="token operator">&lt;</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
      nodeOps.nextSibling<span class="token punctuation">(</span>oldElm<span class="token punctuation">)</span>  // 下一个节点
    <span class="token punctuation">)</span>
    
    <span class="token builtin class-name">return</span> vnode.elm // 返回真实Dom覆盖vm.<span class="token variable">$el</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
                                              
------------------------------------------------------

nodeOps：
<span class="token builtin class-name">export</span> <span class="token keyword">function</span> parentNode <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 获取父节点
  <span class="token builtin class-name">return</span> node.parentNode 
<span class="token punctuation">}</span>

<span class="token builtin class-name">export</span> <span class="token keyword">function</span> nextSibling<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 获取下一个节点
  <span class="token builtin class-name">return</span> node.nextSibing  
<span class="token punctuation">}</span>
</code></pre></div><p>createElm方法开始生成真实的Dom，VNode生成真实的Dom的方式还是分为元素节点和组件两种方式，所以我们使用上一章生成的VNode分别说明。</p> <h4 id="_1-元素节点生成dom"><a href="#_1-元素节点生成dom" class="header-anchor">#</a> 1. 元素节点生成Dom</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">{</span>  // 元素节点VNode
  tag: <span class="token string">'div'</span>,
  children: <span class="token punctuation">[</span><span class="token punctuation">{</span>
      tag: <span class="token string">'h1'</span>,
      children: <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>text: <span class="token string">'title h1'</span><span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>, <span class="token punctuation">{</span>
      tag: <span class="token string">'h2'</span>,
      children: <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>text: <span class="token string">'title h2'</span><span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>, <span class="token punctuation">{</span>
      tag: <span class="token string">'h3'</span>,
      children: <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>text: <span class="token string">'title h3'</span><span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大家可以先看下这个流程图有一个印象即可，接下来再看具体实现时相信思路会清晰很多：</p> <p><img src="/vuepress-blog/assets/img/01.60a16078.png" alt=""></p> <p>开始创建Dom，我们来看下它的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> createElm<span class="token punctuation">(</span>vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token punctuation">..</span>.
  const children <span class="token operator">=</span> vnode.children  // <span class="token punctuation">[</span>VNode, VNode, VNode<span class="token punctuation">]</span>
  const tag <span class="token operator">=</span> vnode.tag  // div
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>createComponent<span class="token punctuation">(</span>vnode, insertedVnodeQueue, parentElm, refElm<span class="token punctuation">))</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span>  // 如果是组件结果返回true，不会继续，之后详解createComponent
  <span class="token punctuation">}</span>
  
  if<span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>tag<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 元素节点
    vnode.elm <span class="token operator">=</span> nodeOps.createElement<span class="token punctuation">(</span>tag<span class="token punctuation">)</span>  // 创建父节点
    createChildren<span class="token punctuation">(</span>vnode, children, insertedVnodeQueue<span class="token punctuation">)</span>  // 创建子节点
    insert<span class="token punctuation">(</span>parentElm, vnode.elm, refElm<span class="token punctuation">)</span>  // 插入
    
  <span class="token punctuation">}</span> <span class="token keyword">else</span> if<span class="token punctuation">(</span>isTrue<span class="token punctuation">(</span>vnode.isComment<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 注释节点
    vnode.elm <span class="token operator">=</span> nodeOps.createComment<span class="token punctuation">(</span>vnode.text<span class="token punctuation">)</span>  // 创建注释节点
    insert<span class="token punctuation">(</span>parentElm, vnode.elm, refElm<span class="token punctuation">)</span><span class="token punctuation">;</span> // 插入到父节点
    
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  // 文本节点
    vnode.elm <span class="token operator">=</span> nodeOps.createTextNode<span class="token punctuation">(</span>vnode.text<span class="token punctuation">)</span>  // 创建文本节点
    insert<span class="token punctuation">(</span>parentElm, vnode.elm, refElm<span class="token punctuation">)</span>  // 插入到父节点
  <span class="token punctuation">}</span>
  
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>

------------------------------------------------------------------

nodeOps：
<span class="token builtin class-name">export</span> <span class="token keyword">function</span> createElement<span class="token punctuation">(</span>tagName<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 创建节点
  <span class="token builtin class-name">return</span> document.createElement<span class="token punctuation">(</span>tagName<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token builtin class-name">export</span> <span class="token keyword">function</span> createComment<span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>  //创建注释节点
  <span class="token builtin class-name">return</span> document.createComment<span class="token punctuation">(</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token builtin class-name">export</span> <span class="token keyword">function</span> createTextNode<span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 创建文本节点
  <span class="token builtin class-name">return</span> document.createTextNode<span class="token punctuation">(</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> insert <span class="token punctuation">(</span>parent, elm, ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>  //插入dom操作
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>parent<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 有父节点
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>ref<span class="token punctuation">))</span> <span class="token punctuation">{</span> // 有参考节点
      <span class="token keyword">if</span> <span class="token punctuation">(</span>ref.parentNode <span class="token operator">==</span><span class="token operator">=</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 参考节点的父节点等于传入的父节点
        nodeOps.insertBefore<span class="token punctuation">(</span>parent, elm, ref<span class="token punctuation">)</span>  // 在父节点内的参考节点之前插入elm
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      nodeOps.appendChild<span class="token punctuation">(</span>parent, elm<span class="token punctuation">)</span>  //  添加elm到parent内
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>  // 没有父节点什么都不做
<span class="token punctuation">}</span>
这算一个比较重要的方法，因为很多地方会用到。
</code></pre></div><p>依次判断是否是元素节点、注释节点、文本节点，分别创建它们然后插入到父节点里面，这里主要介绍创建元素节点，另外两个并没有复杂的逻辑。我们来看下createChild方法定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> createChild<span class="token punctuation">(</span>vnode, children, insertedVnodeQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>children<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 是数组
    for<span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children.length<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 遍历vnode每一项
      createElm<span class="token punctuation">(</span>  // 递归调用
        children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>, 
        insertedVnodeQueue, 
        vnode.elm, 
        null, 
        true, // 不是根节点插入
        children, 
        i
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> if<span class="token punctuation">(</span>isPrimitive<span class="token punctuation">(</span>vnode.text<span class="token punctuation">))</span> <span class="token punctuation">{</span>  //typeof为string/number/symbol/boolean之一
    nodeOps.appendChild<span class="token punctuation">(</span>  // 创建并插入到父节点
      vnode.elm, 
      nodeOps.createTextNode<span class="token punctuation">(</span>String<span class="token punctuation">(</span>vnode.text<span class="token punctuation">))</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

-------------------------------------------------------------------------------

nodeOps:
<span class="token builtin class-name">export</span> default appendChild<span class="token punctuation">(</span>node, child<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 添加子节点
  node.appendChild<span class="token punctuation">(</span>child<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>开始创建子节点，遍历VNode的每一项，每一项还是使用之前的createElm方法创建Dom。如果某一项又是数组，继续调用createChild创建某一项的子节点；如果某一项不是数组，创建文本节点并将它添加到父节点内。像这样使用递归的形式将嵌套的VNode全部创建为真实的Dom。</p> <p>再看一遍流程图，相信大家疑惑已经减少很多：</p> <p><img src="/vuepress-blog/assets/img/02.420ad81e.png" alt=""></p> <p>简单来说就是由里向外的挨个创建出真实的Dom，然后插入到它的父节点内，最后将创建好的Dom插入到body内，完成创建的过程，元素节点的创建还是比较简单的，我们接下来看下组件是怎么创建的。</p> <h4 id="_2-组件vnode生成dom"><a href="#_2-组件vnode生成dom" class="header-anchor">#</a> 2. 组件VNode生成Dom</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">{</span>  // 组件VNode
  tag: <span class="token string">'vue-component-1-app'</span>,
  context: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
  componentOptions: <span class="token punctuation">{</span>
    Ctor: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,  // 子组件构造函数
    propsData: undefined,
    children: undefined,
    tag: undefined,
    children: undefined
  <span class="token punctuation">}</span>,
  data: <span class="token punctuation">{</span>
    on: undefined,  // 原生事件
    hook: <span class="token punctuation">{</span>  // 组件钩子
      init: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
      insert: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
      prepatch: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
      destroy: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

-------------------------------------------

<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>  // app组件内模板
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>app text<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>
</code></pre></div><p>首先还是看张简易流程图，留个印象即可，方便理清之后的逻辑顺序：</p> <p><img src="/vuepress-blog/assets/img/03.95f69156.png" alt=""></p> <p>我们使用上一章组件生成的VNode，看下在createElm内创建组件Dom分支逻辑是怎么样的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> createElm<span class="token punctuation">(</span>vnode, insertedVnodeQueue, parentElm, refElm<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token punctuation">..</span>.
  <span class="token keyword">if</span> <span class="token punctuation">(</span>createComponent<span class="token punctuation">(</span>vnode, insertedVnodeQueue, parentElm, refElm<span class="token punctuation">))</span> <span class="token punctuation">{</span> // 组件分支
    <span class="token builtin class-name">return</span>  
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
</code></pre></div><p>执行createComponent方法，如果是元素节点不会返回任何东西，所以是undefined，会继续走接下来的创建元素节点的逻辑。现在是组件，我们看下createComponent的实现：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> createComponent<span class="token punctuation">(</span>vnode, insertedVnodeQueue, parentElm, refElm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> i <span class="token operator">=</span> vnode.data
  if<span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>i<span class="token punctuation">))</span> <span class="token punctuation">{</span>
    if<span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>i <span class="token operator">=</span> i.hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> isDef<span class="token punctuation">(</span>i <span class="token operator">=</span> i.init<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      i<span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>  // 执行init方法
    <span class="token punctuation">}</span>
    
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先会将组件的vnode.data赋值给i，是否有这个属性就能判断是否是组件vnode。之后的if(isDef(i = i.hook) &amp;&amp; isDef(i = i.init))集判断和赋值为一体，if内的i(vnode)就是执行的组件init(vnode)方法。这个时候我们来看下组件的init钩子方法做了什么：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">import</span> activeInstance  // 全局变量

const init <span class="token operator">=</span> vnode <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  const child <span class="token operator">=</span> vnode.componentInstance <span class="token operator">=</span> 
    createComponentInstanceForVnode<span class="token punctuation">(</span>vnode, activeInstance<span class="token punctuation">)</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>activeInstance是一个全局的变量，再update方法内赋值为当前实例，再当前实例做__patch__的过程中作为子组件的父实例传入，在子组件的initLifecycle时构建组件关系。将createComponentInstanceForVnode执行的结果赋值给了vnode.componentInstance，所以看下它的返回的结果是什么：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span>  createComponentInstanceForVnode<span class="token punctuation">(</span>vnode, parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // parent为全局变量activeInstance
  const options <span class="token operator">=</span> <span class="token punctuation">{</span>  // 组件的options
    _isComponent: true,  // 设置一个标记位，表明是组件
    _parentVnode: vnode, 
    parent  // 子组件的父vm实例，让初始化initLifecycle可以建立父子关系
  <span class="token punctuation">}</span>
  
  <span class="token builtin class-name">return</span> new vnode.componentOptions.Ctor<span class="token punctuation">(</span>options<span class="token punctuation">)</span>  // 子组件的构造函数定义为Ctor
<span class="token punctuation">}</span>
</code></pre></div><p>再组件的init方法内首先执行createComponentInstanceForVnode方法，这个方法的内部就会将子组件的构造函数实例化，因为子组件的构造函数继承了基类Vue的所有能力，这个时候相当于执行new Vue({...})，接下来又会执行_init方法进行一系列的子组件的初始化逻辑，我们回到_init方法内，因为它们之间还是有些不同的地方：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype._init <span class="token operator">=</span> function<span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options._isComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 组件的合并options，_isComponent为之前定义的标记位
    initInternalComponent<span class="token punctuation">(</span>this, options<span class="token punctuation">)</span>  // 区分是因为组件的合并项会简单很多
  <span class="token punctuation">}</span>
  
  initLifecycle<span class="token punctuation">(</span>vm<span class="token punctuation">)</span>  // 建立父子关系
  <span class="token punctuation">..</span>.
  callHook<span class="token punctuation">(</span>vm, <span class="token string">'created'</span><span class="token punctuation">)</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm.<span class="token variable">$options</span>.el<span class="token punctuation">)</span> <span class="token punctuation">{</span> // 组件是没有el属性的，所以到这里咋然而止
    vm.<span class="token variable">$mount</span><span class="token punctuation">(</span>vm.<span class="token variable">$options</span>.el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

----------------------------------------------------------------------------------------

<span class="token keyword">function</span> initInternalComponent<span class="token punctuation">(</span>vm, options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 合并子组件options
  const opts <span class="token operator">=</span> vm.<span class="token variable">$options</span> <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>vm.constructor.options<span class="token punctuation">)</span>
  opts.parent <span class="token operator">=</span> options.parent  // 组件init赋值，全局变量activeInstance
  opts._parentVnode <span class="token operator">=</span> options._parentVnode  // 组件init赋值，组件的vnode 
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>前面都还执行的好好的，最后却因为没有el属性，所以没有挂载，createComponentInstanceForVnode方法执行完毕。这个时候我们回到组件的init方法，补全剩下的逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const init <span class="token operator">=</span> vnode <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  const child <span class="token operator">=</span> vnode.componentInstance <span class="token operator">=</span> // 得到组件的实例
    createComponentInstanceForVnode<span class="token punctuation">(</span>vnode, activeInstance<span class="token punctuation">)</span>
    
  child.<span class="token variable">$mount</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span>  // 那就手动挂载呗
<span class="token punctuation">}</span>
</code></pre></div><p>我们在init方法内手动挂载这个组件，接着又会执行组件的_render()方法得到组件内元素节点VNode，然后执行vm._update()，执行组件的__patch__方法，因为$mount方法传入的是undefined，oldVnode也是undefined，会执行__patch__内的这段逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">return</span> <span class="token keyword">function</span> patch<span class="token punctuation">(</span>oldVnode, vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isUndef<span class="token punctuation">(</span>oldVnode<span class="token punctuation">))</span> <span class="token punctuation">{</span>
    createElm<span class="token punctuation">(</span>vnode, insertedVnodeQueue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>这次执行createElm时没有传入第三个参数父节点的，那组件创建好的Dom放哪生效了？没有父节点也要生成Dom不是，这个时候执行的是组件的__patch__，所以参数vnode就是组件内元素节点的vnode了：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span> // app组件内模板
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>app text<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>

-------------------------

<span class="token punctuation">{</span>  // app内元素vnode
  tag: <span class="token string">'div'</span>,
  children: <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>text: app text<span class="token punctuation">}</span>
  <span class="token punctuation">]</span>,
  parent: <span class="token punctuation">{</span>  // 子组件_init时执行initLifecycle建立的关系
    tag: <span class="token string">'vue-component-1-app'</span>,
    componentOptions: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>很明显这个时候不是组件了，即使是组件也没关系，大不了还是执行一遍createComponent创建组件的逻辑，因为总会有组件是由元素节点组成的。这个时候我们执行一遍创建元素节点的逻辑，因为没有第三个参数父节点，所以组件的Dom虽然创建好了，并不会在这里插入。请注意这个时候组件的init已经完成，但是组件的createComponent方法并没有完成，我们补全它的逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> createComponent<span class="token punctuation">(</span>vnode, insertedVnodeQueue, parentElm, refElm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> i <span class="token operator">=</span> vnode.data<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>i<span class="token punctuation">))</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>i <span class="token operator">=</span> i.hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> isDef<span class="token punctuation">(</span>i <span class="token operator">=</span> i.init<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      i<span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>  // init已经完成
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>vnode.componentInstance<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 执行组件init时被赋值
    
      initComponent<span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>  // 赋值真实dom给vnode.elm
      
      insert<span class="token punctuation">(</span>parentElm, vnode.elm, refElm<span class="token punctuation">)</span>  // 组件Dom在这里插入
      <span class="token punctuation">..</span>.
      <span class="token builtin class-name">return</span> <span class="token boolean">true</span>  // 所以会直接return
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

-----------------------------------------------------------------------

<span class="token keyword">function</span> initComponent<span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  vnode.elm <span class="token operator">=</span> vnode.componentInstance.<span class="token variable">$el</span>  // __patch__返回的真实dom
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>无论是嵌套多么深的组件，遇到组件的后就执行init，在init的__patch__过程中又遇到嵌套组件，那就再执行嵌套组件的init，嵌套组件完成__patch__后将真实的Dom插入到它的父节点内，接着执行完外层组件的__patch__又插入到它的父节点内，最后插入到body内，完成嵌套组件的创建过程，总之还是一个由里及外的过程。</p> <p>再回过头来看这张图，相信会好理解很多~</p> <p>{% asset_img 03.png This is an image %}</p> <p>我们再将本章最初的mountComponent之后的逻辑补充完整：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> mountComponent<span class="token punctuation">(</span>vm, el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  const updateComponent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    vm._update<span class="token punctuation">(</span>vm._render<span class="token punctuation">(</span><span class="token punctuation">))</span>
  <span class="token punctuation">}</span>
  
  new Watcher<span class="token punctuation">(</span>vm, updateComponent, noop, <span class="token punctuation">{</span>
    <span class="token function-name function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      if<span class="token punctuation">(</span>vm._isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        callHook<span class="token punctuation">(</span>vm, <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>   
  <span class="token punctuation">}</span>, <span class="token boolean">true</span><span class="token punctuation">)</span>
  
  <span class="token punctuation">..</span>.
  callHook<span class="token punctuation">(</span>vm, <span class="token string">'mounted'</span><span class="token punctuation">)</span>
  
  <span class="token builtin class-name">return</span> vm
<span class="token punctuation">}</span>
</code></pre></div><p>接下来会将updateComponent传入到一个Watcher的类中，这个类是干嘛的，我们下一章再说明，接下来执行mounted钩子方法。至此new Vue的整个流程就全部走完了。我们回顾下从new Vue开始它的执行顺序：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>new Vue <span class="token operator">==</span><span class="token operator">&gt;</span> vm._init<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> vm.<span class="token variable">$mount</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> vm._render<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">==</span><span class="token operator">&gt;</span> vm.update<span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> 
</code></pre></div><p>最后我们还是以一道vue可能会被问到的面试题作为本章的结束吧~</p> <h3 id="面试官微笑而又不失礼貌的问道-4"><a href="#面试官微笑而又不失礼貌的问道-4" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h3> <h4 id="父子两个组件同时定义了beforecreate、created、beforemounte、mounted四个钩子-它们的执行顺序是怎么样的"><a href="#父子两个组件同时定义了beforecreate、created、beforemounte、mounted四个钩子-它们的执行顺序是怎么样的" class="header-anchor">#</a> 父子两个组件同时定义了beforeCreate、created、beforeMounte、mounted四个钩子，它们的执行顺序是怎么样的？</h4> <ul><li>如果大家看完前面的章节，相信这个问题已经了然于胸了。首先会执行父组件的初始化过程，所以会依次执行beforeCreate、created、在执行挂载前又会执行beforeMount钩子，不过在生成真实dom的__patch__过程中遇到嵌套子组件后又会转为去执行子组件的初始化钩子beforeCreate、created，子组件在挂载前会执行beforeMounte，再完成子组件的Dom创建后执行mounted。这个父组件的__patch__过程才算完成，最后执行父组件的mounted钩子，这就是它们的执行顺序。执行顺序如下：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>parent beforeCreate
parent created
parent beforeMounte
    child beforeCreate
    child created
    child beforeMounte
    child mounted
parent mounted
</code></pre></div><h2 id="vue原理解析-六-全面深入理解响应式原理-上-对象基础篇"><a href="#vue原理解析-六-全面深入理解响应式原理-上-对象基础篇" class="header-anchor">#</a> Vue原理解析（六）：全面深入理解响应式原理(上)-对象基础篇</h2> <p>vue之所以能数据驱动视图发生变更的关键，就是依赖它的响应式系统了。响应式系统如果根据数据类型区分，对象和数组它们的实现会有所不同；解释响应式原理，如果只是为了说明响应式原理而说，但不是从整体流程出发，不在vue组件化的整体流程中找到响应式原理的位置，对深刻理解响应式原理并不太好。接下来笔者会从整体流程出发，试着站在巨人的肩膀上分别说明对象和数组的实现原理</p> <h3 id="对象的响应式原理"><a href="#对象的响应式原理" class="header-anchor">#</a> 对象的响应式原理</h3> <h4 id="对象响应式数据的创建"><a href="#对象响应式数据的创建" class="header-anchor">#</a> 对象响应式数据的创建</h4> <ul><li>在组件的初始化阶段，将对传入的状态进行初始化，以下以data为例，会将传入的数据包装为响应式的数据。</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>对象示例：

main.js
new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>  // 根组件
  render: h <span class="token operator">=</span><span class="token operator">&gt;</span> h<span class="token punctuation">(</span>App<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

--------------------------------------------------------------------------------------

app.vue
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>info.name<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>  // 只用了info.name属性
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>
<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>  // app组件
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      info: <span class="token punctuation">{</span>
        name: <span class="token string">'cc'</span>,
        sex: <span class="token string">'man'</span>  // 即使是响应式数据，没被使用就不会进行依赖收集
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来的分析将以上面代码为示例，这种结构其实是一个嵌套组件，只不过根组件一般定义的参数比较少而已，理解这个还是很重要的。</p> <p>在组件new Vue()后的执行vm._init()初始化过程中，当执行到initState(vm)时就会对内部使用到的一些状态，如props、data、computed、watch、methods分别进行初始化，再对data进行初始化的最后有这么一句：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> initData<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>  //初始化data
  <span class="token punctuation">..</span>.
  observe<span class="token punctuation">(</span>data<span class="token punctuation">)</span> //  info:<span class="token punctuation">{</span>name:<span class="token string">'cc'</span>,sex:<span class="token string">'man'</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个observe就是将用户定义的data变成响应式的数据，接下来看下它的创建过程：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> observe<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span><span class="token operator">!</span>isObject<span class="token punctuation">(</span>value<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 不是数组或对象，再见
    <span class="token builtin class-name">return</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> new Observer<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>简单理解这个observe方法就是Observer这个类的工厂方法，所以还是要看下Observer这个类的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> class Observer <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.value <span class="token operator">=</span> value
    this.walk<span class="token punctuation">(</span>value<span class="token punctuation">)</span>  // 遍历value
  <span class="token punctuation">}</span>
  
  walk<span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const keys <span class="token operator">=</span> Object.keys<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    for<span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      defineReactive<span class="token punctuation">(</span>obj, keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  // 只传入了两个参数
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当执行new Observer时，首先将传入的对象挂载到当前this下，然后遍历当前对象的每一项，执行defineReactive这个方法，看下它的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> defineReactive<span class="token punctuation">(</span>obj, key, val<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  const dep <span class="token operator">=</span> new Dep<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 依赖管理器
  
  val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // 计算出对应key的值
  observe<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  // 递归包装对象的嵌套属性
  
  Object.defineProperty<span class="token punctuation">(</span>obj, key, <span class="token punctuation">{</span>
    enumerable: true,
    configurable: true,
    <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">..</span>. 收集依赖
    <span class="token punctuation">}</span>,
    set<span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">..</span>. 派发更新
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个方法的作用就是使用Object.defineProperty创建响应式数据。首先根据传入的obj和key计算出val具体的值；如果val还是对象，那就使用observe方法进行递归创建，在递归的过程中使用Object.defineProperty将对象的每一个属性都变成响应式数据：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">..</span>.
<span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
    info: <span class="token punctuation">{</span>
      name: <span class="token string">'cc'</span>,
      sex: <span class="token string">'man'</span>
    <span class="token punctuation">}</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
这段代码就会有三个响应式数据：
  info, info.name, info.sex
</code></pre></div><div class="language-bash extra-class"><pre class="language-bash"><code>知识点：Object.defineProperty内的get方法，它的作用就是谁访问到当前key的值就用defineReactive内的dep将它收集起来，也就是依赖收集的意思。set方法的作用就是当前key的值被赋值了，就通知dep内收集到的依赖项，key的值发生了变更，视图请变更吧~
</code></pre></div><p>这个时候get和set只是定义了，并不会触发。什么是依赖我们接下来说明，首先还是用一张图帮大家理清响应式数据的创建过程：</p> <p><img src="/vuepress-blog/assets/img/04.b545fae4.png" alt=""></p> <h3 id="依赖收集"><a href="#依赖收集" class="header-anchor">#</a> 依赖收集</h3> <p>什么是依赖了？我们看下之前mountComponent的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> mountComponent<span class="token punctuation">(</span>vm, el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  const updateComponent <span class="token operator">=</span> <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm._update<span class="token punctuation">(</span>vm._render<span class="token punctuation">(</span><span class="token punctuation">))</span>
  <span class="token punctuation">}</span>
  
  new Watcher<span class="token punctuation">(</span>vm, updateComponent, noop, <span class="token punctuation">{</span>  // 渲染watcher
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>, <span class="token boolean">true</span><span class="token punctuation">)</span>  // true为标志，表示是否是渲染watcher
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>我们首先说明下这个Watcher类，它类似与之前的VNode类，根据传入的参数不同，可以分别实例化出三种不同的Watcher实例，它们分别是用户watcher，计算watcher以及渲染watcher：</p> <h4 id="用户-user-watcher"><a href="#用户-user-watcher" class="header-anchor">#</a> 用户(user) watcher</h4> <ul><li>也就是用户自己定义的，如：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
  data <span class="token punctuation">{</span>
    msg: <span class="token string">'hello Vue!'</span>
  <span class="token punctuation">}</span>
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$watch</span><span class="token punctuation">(</span><span class="token string">'msg'</span>, cb<span class="token punctuation">(</span><span class="token punctuation">))</span>  // 定义用户watcher
  <span class="token punctuation">}</span>,
  watch: <span class="token punctuation">{</span>
    <span class="token function-name function">msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>  // 定义用户watcher
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这里的两种方式内部都是使用Watcher这个类实例化的，只是参数不同，具体实现我们之后章节说明，这里大家只用知道这个是用户watcher即可。</p> <h4 id="计算-computed-watcher"><a href="#计算-computed-watcher" class="header-anchor">#</a> 计算(computed) watcher</h4> <ul><li>顾名思义，这个是当定义计算属性实例化出来的一种：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
  data: <span class="token punctuation">{</span>
    msg: <span class="token string">'hello'</span>  
  <span class="token punctuation">}</span>,
  <span class="token function-name function">computed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function-name function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 计算watcher
      <span class="token builtin class-name">return</span> this.msg + <span class="token string">'vue!'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><p>渲染(render) watcher</p></li> <li><p>只是用做视图渲染而定义的Watcher实例，再组件执行vm.$mount的最后会实例化Watcher类，这个时候就是以渲染watcher的格式定义的，收集的就是当前渲染watcher的实例，我们来看下它内部是如何定义的：</p></li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>class Watcher <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>vm, expOrFn, cb, options, isRenderWatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.vm <span class="token operator">=</span> vm
    if<span class="token punctuation">(</span>isRenderWatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 是否是渲染watcher
      vm._watcher <span class="token operator">=</span> this  // 当前组件下挂载vm._watcher属性
    <span class="token punctuation">}</span>
    vm._watchers.push<span class="token punctuation">(</span>this<span class="token punctuation">)</span>  //vm._watchers是之前初始化initState时定义的<span class="token punctuation">[</span><span class="token punctuation">]</span>
    this.before <span class="token operator">=</span> options.before  // 渲染watcher特有属性
    this.getter <span class="token operator">=</span> expOrFn  // 第二个参数
    this.get<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 实例化就会执行this.get<span class="token punctuation">(</span><span class="token punctuation">)</span>方法
  <span class="token punctuation">}</span>
  
  <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pushTarget<span class="token punctuation">(</span>this<span class="token punctuation">)</span>  // 添加
    <span class="token punctuation">..</span>.
    this.getter.call<span class="token punctuation">(</span>this.vm, this.vm<span class="token punctuation">)</span>  // 执行vm._update<span class="token punctuation">(</span>vm._render<span class="token punctuation">(</span><span class="token punctuation">))</span>
    <span class="token punctuation">..</span>.
    popTarget<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 移除
  <span class="token punctuation">}</span>
  
  addDep<span class="token punctuation">(</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">..</span>.
    dep.addSub<span class="token punctuation">(</span>this<span class="token punctuation">)</span>  // 将当前watcher收集到dep实例中
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当执行new Watcher的时候内部会挂载一些属性，然后执行this.get()这个方法，首先会执行一个全局的方法pushTarget(this)，传入当前watcher的实例，我们看下这个方法定义的地方：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Dep.target <span class="token operator">=</span> null
const targetStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  // 组件从父到子对应的watcher实例集合

<span class="token builtin class-name">export</span> <span class="token keyword">function</span> pushTarget <span class="token punctuation">(</span>_target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 添加
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep.target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    targetStack.push<span class="token punctuation">(</span>Dep.target<span class="token punctuation">)</span>  // 添加到集合内
  <span class="token punctuation">}</span>
  Dep.target <span class="token operator">=</span> _target  // 当前的watcher实例
<span class="token punctuation">}</span>

<span class="token builtin class-name">export</span> <span class="token keyword">function</span> <span class="token function-name function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 移除
  targetStack.pop<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 移除数组最后一项
  Dep.target <span class="token operator">=</span> targetStack<span class="token punctuation">[</span>targetStack.length - <span class="token number">1</span><span class="token punctuation">]</span>  // 赋值为数组最后一项
<span class="token punctuation">}</span>
</code></pre></div><p>首先会定义一个Dep类的静态属性Dep.target为null，这是一个全局会用到的属性，保存的是当前组件对应渲染watcher的实例；targetStack内存储的是再执行组件化的过程中每个组件对应的渲染watcher实例集合，使用的是一个先进后出的形式来管理数组的数据，这里可能有点不太好懂，稍等再看到最后的流程图后自然就明白了；然后将传入的watcher实例赋值给全局属性Dep.target，再之后的依赖收集过程中就是收集的它。</p> <p>watcher的get这个方法然后会执行getter这个方法，它是new Watcher时传入的第二个参数，这个参数就是之前的updateComponent变量：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> mountComponent<span class="token punctuation">(</span>vm, el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  const updateComponent <span class="token operator">=</span> <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  //第二个参数
    vm._update<span class="token punctuation">(</span>vm._render<span class="token punctuation">(</span><span class="token punctuation">))</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>只要一执行就会执行当前组件实例上的vm._update(vm._render())将render函数转为VNode，这个时候如果render函数内有使用到data中已经转为了响应式的数据，就会触发get方法进行依赖的收集，补全之前依赖收集的逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> defineReactive<span class="token punctuation">(</span>obj, key, val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const dep <span class="token operator">=</span> new Dep<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 依赖管理器
  
  val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // 计算出对应key的值
  observe<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  // 递归的转化对象的嵌套属性
  
  Object.defineProperty<span class="token punctuation">(</span>obj, key, <span class="token punctuation">{</span>
    enumerable: true,
    configurable: true,
    <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 触发依赖收集
      if<span class="token punctuation">(</span>Dep.target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 之前赋值的当前watcher实例
        dep.depend<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 收集起来，放入到上面的dep依赖管理器内
        <span class="token punctuation">..</span>.
      <span class="token punctuation">}</span>
      <span class="token builtin class-name">return</span> val
    <span class="token punctuation">}</span>,
    set<span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">..</span>. 派发更新
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个时候我们知道watcher是个什么东西了，简单理解就是数据和组件之间一个通信工具的封装，当某个数据被组件读取时，就将依赖数据的组件使用Dep这个类给收集起来。</p> <p>当前例子data内的属性是只有一个渲染watcher的，因为没有被其他组件所使用。但如果该属性被其他组件使用到，也会将使用它的组件收集起来，例如作为了props传递给了子组件，再dep的数组内就会存在多个渲染watcher。我们来看下Dep类这个依赖管理器的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> uid <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin class-name">export</span> default class Dep <span class="token punctuation">{</span>
  <span class="token function-name function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.id <span class="token operator">=</span> uid++
    this.subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  // 对象某个key的依赖集合
  <span class="token punctuation">}</span>
  
  addSub<span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 添加watcher实例到数组内
    this.subs.push<span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token function-name function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    if<span class="token punctuation">(</span>Dep.target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 已经被赋值为了watcher的实例
      Dep.target.addDep<span class="token punctuation">(</span>this<span class="token punctuation">)</span>  // 执行watcher的addDep方法
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

----------------------------------------------------------
class Watcher<span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  addDep<span class="token punctuation">(</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 将当前watcher实例添加到dep内
    <span class="token punctuation">..</span>.
    dep.addSub<span class="token punctuation">(</span>this<span class="token punctuation">)</span>  // 执行dep的addSub方法
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个Dep类的作用就是管理属性对应的watcher，如添加/删除/通知。至此，依赖收集的过程算是完成了，还是以一张图片加深对过程的理解：</p> <p><img src="/vuepress-blog/assets/img/05.ff0fb196.png" alt=""></p> <h4 id="派发更新"><a href="#派发更新" class="header-anchor">#</a> 派发更新</h4> <p>如果只是收集依赖，那其实是没任何意义的，将收集到的依赖在数据发生变化时通知到并引起视图变化，这样才有意义。如现在我们对数据重新赋值：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>app.vue
<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>  // app组件
  <span class="token punctuation">..</span>.
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">changeInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.info.name <span class="token operator">=</span> <span class="token string">'ww'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个时候就会触发创建响应式数据时的set方法了，我们再补全那里的逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token keyword">function</span> defineReactive<span class="token punctuation">(</span>obj, key, val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const dep <span class="token operator">=</span> new Dep<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 依赖管理器
  
  val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // 计算出对应key的值
  observe<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  // 递归转化对象的嵌套属性
  
  Object.defineProperty<span class="token punctuation">(</span>obj, key, <span class="token punctuation">{</span>
    enumerable: true,
    configurable: true,
    <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">..</span>. 依赖收集
    <span class="token punctuation">}</span>,
    set<span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 派发更新
      if<span class="token punctuation">(</span>newVal <span class="token operator">==</span><span class="token operator">=</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 相同
        <span class="token builtin class-name">return</span>
      <span class="token punctuation">}</span>
      val <span class="token operator">=</span> newVal  // 赋值
      observer<span class="token punctuation">(</span>newVal<span class="token punctuation">)</span>  // 如果新值是对象也递归包装
      dep.notify<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 通知更新
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当赋值触发set时，首先会检测新值和旧值，不能相同；然后将新值赋值给旧值；如果新值是对象则将它变成响应式的；最后让对应属性的依赖管理器使用dep.notify发出更新视图的通知。我们看下它的实现：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> uid <span class="token operator">=</span> <span class="token number">0</span>
class Dep<span class="token punctuation">{</span>
  <span class="token function-name function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.id <span class="token operator">=</span> uid++
    this.subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  
  <span class="token function-name function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 通知
    const subs <span class="token operator">=</span> this.subs.slice<span class="token punctuation">(</span><span class="token punctuation">)</span>
    for<span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span>, i <span class="token operator">&lt;</span> subs.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.update<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 挨个触发watcher的update方法
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里做的事情只有一件，将收集起来的watcher挨个遍历触发update方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Watcher<span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  <span class="token function-name function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    queueWatcher<span class="token punctuation">(</span>this<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

---------------------------------------------------------
const queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin class-name">let</span> has <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> queueWatcher<span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const <span class="token function">id</span> <span class="token operator">=</span> watcher.id
  if<span class="token punctuation">(</span>has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果某个watcher没有被推入队列
    <span class="token punctuation">..</span>.
    has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>  // 已经推入
    queue.push<span class="token punctuation">(</span>watcher<span class="token punctuation">)</span>  // 推入到队列
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
  nextTick<span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span>  // 下一个tick更新
<span class="token punctuation">}</span>
</code></pre></div><p>执行update方法时将当前watcher实例传入到定义的queueWatcher方法内，这个方法的作用是把将要执行更新的watcher收集到一个队列queue之内，保证如果同一个watcher内触发了多次更新，只会更新一次对应的watcher，我们举两个小示例：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>  // 都被模板引用了
      num: <span class="token number">0</span>,
      name: <span class="token string">'cc'</span>,
      sex: <span class="token string">'man'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">changeNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 赋值100次
      for<span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.num++
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>,
    <span class="token function-name function">changeInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 一次赋值多个属性的值
      this.name <span class="token operator">=</span> <span class="token string">'ww'</span>
      this.sex <span class="token operator">=</span> <span class="token string">'woman'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的三个响应式属性它们收集都是同一个渲染watcher。所以当赋值100次的情况出现时，再将当前的渲染watcher推入到的队列之后，之后赋值触发的set队列内并不会添加任何渲染watcher；当同时赋值多个属性时也是，因为它们收集的都是同一个渲染watcher，所以推入到队列一次之后就不会添加了。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>知识点：vue还是挺聪明的，通过这两个实例大家也看出来了，派发更新通知的粒度是组件级别，至于组件内是哪个属性赋值了，派发更新并不关心，而且怎么高效更新这个视图，那是之后diff比对做的事情。
</code></pre></div><p>队列有了，执行nextTick(flushSchedulerQueue)再下一次tick时更新它，这里的nextTick就是我们经常使用的this.$nextTick方法的原始方法，它们作用一致，实现原理之后章节说明。看下参数flushSchedulerQueue是个啥？</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> index <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">function</span> <span class="token function-name function">flushSchedulerQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> watcher, <span class="token function">id</span>
  queue.sort<span class="token punctuation">((</span>a, b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> a.id - b.id<span class="token punctuation">)</span>  // watcher 排序
  
  for<span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> queue.length<span class="token punctuation">;</span> index++<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 遍历队列
    watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>index<span class="token punctuation">]</span>  
    if<span class="token punctuation">(</span>watcher.before<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 渲染watcher独有属性
      watcher.before<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 触发 beforeUpdate 钩子
    <span class="token punctuation">}</span>
    <span class="token function">id</span> <span class="token operator">=</span> watcher.id
    has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> null
    watcher.run<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 真正的更新方法
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>原来是个函数，再nextTick方法的内部会执行第一个参数。首先会将queue这个队列进行一次排序，依据是每次new Watcher生成的id，以从小到大的顺序。当前示例只是做渲染，而且队列内只存在了一个渲染watcher，所以是不存在顺序的。但是如果有定义user watcher和computed watcher加上render watcher后，它们之间就会存在一个执行顺序的问题了。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>知识点：watcher的执行顺序是先父后子，然后是从computed watcher到user watcher最后render watcher，这从它们的初始化顺序就能看出。
</code></pre></div><p>然后就是遍历这个队列，因为是渲染watcher，所有是有before属性的，执行传入的before方法触发beforeUpdate钩子。最后执行watcher.run()方法，执行真正的派发更新方法。我们去看下run干了啥：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Watcher <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  <span class="token function-name function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>this.active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.getAndInvoke<span class="token punctuation">(</span>this.cb<span class="token punctuation">)</span> // 有一种要抓狂的感觉
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  getAndInvoke<span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 渲染watcher的cb为noop空函数
    const value <span class="token operator">=</span> this.get<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token punctuation">..</span>. 后面是用户watcher逻辑
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行run就是执行getAndInvoke方法，因为是渲染watcher，参数cb是noop空函数。看了这么多，其实...就是重新执行一次this.get()方法，让vm._update(vm._render())再走一遍而已。然后生成新旧VNode，最后进行diff比对以更新视图。</p> <p>最后我们来说下vue基于Object.defineProperty响应式系统的一些不足。如只能监听到数据的变化，所以有时data中要定义一堆的初始值，因为加入了响应式系统后才能被感知到；还有就是常规JavaScript操作对象的方式，并不能监听到增加以及删除，例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      info: <span class="token punctuation">{</span>
        name: <span class="token string">'cc'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">addInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 增加属性
      this.info.sex <span class="token operator">=</span> <span class="token string">'man'</span>
    <span class="token punctuation">}</span>,
    <span class="token function-name function">delInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 删除属性
      delete info.name
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>数据是被赋值了，但是视图并不会发生变更。vue为了解决这个问题，提供了两个API：$set和$delete，它们又是怎么办到的了？原理之后章节分析。</p> <p>最后惯例的面试问答就扯扯最近工作中遇到趣事吧。对于一个数据不会变更的列表，笔者把它定义再了created钩子内，很少结对编程，这次例外。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this.list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>旁边的妹子接过后：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>妹子： 这个列表怎么data里没有阿？在哪定义的？
我：我定义在created钩子里了。
妹子：你怎么定义在这了？
我：因为它是不会被变更的，所以不需要<span class="token punctuation">..</span>. 算了，那你移到data里吧。
妹子：嗯！？ 好。 小声说道：我还是第一次看见这么写的。
我：<span class="token punctuation">..</span>.有种被嫌弃了的感觉
</code></pre></div><h3 id="面试官微笑而又不失礼貌的问道-5"><a href="#面试官微笑而又不失礼貌的问道-5" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h3> <h4 id="当前组件模板中用到的变量一定要定义在data里么"><a href="#当前组件模板中用到的变量一定要定义在data里么" class="header-anchor">#</a> 当前组件模板中用到的变量一定要定义在data里么？</h4> <ul><li>data中的变量都会被代理到当前this下，所以我们也可以在this下挂载属性，只要不重名即可。而且定义在data中的变量在vue的内部会将它包装成响应式的数据，让它拥有变更即可驱动视图变化的能力。但是如果这个数据不需要驱动视图，定义在created或mounted钩子内也是可以的，因为不会执行响应式的包装方法，对性能也是一种提升。</li></ul> <h2 id="vue原理解析-七-全面深入理解响应式原理-下-数组进阶篇"><a href="#vue原理解析-七-全面深入理解响应式原理-下-数组进阶篇" class="header-anchor">#</a> Vue原理解析（七）：全面深入理解响应式原理(下)-数组进阶篇</h2> <div class="language-bash extra-class"><pre class="language-bash"><code>  sayHi<span class="token punctuation">(</span>friend<span class="token punctuation">)</span>
  
  <span class="token keyword">function</span> sayHi<span class="token punctuation">(</span>friend<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    if<span class="token punctuation">(</span>friend.status <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'不太理解响应式且还没有看过上一篇'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console.log<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>
        建议看下上一篇，因为算是响应式的基础了，
        不然可能这篇看起来会费点劲。
      <span class="token variable">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> if<span class="token punctuation">(</span>friend.status <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'之前看过上一篇了'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console.log<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>
        也可以瞟一眼，为了和这一篇相契合，部分地方做了增删改。
      <span class="token variable">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> if<span class="token punctuation">(</span>friend.status <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'我是大牛，就来看看你理解的怎么样'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console.log<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>
        大佬！里边请~
      <span class="token variable">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>我们首先来看下改变数组的两种方式：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list: <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">changeArr1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 方式一：重新赋值
      this.list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">5</span>, <span class="token number">6</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>,
    <span class="token function-name function">changeArr2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 方式二：方法改变
      this.list.push<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于这两种改变数据的方式，vue内部的实现并不相同。</p> <ul><li>方式一：重新赋值</li></ul> <p>实现原理和对象是一样的，再vm._render()时有用到list，就将依赖收集起来，重新赋值后走对象派发更新的那一套。</p> <ul><li>方式二：方法改变</li></ul> <p>走对象的那一套就不行了，因为并不是重新赋值，虽然改变了数组自身但并不会触发set，原有的响应式系统根本感知不到，所以我们接下来就分析，vue是如何解决使用数组方法改变自身触发视图的。</p> <h3 id="dep收集依赖的位置"><a href="#dep收集依赖的位置" class="header-anchor">#</a> Dep收集依赖的位置</h3> <p>上一篇它的声音并不大，现在我们来重新认识它。Dep类的主要作用就是管理依赖，在响应式系统中会有两个地方要实例化它，当然它们都会进行依赖的收集，首先是之前具体包装的时候：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> defineReactive<span class="token punctuation">(</span>obj, key, val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const dep <span class="token operator">=</span> new Dep<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 自动依赖管理器
  <span class="token punctuation">..</span>.
  Object.defineProperty<span class="token punctuation">(</span>obj, key, <span class="token punctuation">{</span>
    <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
    <span class="token function-name function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里它会对每个读取到的key都进行依赖收集，无论是对象/数组/原始类型，如果是通过重新赋值触发set就会使用这里收集到的依赖进行更新，笔者这里就把它命名为自动依赖管理器，方便和之后的区分。</p> <p>还有一个地方也会对它进行实例化就是Observer类中：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Observer <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.dep <span class="token operator">=</span> new Dep<span class="token punctuation">(</span><span class="token punctuation">)</span> //  手动依赖管理器
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个依赖管理器并不能通过set触发，而且是只会收集对象/数组的依赖。也就是说对象的依赖会被收集两次，一次在自动依赖管理器内，一次在这里，为什么要收集两次，本章之后说明。而最重要的是数组使用方法改变自身去触发更新的依赖就是再这收集的，这个前提还是很有必要交代下的。</p> <h3 id="数组的响应式原理"><a href="#数组的响应式原理" class="header-anchor">#</a> 数组的响应式原理</h3> <h4 id="数组响应式数据的创建"><a href="#数组响应式数据的创建" class="header-anchor">#</a> 数组响应式数据的创建</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>数组示例：
<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      list: <span class="token punctuation">[</span><span class="token punctuation">{</span>
        name: <span class="token string">'cc'</span>,
        sex: <span class="token string">'man'</span>
      <span class="token punctuation">}</span>, <span class="token punctuation">{</span>
        name: <span class="token string">'ww'</span>,
        sex: <span class="token string">'woman'</span>
      <span class="token punctuation">}</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>流程开始还是执行observe方法，接下来我们更加详细分析响应式系统：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> observe<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isObject<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> //不是数组或对象，再见
    <span class="token builtin class-name">return</span>
  <span class="token punctuation">}</span>
  
  <span class="token builtin class-name">let</span> ob
  if<span class="token punctuation">(</span>hasOwn<span class="token punctuation">(</span>value, <span class="token string">'__ob__'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value.__ob__ instanceof Observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 避免重复包装
    ob <span class="token operator">=</span> value.__ob__
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    ob <span class="token operator">=</span> new Observer<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> ob
<span class="token punctuation">}</span>
</code></pre></div><p>只要是响应式的数据都会有一个__ob__的属性，它是在Observer类中挂载的，如果已经有__ob__属性就直接赋值给ob，不会再次去创建Observer实例，避免重复包装。首次肯定没__ob__属性了，所以再重新看下Observer类的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Observer <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.value <span class="token operator">=</span> value
    this.dep <span class="token operator">=</span> new Dep<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 手动依赖管理器
    
    def<span class="token punctuation">(</span>value, <span class="token string">'__ob__'</span>, this<span class="token punctuation">)</span>  // 挂载__ob__属性，三个参数
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在看Observer类会丰富很多，首先定义一个手动依赖管理器，然后挂载一个不可枚举的__ob__属性到传入的参数下，表示它的一个响应式的数据，而且__ob__的值就是当前Observer类的实例，它拥有实例上的所有属性和方法，这很重要，我们接下来看下def是如何完成属性挂载的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> def <span class="token punctuation">(</span>obj, key, val, enumerable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object.defineProperty<span class="token punctuation">(</span>obj, key, <span class="token punctuation">{</span>
    value: val,
    enumerable: <span class="token operator">!</span><span class="token operator">!</span>enumerable,
    writable: true,
    configurable: <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实就是一个简单的封装，第四个参数不传，enumerable项就是不可枚举的了。接着看Observer类的定义：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Observer <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">..</span>.
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>value<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 数组
      <span class="token punctuation">..</span>.
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  // 对象
      this.walk<span class="token punctuation">(</span>value<span class="token punctuation">)</span>  // <span class="token punctuation">{</span>list: <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  walk <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const keys <span class="token operator">=</span> Object.keys<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      defineReactive<span class="token punctuation">(</span>obj, keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首次传入还是对象的格式，所以会执行walk遍历的将对象每个属性包装为响应式的，再来看下defineReactive方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> defineReactive<span class="token punctuation">(</span>obj, key, val<span class="token punctuation">)</span> <span class="token punctuation">{</span> 

  const dep <span class="token operator">=</span> new Dep<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 自动依赖管理器
  
  val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // val为数组 <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">]</span>
  
  <span class="token builtin class-name">let</span> childOb <span class="token operator">=</span> observe<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  // 返回Observer类实例
  
  Object.defineProperty<span class="token punctuation">(</span>obj, key, <span class="token punctuation">{</span>
    enumerable: true,
    configurable: true,
    <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 依赖收集
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep.target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep.depend<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 自动依赖管理器收集依赖
        <span class="token keyword">if</span> <span class="token punctuation">(</span>childOb<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 只有对象或数组才有返回值
          childOb.dep.depend<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 手动依赖管理器收集依赖
          <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>val<span class="token punctuation">))</span> <span class="token punctuation">{</span> 如果是数组
            dependArray<span class="token punctuation">(</span>val<span class="token punctuation">)</span> // 将数组每一项包装为响应式
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token builtin class-name">return</span> value
    <span class="token punctuation">}</span>,
    set<span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">..</span>.
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先递归执行observe(val)会有一个返回值了，如果是对象或数组的话，childOb就是Observer类的实例。所以在get内的childOb.dep.depend()执行的就是Observer类里定义的dep进行依赖收集，收集的render watcher跟自动依赖管理器是一样的。接下来如果是数组就执行dependArray方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> dependArray <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>let e, i <span class="token operator">=</span> <span class="token number">0</span>, i <span class="token operator">&lt;</span> value.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e <span class="token operator">=</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    e <span class="token operator">&amp;&amp;</span> e.__ob__ <span class="token operator">&amp;&amp;</span> e.__ob__.dep.depend<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 是响应式数据
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>e<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 如果是嵌套数组
      dependArray<span class="token punctuation">(</span>e<span class="token punctuation">)</span>  // 递归调用自己
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个方法的作用就是递归的为每一项收集依赖，这里每一项都必须要有__ob__属性，然后执行Observer类里的dep手动依赖收集器进行依赖收集。我们现在知道数组的依赖放哪了，现在关心的是在哪里去更新这个收集到的依赖。</p> <h3 id="数组方法更新依赖"><a href="#数组方法更新依赖" class="header-anchor">#</a> 数组方法更新依赖</h3> <p>回到defineReactive方法，看看let childOb = observe(val)这句代码：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> defineReactive<span class="token punctuation">(</span>obj, key, val<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token punctuation">..</span>.
  
  val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // val为数组 <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">]</span>
  <span class="token builtin class-name">let</span> childOb <span class="token operator">=</span> observe<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  // 看这句
  
  Object.defineProperty<span class="token punctuation">(</span>obj, key, <span class="token punctuation">{</span>
    enumerable: true,
    configurable: true,
    <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,
    set<span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过求值，val现在就是具体的数组，传入到observe内以数组的形式执行，我们又回到Observer类中：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Observer <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">..</span>.
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>value<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 数组
      
      const augment <span class="token operator">=</span> hasProto // 第一句
        ? protoAugment 
        <span class="token builtin class-name">:</span> copyAugment
      
      augment<span class="token punctuation">(</span>value, arrayMethods, arrayKeys<span class="token punctuation">)</span>  // 第二句
      
      this.observeArray<span class="token punctuation">(</span>value<span class="token punctuation">)</span>  // 第三句
      
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  // 对象
      <span class="token punctuation">..</span>.
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  observeArray<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span>, i <span class="token operator">&lt;</span> items.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      observe<span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-bash extra-class"><pre class="language-bash"><code>数组方法改变自身触发视图原理：首先覆盖数组的__proto__隐式原型，借用数组原生的方法，定义vue内部自定义的数组异变方法拦截原生方法，再调用异变方法改变自身之后手动触发依赖。
</code></pre></div><p>有了这只指向月亮的手，我们现在就一起去往心中的月亮。首先分析第一句：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const augment <span class="token operator">=</span> hasProto ? protoAugment <span class="token builtin class-name">:</span> copyAugment

--------------------------------------------------------

const hasProto <span class="token operator">=</span> <span class="token string">'__proto__'</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> protoAugment <span class="token punctuation">(</span>target, src<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // src为拦截器
  target.__proto__ <span class="token operator">=</span> src
<span class="token punctuation">}</span>

<span class="token keyword">function</span> copyAugment <span class="token punctuation">(</span>target, src, keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // src为拦截器
  <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    def<span class="token punctuation">(</span>target, key, src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>__proto__这个属性并不是所有浏览器都有的，笔者之前也一直以为这是一个通用属性，原来IE11才开始有这个属性，通过'<strong>protp</strong>' in {}也可以快速判断当前浏览浏览器是否IE10以上？确实用过，好用！</p> <p>是否有__proto__属性处理方法也不相同，如果有的的话，直接在protoAugment方法内使用拦截器覆盖；如果没有__proto__属性，那就在当前调用数组下挂载拦截器里的异变数组方法。</p> <p>实现原理都是根据原型链的特性，再数组使用原生方法之前加一个拦截器，拦截器内定义的都是可以改变数组自身的异变方法，如果拦截器内没有就向一层去找。</p> <p>接下来分析第二句，也是整个数组方法实现的核心：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>augment<span class="token punctuation">(</span>value, arrayMethods, arrayKeys<span class="token punctuation">)</span>

----------------------------------------------------------------------------

const arrayProto <span class="token operator">=</span> Array.prototype  // 数组原型，有所有数组原生方法
const arrayMethods <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>  // 创建空对象拦截器

const methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>  // 七个数组使用会改变自身的方法
  <span class="token string">'push'</span>,<span class="token string">'pop'</span>,<span class="token string">'shift'</span>,<span class="token string">'unshift'</span>,<span class="token string">'splice'</span>,<span class="token string">'sort'</span>,<span class="token string">'reverse'</span>
<span class="token punctuation">]</span>

methodsToPatch.forEach<span class="token punctuation">(</span>function <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 往拦截器下挂载异变方法

  const original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>  // 过滤出七个数组原生原始方法
  
  def<span class="token punctuation">(</span>arrayMethods, method, <span class="token keyword">function</span> mutator <span class="token punctuation">(</span><span class="token punctuation">..</span>.args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 不定参数
  
    const result <span class="token operator">=</span> original.apply<span class="token punctuation">(</span>this, args<span class="token punctuation">)</span>  // 借用原生方法，this就是调用的数组
    
    const ob <span class="token operator">=</span> this.__ob__  // 之前Observer类下挂载的__ob__
    
    <span class="token builtin class-name">let</span> inserted  // 临时保存数组新增的值
    switch <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token builtin class-name">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token builtin class-name">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token builtin class-name">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token builtin class-name">:</span>
        inserted <span class="token operator">=</span> args.slice<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ob.observeArray<span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>  // 执行Observer类中的observeArray方法
    <span class="token punctuation">}</span>
    ob.dep.notify<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 触发手动依赖收集器内的依赖
    
    <span class="token builtin class-name">return</span> result  // 返回数组执行结果
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

const arrayKeys <span class="token operator">=</span> Object.getOwnPropertyNames<span class="token punctuation">(</span>arrayMethods<span class="token punctuation">)</span> 
// 获取拦截器内挂载好的七个方法key的数组集合，用于没有__proto__的情况
</code></pre></div><p>首先获取数组的所有原生方法，从中过滤出七个调用可以改变自身的方法，然后创建拦截器在它下面挂载七个经过异变的方法，这个异变方法的使用效果和原生方法是一致的，因为就是使用apply借用的，将执行后的结果保存给result，比如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span>
const result <span class="token operator">=</span> arr.push<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre></div><p>这个时候arr就变成了[1,2,3,4]，result保存的就是新数组的长度，既然模仿就模仿的像一点。</p> <p>接下来的赋值const ob = this.<strong>ob</strong>，之前定义的__ob__不仅仅是标记位，保存的也是Observer类的实例。</p> <p>有三个操作数组的方法是会添加新值的，使用inserted变量保存新添的值。如果是使用splice方法，就将前面两个表示位置的参数截取掉。然后使用observeArray方法将新添加的参数包装为响应式的。</p> <p>最后通知手动依赖管理器内收集到的依赖派发更新，返回数组执行后的结果。</p> <p>最后执行第三句：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>this.observeArray<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
</code></pre></div><p>将数组内的是数组或对象的每一项都包装成响应式的。所以当数组再使用方法时，首先会去arrayMethods拦截器内查找是否是异变方法，不是的话才去调用数组原生方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      list: <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">changeArr1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.list.push<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  // 调用拦截器里的异变方法
    <span class="token punctuation">}</span>,
    <span class="token function-name function">changeArr2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.list <span class="token operator">=</span> this.list.concat<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> 
      // 调用原生方法，因为拦截器里没有，必须重新赋值因为不会改变自身
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此数组响应式系统相关的也讲解完毕，整个响应式系统也分析完了。我们来总结下吧，数组和对象它们收集依赖都是在get方法里，但是依赖存放位置并不同，对象是在defineReactive方法的dep内，数组是Observer类中的dep里；依赖的触发对象可以直接在set方法中派发更新，而数组是在自己定义的异变数组方法最后手动触发的。</p> <p>同样数组响应式也是不是完美的，它也有缺点：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      list: <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">changeListItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 改变数组某一项
      this.list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>
    <span class="token punctuation">}</span>,
    <span class="token function-name function">changeListLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 改变数组长度
      this.list.length <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上两种方式都改变了数组，但响应式是无法监听到的，因为不会触发set也没用使用数组方法去改变。不过大家还记得我们之前介绍的手动依赖管理器么？我们只要手动去通知它更新依赖就可以触发视图变更~</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      list: <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span>,
      info: <span class="token punctuation">{</span> name: <span class="token string">'cc'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">changeListItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 改变数组某一项
      this.list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>
      this.list.__ob__.dep.notify<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 手动通知
    <span class="token punctuation">}</span>,
    <span class="token function-name function">changeListLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 改变数组长度
      this.list.length <span class="token operator">=</span> <span class="token number">0</span>
      this.list.__ob__.dep.notify<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 手动通知
    <span class="token punctuation">}</span>,
    <span class="token function-name function">changeInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.info.sex <span class="token operator">=</span> <span class="token string">'man'</span>
      this.info.__ob__.dep.notify<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 对象也可以
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>常规的对象增加属性是不会被感知到的，也可以使用手动通知的形式触发依赖，知道这个原理还是很cool的~</p> <h3 id="官方填坑"><a href="#官方填坑" class="header-anchor">#</a> 官方填坑</h3> <p>上面的奇技淫巧并不被推荐使用，我们还是介绍下官方推荐的弥补响应式不足的两个API，$set和$delete，其实它们只是处理一些情况，都不满足的最后还是调了一下手动依赖管理器来实现，只是进行了简单的二次封装。</p> <h4 id="this-set-vue-set"><a href="#this-set-vue-set" class="header-anchor">#</a> this.$set || Vue.set</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> set<span class="token punctuation">(</span>target, key, val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>target<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 数组
    target.length <span class="token operator">=</span> Math.max<span class="token punctuation">(</span>target.length, key<span class="token punctuation">)</span>  // 最大值为长度
    target.splice<span class="token punctuation">(</span>key, <span class="token number">1</span>, val<span class="token punctuation">)</span>  // 移除一位，异变方法派发更新
    <span class="token builtin class-name">return</span> val
  <span class="token punctuation">}</span>
  
  if<span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> Object.prototype<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // key属于target
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val  // 赋值操作触发set
    <span class="token builtin class-name">return</span> val
  <span class="token punctuation">}</span>
  
  if<span class="token punctuation">(</span><span class="token operator">!</span>target.__ob__<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 普通对象赋值操作
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token builtin class-name">return</span> val
  <span class="token punctuation">}</span>
  
  defineReactive<span class="token punctuation">(</span>target.__ob__.value, key, val<span class="token punctuation">)</span>  // 将新值包装为响应式
  
  target.__ob__.dep.notify<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 手动触发通知
  
  <span class="token builtin class-name">return</span> val
<span class="token punctuation">}</span>
</code></pre></div><p>首先判断target是否是数组，是数组的话第二个参数就是长度了，设置数组的长度，然后使用splice这个异变方法插入val。
然后是判断key是否属于target，属于的话就是赋值操作了，这个会触发set去派发更新。接下来如果target并不是响应式数据，那就是普通对象，那就设置一个对应key吧。最后以上情况都不满足，说明是在响应式数据上新增了一个属性，把新增的属性转为响应式数据，然后通知手动依赖管理器派发更新。</p> <h4 id="this-delete-vue-delete"><a href="#this-delete-vue-delete" class="header-anchor">#</a> this.$delete || Vue.delete</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> del <span class="token punctuation">(</span>target, key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>target<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 数组
    target.splice<span class="token punctuation">(</span>key, <span class="token number">1</span><span class="token punctuation">)</span>  // 移除指定下表
    <span class="token builtin class-name">return</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasOwn<span class="token punctuation">(</span>target, key<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // key不属于target，再见
    <span class="token builtin class-name">return</span>
  <span class="token punctuation">}</span>
  
  delete target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // 删除对象指定key
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>target.__ob__<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 普通对象，再见
    <span class="token builtin class-name">return</span>
  <span class="token punctuation">}</span>
  target.__ob__.dep.notify<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 手动派发更新
<span class="token punctuation">}</span>
</code></pre></div><p>this.$delete就更加简单了，首先如果是数组就使用异变方法splice移除指定下标值。如果target是对象但key不属于它，再见。然后删除制定key的值，如果target不是响应式对象，删除的就是普通对象一个值，删了就删了。否则通知手动依赖管理器派发更新视图。</p> <p>最后按照惯例我们还是以一道vue可能会被问到的面试题作为本章的结束~</p> <h3 id="面试官微笑而又不失礼貌的问道-6"><a href="#面试官微笑而又不失礼貌的问道-6" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h3> <h4 id="请简单描述下vue响应式系统"><a href="#请简单描述下vue响应式系统" class="header-anchor">#</a> 请简单描述下vue响应式系统</h4> <ul><li>简单来说就是使用Object.defineProperty这个API为数据设置get和set。当读取到某个属性时，触发get将读取它的组件对应的render watcher收集起来；当重置赋值时，触发set通知组件重新渲染页面。如果数据的类型是数组的话，还做了单独的处理，对可以改变数组自身的方法进行重写，因为这些方法不是通过重新赋值改变的数组，不会触发set，所以要单独处理。响应系统也有自身的不足，所以官方给出了$set和$delete来弥补。</li></ul> <h2 id="vue原理解析-八-一起搞明白令人头疼的diff算法"><a href="#vue原理解析-八-一起搞明白令人头疼的diff算法" class="header-anchor">#</a> Vue原理解析（八）：一起搞明白令人头疼的diff算法</h2> <p>之前章节介绍了VNode如何生成真实Dom，这只是patch内首次渲染做的事，完成了一小部分功能而已，而它做的最重要的事情是当响应式触发时，让页面的重新渲染这一过程能高效完成。其实页面的重新渲染完全可以使用新生成的Dom去整个替换掉旧的Dom，然而这么做比较低效，所以就借助接下来将介绍的diff比较算法来完成。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>diff算法做的事情是比较VNode和oldVNode，再以VNode为标准的情况下在oldVNode上做小的改动，完成VNode对应的Dom渲染。
</code></pre></div><p>回到之前_update方法的实现，这个时候就会走到else的逻辑了：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype._update <span class="token operator">=</span> function<span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const vm <span class="token operator">=</span> this
  const prevVnode <span class="token operator">=</span> vm._vnode
  
  vm._vnode <span class="token operator">=</span> vnode  // 缓存为之前vnode
  
  if<span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 首次渲染
    vm.<span class="token variable">$el</span> <span class="token operator">=</span> vm.__patch__<span class="token punctuation">(</span>vm.<span class="token variable">$el</span>, vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  // 重新渲染
    vm.<span class="token variable">$el</span> <span class="token operator">=</span> vm.__patch__<span class="token punctuation">(</span>prevVnode, vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>既然是在现有的VNode上修修补补来达到重新渲染的目的，所以无非是做三件事情：</p> <ul><li>创建新增节点</li> <li>删除废弃节点</li> <li>更新已有节点</li></ul> <p>接下来我们将介绍以上三种情况分别什么情况下会遇到。</p> <h3 id="创建新增节点"><a href="#创建新增节点" class="header-anchor">#</a> 创建新增节点</h3> <p>新增节点两种情况下会遇到</p> <h4 id="vnode中有的节点而oldvnode没有"><a href="#vnode中有的节点而oldvnode没有" class="header-anchor">#</a> VNode中有的节点而oldVNode没有</h4> <ul><li>VNode中有的节点而oldVNode中没有，最明显的场景就是首次渲染了，这个时候是没有oldVNode的，所以将整个VNode渲染为真实Dom插入到根节点之内即可，这一详细过程之前章节有详细说明。</li></ul> <h4 id="vnode和oldvnode完全不同"><a href="#vnode和oldvnode完全不同" class="header-anchor">#</a> VNode和oldVNode完全不同</h4> <ul><li>当VNode和oldVNode不是同一个节点时，直接会将VNode创建为真实Dom，插入到旧节点的后面，这个时候旧节点就变成了废弃节点，移除以完成替换过程。
判断两个节点是否为同一个节点，内部是这样定义的：</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> sameVnode <span class="token punctuation">(</span>a, b<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 是否是相同的VNode节点
  <span class="token builtin class-name">return</span> <span class="token punctuation">(</span>
    a.key <span class="token operator">==</span><span class="token operator">=</span> b.key <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>  // 如平时v-for内写的key
      <span class="token punctuation">(</span>
        a.tag <span class="token operator">==</span><span class="token operator">=</span> b.tag <span class="token operator">&amp;&amp;</span>   // tag相同
        a.isComment <span class="token operator">==</span><span class="token operator">=</span> b.isComment <span class="token operator">&amp;&amp;</span>  // 注释节点
        isDef<span class="token punctuation">(</span>a.data<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> isDef<span class="token punctuation">(</span>b.data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>  // 都有data属性
        sameInputType<span class="token punctuation">(</span>a, b<span class="token punctuation">)</span>  // 相同的input类型
      <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>
        isTrue<span class="token punctuation">(</span>a.isAsyncPlaceholder<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>  // 是异步占位符节点
        a.asyncFactory <span class="token operator">==</span><span class="token operator">=</span> b.asyncFactory <span class="token operator">&amp;&amp;</span>  // 异步工厂方法
        isUndef<span class="token punctuation">(</span>b.asyncFactory.error<span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="删除废弃节点"><a href="#删除废弃节点" class="header-anchor">#</a> 删除废弃节点</h3> <p>上面创建新增节点的第二种情况以略有提及，比较vnode和oldVnode，如果根节点不相同就将Vnode整颗渲染为真实Dom，插入到旧节点的后面，最后删除掉已经废弃的旧节点即可：</p> <p><img src="/vuepress-blog/assets/img/06.da36ef41.png" alt=""></p> <p>在patch方法内将创建好的Dom插入到废弃节点后面之后：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>parentElm<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 在它们的父节点内删除旧节点
  removeVnodes<span class="token punctuation">(</span>parentElm, <span class="token punctuation">[</span>oldVnode<span class="token punctuation">]</span>, <span class="token number">0</span>, <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

-------------------------------------------------------------

<span class="token keyword">function</span> removeVnodes <span class="token punctuation">(</span>parentElm, vnodes, startIdx, endIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> startIdx <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> ++startIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const ch <span class="token operator">=</span> vnodes<span class="token punctuation">[</span>startIdx<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>ch<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      removeNode<span class="token punctuation">(</span>ch.elm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  // 移除从startIdx到endIdx之间的内容

------------------------------------------------------------

<span class="token keyword">function</span> removeNode<span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 单个节点移除
  const parent <span class="token operator">=</span> nodeOps.parentNode<span class="token punctuation">(</span>el<span class="token punctuation">)</span>
  if<span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>parent<span class="token punctuation">))</span> <span class="token punctuation">{</span>
    nodeOps.removeChild<span class="token punctuation">(</span>parent, el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="更新已有节点-重点"><a href="#更新已有节点-重点" class="header-anchor">#</a> 更新已有节点 (重点)</h3> <p>这个才是diff算法的重点，当两个节点是相同的节点时，这个时候就需要找出它们的不同之处，比较它们主要是使用patchVnode方法，这个方法里面主要也是处理几种分支情况：</p> <h4 id="都是静态节点"><a href="#都是静态节点" class="header-anchor">#</a> 都是静态节点</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> patchVnode<span class="token punctuation">(</span>oldVnode, vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode <span class="token operator">==</span><span class="token operator">=</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 完全一样
    <span class="token builtin class-name">return</span>
  <span class="token punctuation">}</span>

  const elm <span class="token operator">=</span> vnode.elm <span class="token operator">=</span> oldVnode.elm
  if<span class="token punctuation">(</span>isTrue<span class="token punctuation">(</span>vnode.isStatic<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> isTrue<span class="token punctuation">(</span>oldVnode.isStatic<span class="token punctuation">))</span> <span class="token punctuation">{</span>  
    vnode.componentInstance <span class="token operator">=</span> oldVnode.componentInstance
    <span class="token builtin class-name">return</span>  // 都是静态节点，跳过
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>什么是静态节点了？这是编译阶段做的事情，它会找出模板中的静态节点并做上标记(isStatic为true)，例如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>新鲜食材<span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>
</code></pre></div><p>这里的h2标签就不是静态节点，因为是根据插值变化的，而p标签就是静态节点，因为不会改变。如果都是静态节点就跳过这次比较，这也是编译阶段为diff比对做的优化。</p> <h4 id="vnode节点没有文本属性"><a href="#vnode节点没有文本属性" class="header-anchor">#</a> vnode节点没有文本属性</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> patchVnode<span class="token punctuation">(</span>oldVnode, vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  const elm <span class="token operator">=</span> vnode.elm <span class="token operator">=</span> oldVnode.elm
  const oldCh <span class="token operator">=</span> oldVnode.children
  const ch <span class="token operator">=</span> vnode.children

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isUndef<span class="token punctuation">(</span>vnode.text<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // vnode没有text属性
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> isDef<span class="token punctuation">(</span>ch<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // // 都有children
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">!=</span><span class="token operator">=</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 且children不同
        updateChildren<span class="token punctuation">(</span>elm, oldCh, ch<span class="token punctuation">)</span>  // 更新子节点
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>ch<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 只有vnode有children
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>oldVnode.text<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // oldVnode有文本节点
        nodeOps.setTextContent<span class="token punctuation">(</span>elm, <span class="token string">''</span><span class="token punctuation">)</span>  // 设置oldVnode文本为空
      <span class="token punctuation">}</span>
      addVnodes<span class="token punctuation">(</span>elm, null, ch, <span class="token number">0</span>, ch.length - <span class="token number">1</span><span class="token punctuation">)</span>
      // 往oldVnode空的标签内插入vnode的children的真实dom
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>oldCh<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 只有oldVnode有children
      removeVnodes<span class="token punctuation">(</span>elm, oldCh, <span class="token number">0</span>, oldCh.length - <span class="token number">1</span><span class="token punctuation">)</span>  // 全部移除
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>oldVnode.text<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // oldVnode有文本节点
      nodeOps.setTextContent<span class="token punctuation">(</span>elm, <span class="token string">''</span><span class="token punctuation">)</span>  // 设置为空
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
  
  <span class="token keyword">else</span> <span class="token punctuation">{</span>  vnode有text属性
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
  
  <span class="token punctuation">..</span>.
</code></pre></div><p>如果vnode没有文本节点，又会有接下来的四个分支：</p> <h5 id="_1-都有children且不相同"><a href="#_1-都有children且不相同" class="header-anchor">#</a> 1. 都有children且不相同</h5> <ul><li>使用updateChildren方法更详细的比对它们的children，如果说更新已有节点是patch的核心，那这里的更新children就是核心中的核心，这个之后使用流程图的方式仔仔细细说明。</li></ul> <h5 id="_2-只有vnode有children"><a href="#_2-只有vnode有children" class="header-anchor">#</a> 2. 只有vnode有children</h5> <ul><li>那这里的oldVnode要么是一个空标签或者是文本节点，如果是文本节点就清空文本节点，然后将vnode的children创建为真实Dom后插入到空标签内。</li></ul> <h5 id="_3-只有oldvnode有children"><a href="#_3-只有oldvnode有children" class="header-anchor">#</a> 3. 只有oldVnode有children</h5> <ul><li>因为是以vnode为标准的，所以vnode没有的东西，oldVnode内就是废弃节点，需要删除掉。</li></ul> <h5 id="_4-只有oldvnode有文本"><a href="#_4-只有oldvnode有文本" class="header-anchor">#</a> 4. 只有oldVnode有文本</h5> <ul><li>只要是oldVnode有而vnode没有的，清空或移除即可。</li></ul> <h4 id="vnode节点有文本属性"><a href="#vnode节点有文本属性" class="header-anchor">#</a> vnode节点有文本属性</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> patchVnode<span class="token punctuation">(</span>oldVnode, vnode, insertedVnodeQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  const elm <span class="token operator">=</span> vnode.elm <span class="token operator">=</span> oldVnode.elm
  const oldCh <span class="token operator">=</span> oldVnode.children
  const ch <span class="token operator">=</span> vnode.children

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isUndef<span class="token punctuation">(</span>vnode.text<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // vnode没有text属性
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span> <span class="token keyword">else</span> if<span class="token punctuation">(</span>oldVnode.text <span class="token operator">!=</span><span class="token operator">=</span> vnode.text<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // vnode有text属性且不同
    nodeOps.setTextContent<span class="token punctuation">(</span>elm, vnode.text<span class="token punctuation">)</span>  // 设置文本
  <span class="token punctuation">}</span>
  
  <span class="token punctuation">..</span>.
</code></pre></div><p>还是那句话，以vnode为标准，所以vnode有文本节点的话，无论oldVnode是什么类型节点，直接设置为vnode内的文本即可。至此，整个diff比对的大致过程就算是说明完毕了，我们还是以一张流程图来理清思路：</p> <p><img src="/vuepress-blog/assets/img/07.9ff10762.png" alt=""></p> <h3 id="更新已有节点之更新子节点-重点中的重点"><a href="#更新已有节点之更新子节点-重点中的重点" class="header-anchor">#</a> 更新已有节点之更新子节点 (重点中的重点)</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>更新子节点示例：
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>li v-for<span class="token operator">=</span><span class="token string">'item in list'</span> :key<span class="token operator">=</span><span class="token string">'item.id'</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>item.name<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/li<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>/ul<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      list: <span class="token punctuation">[</span><span class="token punctuation">{</span>
        id: <span class="token string">'a1'</span>,name: <span class="token string">'A'</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span>
        id: <span class="token string">'b2'</span>,name: <span class="token string">'B'</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span>
        id: <span class="token string">'c3'</span>,name: <span class="token string">'C'</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span>
        id: <span class="token string">'d4'</span>,name: <span class="token string">'D'</span><span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  <span class="token function-name function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      this.list.sort<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> Math.random<span class="token punctuation">(</span><span class="token punctuation">)</span> - .5<span class="token punctuation">)</span>
        .unshift<span class="token punctuation">(</span><span class="token punctuation">{</span>id: <span class="token string">'e5'</span>, name: <span class="token string">'E'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>, <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述代码中首先渲染一个列表，然后将其随机打乱顺序后并添加一项到列表最前面，这个时候就会触发该组件更新子节点的逻辑，之前也会有一些其他的逻辑，这里只用关注更新子节点相关，来看下它怎么更新Dom的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> updateChildren<span class="token punctuation">(</span>parentElm, oldCh, newCh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> oldStartIdx <span class="token operator">=</span> <span class="token number">0</span>  // 旧第一个下标
  <span class="token builtin class-name">let</span> oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  // 旧第一个节点
  <span class="token builtin class-name">let</span> oldEndIdx <span class="token operator">=</span> oldCh.length - <span class="token number">1</span>  // 旧最后下标
  <span class="token builtin class-name">let</span> oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>oldEndIdx<span class="token punctuation">]</span>  // 旧最后节点
  
  <span class="token builtin class-name">let</span> newStartIdx <span class="token operator">=</span> <span class="token number">0</span>  // 新第一个下标
  <span class="token builtin class-name">let</span> newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  // 新第一个节点
  <span class="token builtin class-name">let</span> newEndIdx <span class="token operator">=</span> newCh.length - <span class="token number">1</span>  // 新最后下标
  <span class="token builtin class-name">let</span> newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>newEndIdx<span class="token punctuation">]</span>  // 新最后节点
  
  <span class="token builtin class-name">let</span> oldKeyToIdx  // 旧节点key和下标的对象集合
  <span class="token builtin class-name">let</span> idxInOld  // 新节点key在旧节点key集合里的下标
  <span class="token builtin class-name">let</span> vnodeToMove  // idxInOld对应的旧节点
  <span class="token builtin class-name">let</span> refElm  // 参考节点
  
  checkDuplicateKeys<span class="token punctuation">(</span>newCh<span class="token punctuation">)</span> // 检测newVnode的key是否有重复
  
  while<span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 开始遍历children
  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isUndef<span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 跳过因位移留下的undefined
      oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>++oldStartIdx<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isUndef<span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 跳过因位移留下的undefine
      oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>--oldEndIdx<span class="token punctuation">]</span>  
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">else</span> if<span class="token punctuation">(</span>sameVnode<span class="token punctuation">(</span>oldStartVnode, newStartVnode<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 比对新第一和旧第一节点
      patchVnode<span class="token punctuation">(</span>oldStartVnode, newStartVnode<span class="token punctuation">)</span>  // 递归调用                        
      oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>++oldStartIdx<span class="token punctuation">]</span>  // 旧第一节点和下表重新标记后移        
      newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>++newStartIdx<span class="token punctuation">]</span>  // 新第一节点和下表重新标记后移        
    <span class="token punctuation">}</span>
    
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sameVnode<span class="token punctuation">(</span>oldEndVnode, newEndVnode<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 比对旧最后和新最后节点     
      patchVnode<span class="token punctuation">(</span>oldEndVnode, newEndVnode<span class="token punctuation">)</span>  // 递归调用                            
      oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>--oldEndIdx<span class="token punctuation">]</span>  // 旧最后节点和下表重新标记前移            
      newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>--newEndIdx<span class="token punctuation">]</span>  // 新最后节点和下表重新标记前移            
    <span class="token punctuation">}</span>
    
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sameVnode<span class="token punctuation">(</span>oldStartVnode, newEndVnode<span class="token punctuation">))</span> <span class="token punctuation">{</span> // 比对旧第一和新最后节点
      patchVnode<span class="token punctuation">(</span>oldStartVnode, newEndVnode<span class="token punctuation">)</span>  // 递归调用
      nodeOps.insertBefore<span class="token punctuation">(</span>parentElm, oldStartVnode.elm, nodeOps.nextSibling<span class="token punctuation">(</span>oldEndVnode.elm<span class="token punctuation">))</span>  
      // 将旧第一节点右移到最后，视图立刻呈现
      oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>++oldStartIdx<span class="token punctuation">]</span>  // 旧开始节点被处理，旧开始节点为第二个
      newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>--newEndIdx<span class="token punctuation">]</span>  // 新最后节点被处理，新最后节点为倒数第二个
    <span class="token punctuation">}</span>
    
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sameVnode<span class="token punctuation">(</span>oldEndVnode, newStartVnode<span class="token punctuation">))</span> <span class="token punctuation">{</span> // 比对旧最后和新第一节点
      patchVnode<span class="token punctuation">(</span>oldEndVnode, newStartVnode, insertedVnodeQueue<span class="token punctuation">)</span>  // 递归调用
      nodeOps.insertBefore<span class="token punctuation">(</span>parentElm, oldEndVnode.elm, oldStartVnode.elm<span class="token punctuation">)</span>
      // 将旧最后节点左移到最前面，视图立刻呈现
      oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>--oldEndIdx<span class="token punctuation">]</span>  // 旧最后节点被处理，旧最后节点为倒数第二个
      newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>++newStartIdx<span class="token punctuation">]</span>  // 新第一节点被处理，新第一节点为第二个
    <span class="token punctuation">}</span>
    
    <span class="token keyword">else</span> <span class="token punctuation">{</span>  // 不包括以上四种快捷比对方式
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isUndef<span class="token punctuation">(</span>oldKeyToIdx<span class="token punctuation">))</span> <span class="token punctuation">{</span>
        oldKeyToIdx <span class="token operator">=</span> createKeyToOldIdx<span class="token punctuation">(</span>oldCh, oldStartIdx, oldEndIdx<span class="token punctuation">)</span> 
        // 获取旧开始到结束节点的key和下表集合
      <span class="token punctuation">}</span>
      
      idxInOld <span class="token operator">=</span> isDef<span class="token punctuation">(</span>newStartVnode.key<span class="token punctuation">)</span>  // 获取新节点key在旧节点key集合里的下标
          ? oldKeyToIdx<span class="token punctuation">[</span>newStartVnode.key<span class="token punctuation">]</span>
          <span class="token builtin class-name">:</span> findIdxInOld<span class="token punctuation">(</span>newStartVnode, oldCh, oldStartIdx, oldEndIdx<span class="token punctuation">)</span>
      
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isUndef<span class="token punctuation">(</span>idxInOld<span class="token punctuation">))</span> <span class="token punctuation">{</span> // 找不到对应的下标，表示新节点是新增的，需要创建新dom
        createElm<span class="token punctuation">(</span>
          newStartVnode, 
          insertedVnodeQueue, 
          parentElm, 
          oldStartVnode.elm, 
          false, 
          newCh, 
          newStartIdx
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      
      <span class="token keyword">else</span> <span class="token punctuation">{</span>  // 能找到对应的下标，表示是已有的节点，移动位置即可
        vnodeToMove <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span>  // 获取对应已有的旧节点
        patchVnode<span class="token punctuation">(</span>vnodeToMove, newStartVnode, insertedVnodeQueue<span class="token punctuation">)</span>
        oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> undefined
        nodeOps.insertBefore<span class="token punctuation">(</span>parentElm, vnodeToMove.elm, oldStartVnode.elm<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      
      newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>++newStartIdx<span class="token punctuation">]</span>  // 新开始下标和节点更新为第二个节点
      
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token punctuation">..</span>.
  
<span class="token punctuation">}</span>
</code></pre></div><p>函数内首先会定义一堆let定义的变量，这些变量是随着while循环体而改变当前值的，循环的退出条件为只要新旧节点列表有一个处理完就退出，看着循环体代码挺复杂，其实它只是做了三件事，明白了哪三件事再看循环体，会发现其实并不复杂：</p> <h4 id="_1-跳过undefined"><a href="#_1-跳过undefined" class="header-anchor">#</a> 1. 跳过undefined</h4> <p>为什么会有undefined，之后的流程图会说明清楚。这里只要记住，如果旧开始节点为undefined，就后移一位；如果旧结束节点为undefined，就前移一位。</p> <h4 id="_2-快捷查找"><a href="#_2-快捷查找" class="header-anchor">#</a> 2. 快捷查找</h4> <p>首先会尝试四种快速查找的方式，如果不匹配，再做进一步处理：</p> <ul><li><p>2.1 新开始和旧开始节点比对
如果匹配，表示它们位置都是对的，Dom不用改，就将新旧节点开始的下标往后移一位即可。</p></li> <li><p>2.2 旧结束和新结束节点比对
如果匹配，也表示它们位置是对的，Dom不用改，就将新旧节点结束的下标前移一位即可。</p></li> <li><p>2.3 旧开始和新结束节点比对
如果匹配，位置不对需要更新Dom视图，将旧开始节点对应的真实Dom插入到最后一位，旧开始节点下标后移一位，新结束节点下标前移一位。</p></li> <li><p>2.4 旧结束和新开始节点比对
如果匹配，位置不对需要更新Dom视图，将旧结束节点对应的真实Dom插入到旧开始节点对应真实Dom的前面，旧结束节点下标前移一位，新开始节点下标后移一位。</p></li></ul> <h4 id="_3-key值查找"><a href="#_3-key值查找" class="header-anchor">#</a> 3. key值查找</h4> <ul><li><p>3.1 如果和已有key值匹配
那就说明是已有的节点，只是位置不对，那就移动节点位置即可。</p></li> <li><p>3.2 如果和已有key值不匹配
再已有的key值集合内找不到，那就说明是新的节点，那就创建一个对应的真实Dom节点，插入到旧开始节点对应的真实Dom前面即可。</p></li></ul> <p>这么说并不太好理解，结合之前的示例，根据以下的流程图将会明白很多：</p> <p><img src="/vuepress-blog/assets/img/08.f92e0f80.png" alt=""></p> <p>↑ 示例的初始状态就是这样了，之前定义的下标以及对应的节点就是start和end标记。</p> <p><img src="/vuepress-blog/assets/img/09.909f578d.png" alt=""></p> <p>↑ 首先进行之前说明两两四次的快捷比对，找不到后通过旧节点的key值列表查找，并没有找到说明E是新增的节点，创建对应的真实Dom，插入到旧节点里start对应真实Dom的前面，也就是A的前面，已经处理完了一个，新start位置后移一位。</p> <p><img src="/vuepress-blog/assets/img/10.0e2a3c46.png" alt=""></p> <p>↑ 接着开始处理第二个，还是首先进行快捷查找，没有后进行key值列表查找。发现是已有的节点，只是位置不对，那么进行插入操作，参考节点还是A节点，将原来旧节点C设置为undefined，这里之后会跳过它。又处理完了一个节点，新start后移一位。</p> <p><img src="/vuepress-blog/assets/img/11.a2f5f8e3.png" alt=""></p> <p>↑ 再处理第三个节点，通过快捷查找找到了，是新开始节点对应旧开始节点，Dom位置是对的，新start和旧start都后移一位。</p> <p><img src="/vuepress-blog/assets/img/12.1edfce55.png" alt=""></p> <p>↑ 接着处理的第四个节点，通过快捷查找，这个时候先满足了旧开始节点和新结束节点的匹配，Dom位置是不对的，插入节点到最后位置，最后将新end前移一位，旧start后移一位。</p> <p><img src="/vuepress-blog/assets/img/13.cf06becf.png" alt=""></p> <p>↑ 处理最后一个节点，首先会执行跳过undefined的逻辑，然后再开始快捷比对，匹配到的是新开始节点和旧开始节点，它们各自start后移一位，这个时候就会跳出循环了。接着看下最后的收尾代码：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> updateChildren<span class="token punctuation">(</span>parentElm, oldCh, newCh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> oldStartIdx <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">..</span>.
  
  while<span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&gt;</span> oldEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果旧节点列表先处理完，处理剩余新节点
    refElm <span class="token operator">=</span> isUndef<span class="token punctuation">(</span>newCh<span class="token punctuation">[</span>newEndIdx + <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ? null <span class="token builtin class-name">:</span> newCh<span class="token punctuation">[</span>newEndIdx + <span class="token number">1</span><span class="token punctuation">]</span>.elm
    addVnodes<span class="token punctuation">(</span>parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue<span class="token punctuation">)</span>  // 添加
  <span class="token punctuation">}</span> 
  
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newStartIdx <span class="token operator">&gt;</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果新节点列表先处理完，处理剩余旧节点
    removeVnodes<span class="token punctuation">(</span>parentElm, oldCh, oldStartIdx, oldEndIdx<span class="token punctuation">)</span>  // 删除废弃节点
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们之前的示例刚好是新旧节点列表同时处理完退出的循环，这里是退出循环后为还有没有处理完的节点，做不同的处理：</p> <p><img src="/vuepress-blog/assets/img/14.bbde1040.png" alt=""></p> <p>以新节点列表为标准，如果是新节点列表处理完，旧列表还有没被处理的废弃节点，删除即可；如果是旧节点先处理完，新列表里还有没被使用的节点，创建真实Dom并插入到视图即可。这就是整个diff算法过程了，大家可以对比之前的递归流程图再看一遍，相信思路会清晰很多。
最后按照惯例我们还是以一道vue可能会被问到的面试题作为本章的结束~</p> <h3 id="面试官微笑而又不失礼貌的问道-7"><a href="#面试官微笑而又不失礼貌的问道-7" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h3> <h4 id="为什么v-for里建议为每一项绑定key-而且最好具有唯一性-而不建议使用index"><a href="#为什么v-for里建议为每一项绑定key-而且最好具有唯一性-而不建议使用index" class="header-anchor">#</a> 为什么v-for里建议为每一项绑定key，而且最好具有唯一性，而不建议使用index？</h4> <ul><li>在diff比对内部做更新子节点时，会根据oldVnode内没有处理的节点得到一个key值和下标对应的对象集合，为的就是当处理vnode每一个节点时，能快速查找该节点是否是已有的节点，从而提高整个diff比对的性能。如果是一个动态列表，key值最好能保持唯一性，但像轮播图那种不会变更的列表，使用index也是没问题的。</li></ul> <h2 id="vue原理解析-九-监听属性watch和计算属性computed实现原理"><a href="#vue原理解析-九-监听属性watch和计算属性computed实现原理" class="header-anchor">#</a> Vue原理解析（九）：监听属性watch和计算属性computed实现原理</h2> <p>之前的八个章节，我们按照流程介绍了vue的初始化、虚拟Dom生成、虚拟Dom转为真实Dom、深入理解响应式以及diff算法等这些核心概念，对它内部的实现原理做了分析，相信大家对vue已经有了较深入的理解。现在我们来进一步丰富对vue的认识，开启API系列之旅，介绍日常开发中经常会使用到的API的实现原理，它们主要包括以下：</p> <ul><li><p>响应式相关API：this.$watch、this.$set、this.$delete</p></li> <li><p>事件相关API：this.$on、this.$off、this.$once、this.$emit</p></li> <li><p>生命周期相关API：this.$mount、this.$forceUpdate、this.$destroy</p></li> <li><p>全局API：Vue.extend、Vue.nextTick、Vue.set、Vue.delete、Vue.component、Vue.use、Vue.mixin、Vue.compile、Vue.version、Vue.directive、Vue.filter</p></li></ul> <h3 id="_1-this-watch"><a href="#_1-this-watch" class="header-anchor">#</a> 1. this.$watch</h3> <p>这个API是我们之前介绍响应式时的Watcher类的一种封装，也就是三种watcher中的user-watcher，监听属性经常会被这样使用到：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  watch: <span class="token punctuation">{</span>
    name<span class="token punctuation">(</span>newName<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实它只是this.$watch这个API的一种封装：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$watch</span><span class="token punctuation">(</span><span class="token string">'name'</span>, newName <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="监听属性初始化"><a href="#监听属性初始化" class="header-anchor">#</a> 监听属性初始化</h3> <p>为什么这么说，我们首先来看下初始化时watch属性都做了什么：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> initState<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 初始化所有状态时
  vm._watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  // 当前实例watcher集合
  const opts <span class="token operator">=</span> vm.<span class="token variable">$options</span>  // 合并后的属性
  
  <span class="token punctuation">..</span>. // 其他状态初始化
  
  if<span class="token punctuation">(</span>opts.watch<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果有定义watch属性
    initWatch<span class="token punctuation">(</span>vm, opts.watch<span class="token punctuation">)</span>  // 执行初始化方法
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

---------------------------------------------------------

<span class="token keyword">function</span> initWatch <span class="token punctuation">(</span>vm, <span class="token function">watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 初始化方法
  <span class="token keyword">for</span> <span class="token punctuation">(</span>const key <span class="token keyword">in</span> <span class="token function">watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 遍历watch内多个监听属性
    const handler <span class="token operator">=</span> watch<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // 每一个监听属性的值
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>handler<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 如果该项的值为数组
      <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> handler.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        createWatcher<span class="token punctuation">(</span>vm, key, handler<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  // 将每一项使用watcher包装
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      createWatcher<span class="token punctuation">(</span>vm, key, handler<span class="token punctuation">)</span> // 不是数组直接使用watcher
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

---------------------------------------------------------

<span class="token keyword">function</span> createWatcher <span class="token punctuation">(</span>vm, expOrFn, handler, options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isPlainObject<span class="token punctuation">(</span>handler<span class="token punctuation">))</span> <span class="token punctuation">{</span> // 如果是对象，参数移位
    options <span class="token operator">=</span> handler  
    handler <span class="token operator">=</span> handler.handler
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>typeof handler <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果是字符串，表示为方法名
    handler <span class="token operator">=</span> vm<span class="token punctuation">[</span>handler<span class="token punctuation">]</span>  // 获取methods内的方法
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> vm.<span class="token variable">$watch</span><span class="token punctuation">(</span>expOrFn, handler, options<span class="token punctuation">)</span>  // 封装
<span class="token punctuation">}</span>
</code></pre></div><p>以上对监听属性的多种不同的使用方式，都做了处理。使用示例在官网上均可找到：watch示例，这里就不做过多的介绍了。可以看到最后是调用了<a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener noreferrer">vm.$watch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>方法。</p> <h3 id="监听属性实现原理"><a href="#监听属性实现原理" class="header-anchor">#</a> 监听属性实现原理</h3> <p>所以我们来看下$watch的内部实现：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype.<span class="token variable">$watch</span> <span class="token operator">=</span> function<span class="token punctuation">(</span>expOrFn, cb, options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const vm <span class="token operator">=</span> this
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isPlainObject<span class="token punctuation">(</span>cb<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 如果cb是对象，当手动创建监听属性时
    <span class="token builtin class-name">return</span> createWatcher<span class="token punctuation">(</span>vm, expOrFn, cb, options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  options.user <span class="token operator">=</span> <span class="token boolean">true</span>  // user-watcher的标志位，传入Watcher类中
  const watcher <span class="token operator">=</span> new Watcher<span class="token punctuation">(</span>vm, expOrFn, cb, options<span class="token punctuation">)</span>  // 实例化user-watcher
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options.immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 立即执行
    cb.call<span class="token punctuation">(</span>vm, watcher.value<span class="token punctuation">)</span>  // 以当前值立即执行一次回调函数
  <span class="token punctuation">}</span>  // watcher.value为实例化后返回的值
  
  <span class="token builtin class-name">return</span> <span class="token keyword">function</span> <span class="token function-name function">unwatchFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 返回一个函数，执行取消监听
    watcher.teardown<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

---------------------------------------------------------------

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      name: <span class="token string">'cc'</span>
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>,
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.unwatch <span class="token operator">=</span> this.<span class="token variable">$watch</span><span class="token punctuation">(</span><span class="token string">'name'</span>, newName <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span>
    this.unwatch<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 取消监听
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>虽然watch内部是使用this.$watch，但是我们也是可以手动调用this.$watch来创建监听属性的，所以第二个参数cb会出现是对象的情况。接下来设置一个标记位options.user为true，表明这是一个user-watcher。再给watch设置了immediate属性后，会将实例化后得到的值传入回调，并立即执行一次回调函数，这也是immediate的实现原理。最后的返回值是一个方法，执行后可以取消对该监听属性的监听。接下来我们看看user-watcher是如何定义的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Watcher <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>vm, expOrFn, cb, options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.vm <span class="token operator">=</span> vm
    vm._watchers.push<span class="token punctuation">(</span>this<span class="token punctuation">)</span>  // 添加到当前实例的watchers内
    
    if<span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.deep <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options.deep  // 是否深度监听
      this.user <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options.user  // 是否是user-wathcer
      this.sync <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options.sync  // 是否同步更新
    <span class="token punctuation">}</span>
    
    this.active <span class="token operator">=</span> <span class="token boolean">true</span>  // // 派发更新的标志位
    this.cb <span class="token operator">=</span> cb  // 回调函数
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>typeof expOrFn <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果expOrFn是函数
      this.getter <span class="token operator">=</span> expOrFn
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      this.getter <span class="token operator">=</span> parsePath<span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span>  // 如果是字符串对象路径形式，返回闭包函数
    <span class="token punctuation">}</span>
    
    <span class="token punctuation">..</span>.
    
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当是user-watcher时，Watcher内部是以上方式实例化的，通常情况下我们是使用字符串的形式创建监听属性，所以首先来看下parsePath方法是干什么的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const bailRE <span class="token operator">=</span> /<span class="token punctuation">[</span>^<span class="token punctuation">\</span>w.$<span class="token punctuation">]</span>/  // 得是对象路径形式，如info.name

<span class="token keyword">function</span> parsePath <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>bailRE.test<span class="token punctuation">(</span>path<span class="token punctuation">))</span> <span class="token builtin class-name">return</span> // 不匹配对象路径形式，再见
  
  const segments <span class="token operator">=</span> path.split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>  // 按照点分割为数组
  
  <span class="token builtin class-name">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 闭包返回一个函数
    <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> segments.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span> <span class="token builtin class-name">return</span>
      obj <span class="token operator">=</span> obj<span class="token punctuation">[</span>segments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>  // 依次读取到实例下对象末端的值
    <span class="token punctuation">}</span>
    <span class="token builtin class-name">return</span> obj
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>parsePath方法最终返回一个闭包方法，此时Watcher类中的this.getter就是一个函数了，再执行this.get()方法时会将this.vm传入到闭包内，补全Watcher其他的逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Watcher <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>vm, expOrFn, cb, options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token punctuation">..</span>.
    this.getter <span class="token operator">=</span> parsePath<span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span>  // 返回的方法
    
    this.value <span class="token operator">=</span> this.get<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 执行get
  <span class="token punctuation">}</span>
  
  <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pushTarget<span class="token punctuation">(</span>this<span class="token punctuation">)</span>  // 将当前user-watcher实例赋值给Dep.target，读取时收集它
    
    <span class="token builtin class-name">let</span> value <span class="token operator">=</span> this.getter.call<span class="token punctuation">(</span>this.vm, this.vm<span class="token punctuation">)</span>  // 将vm实例传给闭包，进行读取操作
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>this.deep<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果有定义deep属性
      traverse<span class="token punctuation">(</span>value<span class="token punctuation">)</span>  // 进行深度监听
    <span class="token punctuation">}</span>
    
    popTarget<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token builtin class-name">return</span> value  // 返回闭包读取到的值，参数immediate使用的就是这里的值
  <span class="token punctuation">}</span>
  
  <span class="token punctuation">..</span>.
  
<span class="token punctuation">}</span>
</code></pre></div><p>因为之前初始化已经将状态已经全部都代理到了this下，所以读取this下的属性即可，比如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // data的初始化先与watch
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      info: <span class="token punctuation">{</span>
        name: <span class="token string">'cc'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$watch</span><span class="token punctuation">(</span><span class="token string">'info.name'</span>, newName <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span>  // 何况手动创建
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先读取this下的info属性，然后读取info下的name属性。大家注意，这里我们使用了读取这个动词，所以会执行之前包装data响应式数据的get方法进行依赖收集，将依赖收集到读取到的属性的dep里，不过收集的是user-watcher，get方法最后返回闭包读取到的值。</p> <p>之后就是当info.name属性被重新赋值时，走派发更新的流程，我们这里把和render-watcher不同之处做单独的说明，派发更新会执行Watcher内的update方法内：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Watcher <span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>vm, expOrFn, cb, options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
  
  <span class="token function-name function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 执行派发更新
    if<span class="token punctuation">(</span>this.sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果有设置sync为true
      this.run<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 不走nextTick队列，直接执行
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      queueWatcher<span class="token punctuation">(</span>this<span class="token punctuation">)</span>  // 否则加入队列，异步执行run<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token function-name function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>this.active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.getAndInvoke<span class="token punctuation">(</span>this.cb<span class="token punctuation">)</span>  // 传入回调函数
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  getAndInvoke<span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const value <span class="token operator">=</span> this.get<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 重新求值
    
    if<span class="token punctuation">(</span>value <span class="token operator">!=</span><span class="token operator">=</span> this.value <span class="token operator">||</span> isObject<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> this.deep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      const oldValue <span class="token operator">=</span> this.value  // 缓存之前的值
      this.value <span class="token operator">=</span> value  // 新值
      if<span class="token punctuation">(</span>this.user<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果是user-watcher
        cb.call<span class="token punctuation">(</span>this.vm, value, oldValue<span class="token punctuation">)</span>  // 在回调内传入新值和旧值
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实这里的sync属性已经没在官网做说明了，不过我们看到源码中还是保留了相关代码。接下来我们看到为什么watch的回调内可以得到新值和旧值的原理，因为cb.call(this.vm, value, oldValue)这句代码的原因，内部将新值和旧值传给了回调函数。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>watch监听属性示例：
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>  
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>  // App组件
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      name: <span class="token string">'cc'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  watch: <span class="token punctuation">{</span>
    name<span class="token punctuation">(</span>newName, oldName<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>  // 派发新值和旧值给回调
  <span class="token punctuation">}</span>,
  <span class="token function-name function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>  
      this.name <span class="token operator">=</span> <span class="token string">'ww'</span>  // 触发name的set
    <span class="token punctuation">}</span>, <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/vuepress-blog/assets/img/15.c18bf644.png" alt=""></p> <h3 id="监听属性的deep深度监听原理"><a href="#监听属性的deep深度监听原理" class="header-anchor">#</a> 监听属性的deep深度监听原理</h3> <p>之前的get方法内有说明，如果有deep属性，则执行traverse方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const seenObjects <span class="token operator">=</span> new Set<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 不重复添加

<span class="token keyword">function</span> traverse <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _traverse<span class="token punctuation">(</span>val, seenObjects<span class="token punctuation">)</span>
  seenObjects.clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> _traverse <span class="token punctuation">(</span>val, seen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> i, keys
  const isA <span class="token operator">=</span> Array.isArray<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  // val是否是数组
  
  <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token operator">!</span>isA <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isObject<span class="token punctuation">(</span>val<span class="token punctuation">))</span></span>  // 如果不是array和object
        <span class="token operator">||</span> Object.isFrozen<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  // 或者是已经冻结对象
        <span class="token operator">||</span> val instanceof VNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 或者是VNode实例
    <span class="token builtin class-name">return</span>  // 再见
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>val.__ob__<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 只有object和array才有__ob__属性
    const depId <span class="token operator">=</span> val.__ob__.dep.id  // 手动依赖收集器的id
    <span class="token keyword">if</span> <span class="token punctuation">(</span>seen.has<span class="token punctuation">(</span>depId<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 已经有收集过
      <span class="token builtin class-name">return</span>  // 再见
    <span class="token punctuation">}</span>
    seen.add<span class="token punctuation">(</span>depId<span class="token punctuation">)</span>  // 没有被收集，添加
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isA<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 是array
    i <span class="token operator">=</span> val.length
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i--<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _traverse<span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span>, seen<span class="token punctuation">)</span>  // 递归触发每一项的get进行依赖收集
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
  
  <span class="token keyword">else</span> <span class="token punctuation">{</span>  // 是object
    keys <span class="token operator">=</span> Object.keys<span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    i <span class="token operator">=</span> keys.length
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i--<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _traverse<span class="token punctuation">(</span>val<span class="token punctuation">[</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>, seen<span class="token punctuation">)</span>  // 递归触发子属性的get进行依赖收集
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看着还挺复杂，简单来说deep的实现原理就是递归的触发数组或对象的get进行依赖收集，因为只有数组和对象才有__ob__属性，也就是我们第七章说明的手动依赖管理器，将它们的依赖收集到Observer类里的dep内，完成deep深度监听。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>watch总结：这里说明了为什么watch和this.<span class="token variable">$watch</span>的实现是一致的，以及简单解释它的原理就是为需要观察的数据创建并收集user-watcher，当数据改变时通知到user-watcher将新值和旧值传递给用户自己定义的回调函数。最后分析了定义watch时会被使用到的三个参数：sync、immediate、deep它们的实现原理。简单说明它们的实现原理就是：sync是不将watcher加入到nextTick队列而同步的更新、immediate是立即以得到的值执行一次回调函数、deep是递归的对它的子值进行依赖收集。
</code></pre></div><h3 id="_2-this-set"><a href="#_2-this-set" class="header-anchor">#</a> 2. this.$set</h3> <p>这个API已经在第七章的最后做了具体分析</p> <h3 id="_3-this-delete"><a href="#_3-this-delete" class="header-anchor">#</a> 3. this.$delete</h3> <p>这个API也已经在第七章的最后做了具体分析</p> <h3 id="_4-computed计算属性"><a href="#_4-computed计算属性" class="header-anchor">#</a> 4. computed计算属性</h3> <p>计算属性不是API，但它是Watcher类的最后也是最复杂的一种实例化的使用，还是很有必要分析的。(vue版本2.6.10)其实主要就是分析计算属性为何可以做到当它的依赖项发生改变时才会进行重新的计算，否则当前数据是被缓存的。计算属性的值可以是对象，这个对象需要传入get和set方法，这种并不常用，所以这里的分析还是介绍常用的函数形式，它们之间是大同小异的，不过可以减少认知负担，聚焦核心原理实现。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  computed: <span class="token punctuation">{</span>
    newName: <span class="token punctuation">{</span>  // 不分析这种了~
      <span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,  // 内部会采用get属性为计算属性的值
      <span class="token function-name function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="计算属性初始化"><a href="#计算属性初始化" class="header-anchor">#</a> 计算属性初始化</h4> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> initState<span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 初始化所有状态时
  vm._watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  // 当前实例watcher集合
  const opts <span class="token operator">=</span> vm.<span class="token variable">$options</span>  // 合并后的属性
  
  <span class="token punctuation">..</span>. // 其他状态初始化
  
  if<span class="token punctuation">(</span>opts.computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果有定义计算属性
    initComputed<span class="token punctuation">(</span>vm, opts.computed<span class="token punctuation">)</span>  // 进行初始化
  <span class="token punctuation">}</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>

---------------------------------------------------------------------------

<span class="token keyword">function</span> initComputed<span class="token punctuation">(</span>vm, computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const watchers <span class="token operator">=</span> vm._computedWatchers <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span> // 创建一个纯净对象
  
  for<span class="token punctuation">(</span>const key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const getter <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // computed每项对应的回调函数
    
    watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> new Watcher<span class="token punctuation">(</span>vm, getter, noop, <span class="token punctuation">{</span>lazy: true<span class="token punctuation">}</span><span class="token punctuation">)</span>  // 实例化computed-watcher
    
    <span class="token punctuation">..</span>.
    
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="计算属性实现原理"><a href="#计算属性实现原理" class="header-anchor">#</a> 计算属性实现原理</h4> <p>这里还是按照惯例，将定义的computed属性的每一项使用Watcher类进行实例化，不过这里是按照computed-watcher的形式，来看下如何实例化的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Watcher<span class="token punctuation">{</span>
  constructor<span class="token punctuation">(</span>vm, expOrFn, cb, options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.vm <span class="token operator">=</span> vm
    this._watchers.push<span class="token punctuation">(</span>this<span class="token punctuation">)</span>
    
    if<span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.lazy <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options.lazy  // 表示是computed
    <span class="token punctuation">}</span>
    
    this.dirty <span class="token operator">=</span> this.lazy  // dirty为标记位，表示是否对computed计算
    
    this.getter <span class="token operator">=</span> expOrFn  // computed的回调函数
    
    this.value <span class="token operator">=</span> undefined
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里就点到为止，实例化已经结束了。并没有和之前render-watcher以及user-watcher那般，执行get方法，这是为什么？我们接着分析为何如此，补全之前初始化computed的方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> initComputed<span class="token punctuation">(</span>vm, computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  
  for<span class="token punctuation">(</span>const key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const getter <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  // // computed每项对应的回调函数
    <span class="token punctuation">..</span>.
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">))</span> <span class="token punctuation">{</span>
      defineComputed<span class="token punctuation">(</span>vm, key, getter<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token punctuation">..</span>. key不能和data里的属性重名
    <span class="token punctuation">..</span>. key不能和props里的属性重名
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的App组件在执行extend创建子组件的构造函数时，已经将key挂载到vm的原型中了，不过之前也是执行的defineComputed方法，所以不妨碍我们看它做了什么：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> defineComputed<span class="token punctuation">(</span>target, key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  Object.defineProperty<span class="token punctuation">(</span>target, key, <span class="token punctuation">{</span>
    enumerable: true,
    configurable: true,
    get: createComputedGetter<span class="token punctuation">(</span>key<span class="token punctuation">)</span>,
    set: noop
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个方法的作用就是让computed成为一个响应式数据，并定义它的get属性，也就是说当页面执行渲染访问到computed时，才会触发get然后执行createComputedGetter方法，所以之前的点到为止再这里会续上，看下get方法是怎么定义的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> createComputedGetter <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span> // 高阶函数
  <span class="token builtin class-name">return</span> <span class="token function-name function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 返回函数
    const watcher <span class="token operator">=</span> this._computedWatchers <span class="token operator">&amp;&amp;</span> this._computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    // 原来this还可以这样用，得到key对应的computed-watcher
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher.dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 在实例化watcher时为true，表示需要计算
        watcher.evaluate<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 进行计算属性的求值
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep.target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 当前的watcher，这里是页面渲染触发的这个方法，所以为render-watcher
        watcher.depend<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 收集当前watcher
      <span class="token punctuation">}</span>
      <span class="token builtin class-name">return</span> watcher.value  // 返回求到的值或之前缓存的值
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

------------------------------------------------------------------------------------

class Watcher <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  
  <span class="token function-name function">evaluate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.value <span class="token operator">=</span> this.get<span class="token punctuation">(</span><span class="token punctuation">)</span>  //  计算属性求值
    this.dirty <span class="token operator">=</span> <span class="token boolean">false</span>  // 表示计算属性已经计算，不需要再计算
  <span class="token punctuation">}</span>
  
  <span class="token function-name function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> i <span class="token operator">=</span> this.deps.length  // deps内是计算属性内能访问到的响应式数据的dep的数组集合
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i--<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.depend<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 让每个dep收集当前的render-watcher
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的变量watcher就是之前computed对应的computed-watcher实例，接下来会执行Watcher类专门为计算属性定义的两个方法，在执行evaluate方法进行求值的过程中又会触发computed内可以访问到的响应式数据的get，它们会将当前的computed-watcher作为依赖收集到自己的dep里，计算完毕之后将dirty置为false，表示已经计算过了。</p> <p>然后执行depend让计算属性内的响应式数据订阅当前的render-watcher，所以computed内的响应式数据会收集computed-watcher和render-watcher两个watcher，当computed内的状态发生变更触发set后，首先通知computed需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到computed计算后的值，最后渲染到页面。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Ps: 计算属性内的值须是响应式数据才能触发重新计算。
</code></pre></div><p>当computed内的响应式数据变更后触发的通知：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>class Watcher <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
  <span class="token function-name function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 当computed内的响应式数据触发set后
    if<span class="token punctuation">(</span>this.lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.diray <span class="token operator">=</span> <span class="token boolean">true</span>  // 通知computed需要重新计算了
    <span class="token punctuation">}</span>
    <span class="token punctuation">..</span>.
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后还是以一个示例结合流程图来帮大家理清楚这里的逻辑：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      manName: <span class="token string">&quot;cc&quot;</span>,
      womanName: <span class="token string">&quot;ww&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>,
  computed: <span class="token punctuation">{</span>
    <span class="token function-name function">newName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token builtin class-name">return</span> this.manName + <span class="token string">&quot;:&quot;</span> + this.womanName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">changeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.manName <span class="token operator">=</span> <span class="token string">&quot;ss&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="/vuepress-blog/assets/img/16.598c6399.png" alt=""></p> <div class="language-bash extra-class"><pre class="language-bash"><code>watch总结：为什么计算属性有缓存功能？因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值；为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？因为内部的响应式数据会收集computed-watcher，变更后通知计算属性要进行计算，也会通知页面重新渲染，渲染时会读取到重新计算后的值。
</code></pre></div><p>最后按照惯例我们还是以一道vue可能会被问到的面试题作为本章的结束~</p> <h3 id="面试官微笑而又不失礼貌的问道-8"><a href="#面试官微笑而又不失礼貌的问道-8" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h3> <h4 id="请问computed属性和watch属性分别什么场景使用"><a href="#请问computed属性和watch属性分别什么场景使用" class="header-anchor">#</a> 请问computed属性和watch属性分别什么场景使用？</h4> <p>当模板中的某个值需要通过一个或多个数据计算得到时，就可以使用计算属性，还有计算属性的函数不接受参数；监听属性主要是监听某个值发生变化后，对新值去进行逻辑处理。</p> <h2 id="vue原理解析-十-搞懂事件api原理及在组件库中的妙用"><a href="#vue原理解析-十-搞懂事件api原理及在组件库中的妙用" class="header-anchor">#</a> Vue原理解析（十）：搞懂事件API原理及在组件库中的妙用</h2> <p>在vue内部初始化时会为每个组件实例挂载一个this._events私有的空对象属性：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vm._events <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span> // 没有__proto__属性
</code></pre></div><p>这个里面存放的就是当前实例上的自定义事件集合，也就是自定义事件中心，它存放着当前组件所有的自定义事件。和自定义事件相关的API分为以下四个：this.$on、this.$emit、this.$off、this.$once，它们会往这个事件中心中添加、触发、移除对应的自定义事件，从而组成了vue的自定义事件系统，接下来看下它们都是怎么实现的。</p> <h3 id="this-on"><a href="#this-on" class="header-anchor">#</a> this.$on</h3> <p>描述：监听当前实例上的自定义事件。事件可以由vm.$emit触发，回调函数会接收所有传入事件触发函数的额外参数。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'test'</span>, res <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      console.log<span class="token punctuation">(</span>res<span class="token punctuation">)</span>    
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.<span class="token variable">$emit</span><span class="token punctuation">(</span><span class="token string">'test'</span>, <span class="token string">'hello-vue~'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上示例首先在created钩子内往当前组件实例的事件中心_events中添加一个名为test的自定义事件，第二个参数为该自定义事件的回调函数，而触发handleClick这个方法后，就会在事件中心中尝试找到test自定义事件，触发它并传递给回调函数hello-vue~这个字符串，从而打印出来。我们来看下$on的实现：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype.<span class="token variable">$on</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event, fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const hookRE <span class="token operator">=</span> /^hook:/    //检测自定义事件名是否是hook:开头
  
  const vm <span class="token operator">=</span> this
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>event<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 如果第一个参数是数组
    <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> event.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.<span class="token variable">$on</span><span class="token punctuation">(</span>event<span class="token punctuation">[</span>i<span class="token punctuation">]</span>, fn<span class="token punctuation">)</span>  // 递归
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>vm._events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>vm._events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">))</span>.push<span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    // 如果有对应事件名就push，没有创建为空数组然后push
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hookRE.test<span class="token punctuation">(</span>event<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 如果是hook:开头
      vm._hasHookEvent <span class="token operator">=</span> <span class="token boolean">true</span>  // 标志位为true
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> vm
<span class="token punctuation">}</span>
</code></pre></div><p>以上就是$on的实现了，它接受两个参数，自定义事件名event和对应的回调函数fn。主要就是往事件中心_events下挂载对应的event事件名key，而事件名对应的key又是一个数组形式，这样相同事件名的回调会在一个数组之内。而接下来的_hasHookEvent标志位表示是否监听组件的钩子函数，这个之后示例说明。</p> <h3 id="this-emit"><a href="#this-emit" class="header-anchor">#</a> this.$emit</h3> <p>描述：触发当前实例上的事件，附加参数都会传给监听器回调。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype.<span class="token variable">$emit</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const vm <span class="token operator">=</span> this
  <span class="token builtin class-name">let</span> cbs <span class="token operator">=</span> vm._events<span class="token punctuation">[</span>event<span class="token punctuation">]</span>  // 找到事件名对应的回调集合
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cbs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const args <span class="token operator">=</span> toArray<span class="token punctuation">(</span>arguments, <span class="token number">1</span><span class="token punctuation">)</span>  // 将附加参数转为数组
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cbs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.apply<span class="token punctuation">(</span>vm, args<span class="token punctuation">)</span>  // 挨个执行对应的回调集合
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> vm
<span class="token punctuation">}</span>
</code></pre></div><p>而$emit的实现会更好理解些，首先从事件中心中找到event对应的回调集合，然后将$emit其余参数转为args数组，最后挨个执行回调集合内的回调并传入args。通过这么一对朴实的API可以帮我们理解三件小事：</p> <h4 id="_1-理解自定义事件原理"><a href="#_1-理解自定义事件原理" class="header-anchor">#</a> 1. 理解自定义事件原理</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>app.vue
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>child-component @test<span class="token operator">=</span><span class="token string">'handleTest'</span> /<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>
<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  methods: <span class="token punctuation">{</span>
    handleTest<span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console.log<span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

----------------------------------------

child.vue
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">'onClick'</span><span class="token operator">&gt;</span>btn<span class="token operator">&lt;</span>/button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>
<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.<span class="token variable">$emit</span><span class="token punctuation">(</span><span class="token string">'test'</span>, <span class="token string">'hello-vue~'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上是父子组件通过自定义事件通信，想必大家非常熟悉。自定义事件的实现原理和通常解释的会不同，它们的原理是父组件在经过编译模板后，会将定义在子组件上的自定义事件test及其回调handleTest通过$on添加到子组件的事件中心中，当子组件通过$emit触发test自定义事件时，会在它的事件中心中去找test，找到后传递hello-vue~给回调函数并执行，不过因为回调函数handleTest是在父组件作用域内定义的，所以看起来就像是父子组件之间通信般。</p> <p><img src="/vuepress-blog/assets/img/17.37a8c91a.png" alt=""></p> <h4 id="_2-监听组件的钩子函数"><a href="#_2-监听组件的钩子函数" class="header-anchor">#</a> 2. 监听组件的钩子函数</h4> <p>也就是$on内自定义事件名之前是hook:的情况，可以监听组件的钩子函数触发：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>app.vue
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>child-component @hook:created<span class="token operator">=</span><span class="token string">'handleHookEvent'</span> /<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>
</code></pre></div><p>以上示例为当子组件的created钩子触发时，就触发父组件内定义的handleHookEvent回调。接下来让我们再看一个官网的示例，使用这个特性如何帮我们写出更优雅的代码：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>监听组件钩子之前：
<span class="token function-name function">mounted</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this.picker <span class="token operator">=</span> new Pikaday<span class="token punctuation">(</span><span class="token punctuation">{</span>  // Pikaday是一个日期选择库
    field: this.<span class="token variable">$refs</span>.input,
    format: <span class="token string">'YYYY-MM-DD'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>,
<span class="token function-name function">beforeDestroy</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 销毁日期选择器
  this.picker.destroy<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

监听组件钩子之后：
<span class="token function-name function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this.attachDatepicker<span class="token punctuation">(</span><span class="token string">'startDateInput'</span><span class="token punctuation">)</span>
  this.attachDatepicker<span class="token punctuation">(</span><span class="token string">'endDateInput'</span><span class="token punctuation">)</span>  // 同时为两个input添加日期选择
<span class="token punctuation">}</span>,
methods: <span class="token punctuation">{</span>
  attachDatepicker<span class="token punctuation">(</span>refName<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 封装为一个方法
    const picker <span class="token operator">=</span> new Pikaday<span class="token punctuation">(</span><span class="token punctuation">{</span>  // Pikaday是一个日期选择库
      field: this.<span class="token variable">$refs</span><span class="token punctuation">[</span>refName<span class="token punctuation">]</span>,  // 为input添加日期选择
      format: <span class="token string">'YYYY-MM-DD'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    this.<span class="token variable">$once</span><span class="token punctuation">(</span><span class="token string">'hook:beforeDestroy'</span>, <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>  // 监听beforeDestroy钩子
      picker.destroy<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 销毁日期选择器
    <span class="token punctuation">}</span><span class="token punctuation">)</span>  // <span class="token variable">$once</span>和<span class="token variable">$on</span>类似，只是只会触发一次
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先不用在当前实例下挂载一个额外的属性，其次可以封装为一个方法，复用更方便。</p> <h4 id="_3-不借助vuex跨组件通信"><a href="#_3-不借助vuex跨组件通信" class="header-anchor">#</a> 3. 不借助vuex跨组件通信</h4> <p>再开发组件库时，因为都是独立的组件，从而引入vuex这种强依赖是不现实的，而且很多时候是用插槽来放置子组件，所以子组件的位置、嵌套、数量并不会确定，从而在组件库内完成跨组件的通信就尤为重要。</p> <p>通过接下来的示例介绍组件库中会运用到的一种，使用$on和$emit来实现跨组件通信，子组件通过父组件的name属性找到对应的实例，找到后使用$emit触发父组件的自定义事件，而在这之前父组件已经使用$on完成了自定义事件的添加</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  methods: <span class="token punctuation">{</span>  // 混入mixin使用
    dispatch<span class="token punctuation">(</span>componentName, eventName, params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token builtin class-name">let</span> parent <span class="token operator">=</span> this.<span class="token variable">$parent</span> <span class="token operator">||</span> this.<span class="token variable">$root</span>  // 找父组件
      <span class="token builtin class-name">let</span> name <span class="token operator">=</span> parent.<span class="token variable">$options</span>.name  // 父组件的name属性

      <span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>name <span class="token operator">||</span> name <span class="token operator">!=</span><span class="token operator">=</span> componentName<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // 和传入的componentName进行匹配
        parent <span class="token operator">=</span> parent.<span class="token variable">$parent</span>  // 一直向上查找

        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          name <span class="token operator">=</span> parent.<span class="token variable">$options</span>.name  // 重新赋值name
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 找到匹配的组件实例
        parent.<span class="token variable">$emit</span>.apply<span class="token punctuation">(</span>parent, <span class="token punctuation">[</span>eventName<span class="token punctuation">]</span>.concat<span class="token punctuation">(</span>params<span class="token punctuation">))</span>  // <span class="token variable">$emit</span>触发自定义事件
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来介绍表单验证组件内的使用案例：</p> <p><img src="/vuepress-blog/assets/img/18.cae06b11.png" alt=""></p> <p>不知道大家是否对这种表单验证好奇过，为什么点一下提交，就可以将所有的表单项全部做验证，接下来笔者试着写一个极简的表单验证组件来说明它的原理。这里会有两个组件，一个是iForm为整个表单，一个是iFormItem为其中的某个表单项：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>iForm组件：

<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>slot /<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>  // 只有一个插槽
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  name: <span class="token string">&quot;iForm&quot;</span>,  // 组件名很重要
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      fields: <span class="token punctuation">[</span><span class="token punctuation">]</span>  // 收集所有表单项的集合
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>,
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">&quot;on-form-item-add&quot;</span>, field <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>  // <span class="token variable">$on</span>必须得比<span class="token variable">$emit</span>先执行，因为要先添加嘛
      this.fields.push<span class="token punctuation">(</span>field<span class="token punctuation">)</span>  // 添加到集合内
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">validataAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 验证所有的接口方法
      this.fields.forEach<span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        item.validateVal<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 执行每个表单项内的validateVal方法
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span>
</code></pre></div><p>模板只有一个slot插槽，这个组件主要是做两件事，将所有的表单项的实例收集到fields内，提供一个可以验证所有表单项的方法validataAll，然后看下iFormItem组件：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>input v-model<span class="token operator">=</span><span class="token string">&quot;curValue&quot;</span> <span class="token assign-left variable">style</span><span class="token operator">=</span><span class="token string">&quot;border: 1px solid #aaa;&quot;</span> /<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>span <span class="token assign-left variable">style</span><span class="token operator">=</span><span class="token string">&quot;color: red;&quot;</span> v-show<span class="token operator">=</span><span class="token string">&quot;showTip&quot;</span><span class="token operator">&gt;</span>输入不能为空<span class="token operator">&lt;</span>/span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token function">import</span> emitter from <span class="token string">&quot;./emitter&quot;</span>  // 引入之前的dispatch方法

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  name: <span class="token string">&quot;iFormItem&quot;</span>,
  mixins: <span class="token punctuation">[</span>emitter<span class="token punctuation">]</span>,  // 混入
  <span class="token function-name function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
      curValue: <span class="token string">&quot;&quot;</span>,  // 表单项的值
      showTip: <span class="token boolean">false</span>  // 是否验证通过
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>,
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.dispatch<span class="token punctuation">(</span><span class="token string">&quot;iForm&quot;</span>, <span class="token string">&quot;on-form-item-add&quot;</span>, this<span class="token punctuation">)</span>  // 将当前实例传给iForm组件
  <span class="token punctuation">}</span>,
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">validateVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 某个表单项的验证方法
      <span class="token keyword">if</span> <span class="token punctuation">(</span>this.curValue <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 不能为空
        this.showTip <span class="token operator">=</span> <span class="token boolean">true</span>  // 验证不通过
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span>
</code></pre></div><p>看到这里我们知道了原来这种表单验证原理是将每个表单项的实例传入给iForm，然后在iForm内遍历的执行每个表单项的验证方法，从而可以一次性验证完所有的表单项。表单验证调用方式：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>i-form <span class="token assign-left variable">ref</span><span class="token operator">=</span><span class="token string">'form'</span><span class="token operator">&gt;</span>  // 引用
      <span class="token operator">&lt;</span>i-form-item /<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>i-form-item /<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>i-form-item /<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>i-form-item /<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>i-form-item /<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/i-form<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span><span class="token operator">&gt;</span>提交<span class="token operator">&lt;</span>/button<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token function">import</span> iForm from <span class="token string">&quot;./form&quot;</span>
<span class="token function">import</span> iFormItem from <span class="token string">&quot;./form-item&quot;</span>

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  methods: <span class="token punctuation">{</span>
    <span class="token function-name function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this.<span class="token variable">$refs</span><span class="token punctuation">[</span><span class="token string">'form'</span><span class="token punctuation">]</span>.validataAll<span class="token punctuation">(</span><span class="token punctuation">)</span> // 验证所有
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  components: <span class="token punctuation">{</span>
    iForm, iFormItem
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span>
</code></pre></div><p>这里就使用了$on和$emit这么一对API，通过组件的名称去查找组件实例，不论嵌套以及数量，然后使用事件API去跨组件传递参数。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>注意点：当<span class="token variable">$on</span>和<span class="token variable">$emit</span>配合使用时，<span class="token variable">$on</span>要优先与<span class="token variable">$emit</span>执行。因为首先要往实例的事件中心去添加事件，才能被触发。
</code></pre></div><h3 id="this-off"><a href="#this-off" class="header-anchor">#</a> this.$off</h3> <p>描述：移除自定义事件监听器，不过根据传入的参数分为三种形式：</p> <ul><li>如果没有提供参数，则移除所有的事件监听器；</li> <li>如果只提供了事件，则移除该事件所有的监听器；</li> <li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'test1'</span>, this.test1<span class="token punctuation">)</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'test2'</span>, this.test2<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>,
  <span class="token function-name function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$off</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  // 没有参数，清空事件中心
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

-------------------------------------------

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'test1'</span>, this.test1<span class="token punctuation">)</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'test2'</span>, this.test2<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>,
  <span class="token function-name function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$off</span><span class="token punctuation">(</span><span class="token string">'test1'</span><span class="token punctuation">)</span>  // 在事件中心中移除test1
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

-------------------------------------------

<span class="token builtin class-name">export</span> default <span class="token punctuation">{</span>
  <span class="token function-name function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'test1'</span>, this.test1<span class="token punctuation">)</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'test1'</span>, this.test3<span class="token punctuation">)</span>
    this.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'test2'</span>, this.test2<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>,
  <span class="token function-name function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.<span class="token variable">$off</span><span class="token punctuation">(</span><span class="token string">'test1'</span>, this.test3<span class="token punctuation">)</span>  // 在事件中心中移除事件test1的test3回调
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>知道了这个API的调用方式之后，接下来看下$off的实现方式：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype.<span class="token variable">$off</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event, fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const vm <span class="token operator">=</span> this
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arguments.length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 如果没有传递参数
    vm._events <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span>  // 重置事件中心
    <span class="token builtin class-name">return</span> vm
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>event<span class="token punctuation">))</span> <span class="token punctuation">{</span>  // event如果是数组
    <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span>, l <span class="token operator">=</span> event.length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm.<span class="token variable">$off</span><span class="token punctuation">(</span>event<span class="token punctuation">[</span>i<span class="token punctuation">]</span>, fn<span class="token punctuation">)</span>  // 递归清空
    <span class="token punctuation">}</span>
    <span class="token builtin class-name">return</span> vm
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // 只传递了事件名没回调
    vm._events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> null  // 清空对应所有的回调
    <span class="token builtin class-name">return</span> vm
  <span class="token punctuation">}</span>
  
  const cbs <span class="token operator">=</span> vm._events<span class="token punctuation">[</span>event<span class="token punctuation">]</span>  // 获取回调集合
  <span class="token builtin class-name">let</span> cb
  <span class="token builtin class-name">let</span> i <span class="token operator">=</span> cbs.length
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i--<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cb <span class="token operator">=</span> cbs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  // 回调集合里的每一项
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cb <span class="token operator">==</span><span class="token operator">=</span> fn <span class="token operator">||</span> cb.fn <span class="token operator">==</span><span class="token operator">=</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  // cb.fn为<span class="token variable">$once</span>时挂载的
      cbs.splice<span class="token punctuation">(</span>i, <span class="token number">1</span><span class="token punctuation">)</span>  // 找到对应的回调，从集合内移除
      <span class="token builtin class-name">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> vm
<span class="token punctuation">}</span>
</code></pre></div><p>也是分为了三种情况，根据参数的不同做分别处理。</p> <h3 id="this-once"><a href="#this-once" class="header-anchor">#</a> this.$once</h3> <p>描述：监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。</p> <p>效果和$on是类似的，只是说触发一次之后会从事件中心中移除。所以它的实现思路也很好理解，首先通过$on实现功能，当触发之后从事件中心中移除这个事件。来看下它的实现原理：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Vue.prototype.<span class="token variable">$once</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event, fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const vm <span class="token operator">=</span> this
  <span class="token keyword">function</span> <span class="token function-name function">on</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm.<span class="token variable">$off</span><span class="token punctuation">(</span>event, on<span class="token punctuation">)</span>
    fn.apply<span class="token punctuation">(</span>vm, arguments<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  on.fn <span class="token operator">=</span> fn  // 回调挂载到on下，移除时好做判断
  vm.<span class="token variable">$on</span><span class="token punctuation">(</span>event, on<span class="token punctuation">)</span>  // 将on添加到事件中心中
  <span class="token builtin class-name">return</span> vm
<span class="token punctuation">}</span>
</code></pre></div><p>首先将回调fn挂载到on函数下，将on函数注册到事件中心去，触发自定义事件时首先会在$emit内执行on函数，在on函数内执行$off将on函数移除，然后执行传入的fn回调。这个时候事件中心没有了on函数，回调函数也执行了一次，完成$once功能~</p> <div class="language-bash extra-class"><pre class="language-bash"><code>事件API总结：<span class="token variable">$on</span>往事件中心添加事件；<span class="token variable">$emit</span>是触发事件中心里的事件；<span class="token variable">$off</span>是移除事件中心里的事件；<span class="token variable">$once</span>是触发一次事件中心里的事件。哪怕是如此不显眼的API，再理解了它们的实现原理后，也能让我们再更多场景更好的使用它们~
</code></pre></div><p>最后按照惯例我们还是以一道vue可能会被问到的面试题作为本章的结束(想不到事件相关特别好的题目~)</p> <h3 id="面试官微笑而又不失礼貌的问道-9"><a href="#面试官微笑而又不失礼貌的问道-9" class="header-anchor">#</a> 面试官微笑而又不失礼貌的问道：</h3> <h4 id="说下自定义事件的机制。"><a href="#说下自定义事件的机制。" class="header-anchor">#</a> 说下自定义事件的机制。</h4> <p>子组件使用this.$emit触发事件时，会在当前实例的事件中心去查找对应的事件，然后执行它。不过这个事件回调是在父组件的作用域里定义的，所以$emit里的参数会传递给父组件的回调函数，从而完成父子组件通信。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-一-vue到底是什么" class="sidebar-link reco-side-vue原理解析-一-vue到底是什么" data-v-b57cc07c>Vue原理解析（一）：Vue到底是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue是什么" class="sidebar-link reco-side-vue是什么" data-v-b57cc07c>vue是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#目录结构" class="sidebar-link reco-side-目录结构" data-v-b57cc07c>目录结构</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue版本" class="sidebar-link reco-side-vue版本" data-v-b57cc07c>vue版本</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-二-快速搞懂new-vue-时到底做了什么-上" class="sidebar-link reco-side-vue原理解析-二-快速搞懂new-vue-时到底做了什么-上" data-v-b57cc07c>Vue原理解析（二）：快速搞懂new Vue()时到底做了什么？（上）</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#合并options配置" class="sidebar-link reco-side-合并options配置" data-v-b57cc07c>合并options配置</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-三-快速搞懂new-vue-时到底做了什么-下" class="sidebar-link reco-side-vue原理解析-三-快速搞懂new-vue-时到底做了什么-下" data-v-b57cc07c>Vue原理解析（三）：快速搞懂new Vue()时到底做了什么？（下）</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_5-initinjections-vm-主要作用是初始化inject-可以访问到对应的依赖。" class="sidebar-link reco-side-_5-initinjections-vm-主要作用是初始化inject-可以访问到对应的依赖。" data-v-b57cc07c>5. initInjections(vm): 主要作用是初始化inject，可以访问到对应的依赖。</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_6-initstate-vm-初始化会被使用到的状态-状态包括props-methods-data-computed-watch五个选项。" class="sidebar-link reco-side-_6-initstate-vm-初始化会被使用到的状态-状态包括props-methods-data-computed-watch五个选项。" data-v-b57cc07c>6. initState(vm): 初始化会被使用到的状态，状态包括props，methods，data，computed，watch五个选项。</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_7-initprovide-vm-主要作用是初始化provide为子组件提供依赖。" class="sidebar-link reco-side-_7-initprovide-vm-主要作用是初始化provide为子组件提供依赖。" data-v-b57cc07c>7. initProvide(vm): 主要作用是初始化provide为子组件提供依赖。</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_8-callhook-vm-created-执行用户定义的created钩子函数-有mixin混入的也一并执行。" class="sidebar-link reco-side-_8-callhook-vm-created-执行用户定义的created钩子函数-有mixin混入的也一并执行。" data-v-b57cc07c>8. callHook(vm, 'created'): 执行用户定义的created钩子函数，有mixin混入的也一并执行。</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#面试官微笑而又不失礼貌的问道-2" class="sidebar-link reco-side-面试官微笑而又不失礼貌的问道-2" data-v-b57cc07c>面试官微笑而又不失礼貌的问道：</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#怼回去-2" class="sidebar-link reco-side-怼回去-2" data-v-b57cc07c>怼回去：</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-四-你知道被大家聊烂了的虚拟dom是怎么生成的吗" class="sidebar-link reco-side-vue原理解析-四-你知道被大家聊烂了的虚拟dom是怎么生成的吗" data-v-b57cc07c>Vue原理解析（四）：你知道被大家聊烂了的虚拟Dom是怎么生成的吗？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#注释节点-↓" class="sidebar-link reco-side-注释节点-↓" data-v-b57cc07c>注释节点 ↓</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#文本节点-↓" class="sidebar-link reco-side-文本节点-↓" data-v-b57cc07c>文本节点 ↓</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#克隆节点-↓" class="sidebar-link reco-side-克隆节点-↓" data-v-b57cc07c>克隆节点 ↓</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#元素节点-↓" class="sidebar-link reco-side-元素节点-↓" data-v-b57cc07c>元素节点 ↓</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#组件节点-↓" class="sidebar-link reco-side-组件节点-↓" data-v-b57cc07c>组件节点 ↓</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#开始挂载阶段" class="sidebar-link reco-side-开始挂载阶段" data-v-b57cc07c>开始挂载阶段</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_1-普通的元素节点转化为vnode" class="sidebar-link reco-side-_1-普通的元素节点转化为vnode" data-v-b57cc07c>1. 普通的元素节点转化为VNode</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_2-组件转化为vnode" class="sidebar-link reco-side-_2-组件转化为vnode" data-v-b57cc07c>2. 组件转化为VNode</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#面试官微笑而又不失礼貌的问道-3" class="sidebar-link reco-side-面试官微笑而又不失礼貌的问道-3" data-v-b57cc07c>面试官微笑而又不失礼貌的问道：</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-五-彻底搞懂虚拟dom到真实dom的生成过程" class="sidebar-link reco-side-vue原理解析-五-彻底搞懂虚拟dom到真实dom的生成过程" data-v-b57cc07c>Vue原理解析（五）：彻底搞懂虚拟Dom到真实Dom的生成过程</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#首次渲染" class="sidebar-link reco-side-首次渲染" data-v-b57cc07c>首次渲染</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#更新页面" class="sidebar-link reco-side-更新页面" data-v-b57cc07c>更新页面</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#生成dom" class="sidebar-link reco-side-生成dom" data-v-b57cc07c>生成Dom</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#面试官微笑而又不失礼貌的问道-4" class="sidebar-link reco-side-面试官微笑而又不失礼貌的问道-4" data-v-b57cc07c>面试官微笑而又不失礼貌的问道：</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-六-全面深入理解响应式原理-上-对象基础篇" class="sidebar-link reco-side-vue原理解析-六-全面深入理解响应式原理-上-对象基础篇" data-v-b57cc07c>Vue原理解析（六）：全面深入理解响应式原理(上)-对象基础篇</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#对象的响应式原理" class="sidebar-link reco-side-对象的响应式原理" data-v-b57cc07c>对象的响应式原理</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#依赖收集" class="sidebar-link reco-side-依赖收集" data-v-b57cc07c>依赖收集</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#面试官微笑而又不失礼貌的问道-5" class="sidebar-link reco-side-面试官微笑而又不失礼貌的问道-5" data-v-b57cc07c>面试官微笑而又不失礼貌的问道：</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-七-全面深入理解响应式原理-下-数组进阶篇" class="sidebar-link reco-side-vue原理解析-七-全面深入理解响应式原理-下-数组进阶篇" data-v-b57cc07c>Vue原理解析（七）：全面深入理解响应式原理(下)-数组进阶篇</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#dep收集依赖的位置" class="sidebar-link reco-side-dep收集依赖的位置" data-v-b57cc07c>Dep收集依赖的位置</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#数组的响应式原理" class="sidebar-link reco-side-数组的响应式原理" data-v-b57cc07c>数组的响应式原理</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#数组方法更新依赖" class="sidebar-link reco-side-数组方法更新依赖" data-v-b57cc07c>数组方法更新依赖</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#官方填坑" class="sidebar-link reco-side-官方填坑" data-v-b57cc07c>官方填坑</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#面试官微笑而又不失礼貌的问道-6" class="sidebar-link reco-side-面试官微笑而又不失礼貌的问道-6" data-v-b57cc07c>面试官微笑而又不失礼貌的问道：</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-八-一起搞明白令人头疼的diff算法" class="sidebar-link reco-side-vue原理解析-八-一起搞明白令人头疼的diff算法" data-v-b57cc07c>Vue原理解析（八）：一起搞明白令人头疼的diff算法</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#创建新增节点" class="sidebar-link reco-side-创建新增节点" data-v-b57cc07c>创建新增节点</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#删除废弃节点" class="sidebar-link reco-side-删除废弃节点" data-v-b57cc07c>删除废弃节点</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#更新已有节点-重点" class="sidebar-link reco-side-更新已有节点-重点" data-v-b57cc07c>更新已有节点 (重点)</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#更新已有节点之更新子节点-重点中的重点" class="sidebar-link reco-side-更新已有节点之更新子节点-重点中的重点" data-v-b57cc07c>更新已有节点之更新子节点 (重点中的重点)</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#面试官微笑而又不失礼貌的问道-7" class="sidebar-link reco-side-面试官微笑而又不失礼貌的问道-7" data-v-b57cc07c>面试官微笑而又不失礼貌的问道：</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-九-监听属性watch和计算属性computed实现原理" class="sidebar-link reco-side-vue原理解析-九-监听属性watch和计算属性computed实现原理" data-v-b57cc07c>Vue原理解析（九）：监听属性watch和计算属性computed实现原理</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_1-this-watch" class="sidebar-link reco-side-_1-this-watch" data-v-b57cc07c>1. this.$watch</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#监听属性初始化" class="sidebar-link reco-side-监听属性初始化" data-v-b57cc07c>监听属性初始化</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#监听属性实现原理" class="sidebar-link reco-side-监听属性实现原理" data-v-b57cc07c>监听属性实现原理</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#监听属性的deep深度监听原理" class="sidebar-link reco-side-监听属性的deep深度监听原理" data-v-b57cc07c>监听属性的deep深度监听原理</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_2-this-set" class="sidebar-link reco-side-_2-this-set" data-v-b57cc07c>2. this.$set</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_3-this-delete" class="sidebar-link reco-side-_3-this-delete" data-v-b57cc07c>3. this.$delete</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#_4-computed计算属性" class="sidebar-link reco-side-_4-computed计算属性" data-v-b57cc07c>4. computed计算属性</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#面试官微笑而又不失礼貌的问道-8" class="sidebar-link reco-side-面试官微笑而又不失礼貌的问道-8" data-v-b57cc07c>面试官微笑而又不失礼貌的问道：</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#vue原理解析-十-搞懂事件api原理及在组件库中的妙用" class="sidebar-link reco-side-vue原理解析-十-搞懂事件api原理及在组件库中的妙用" data-v-b57cc07c>Vue原理解析（十）：搞懂事件API原理及在组件库中的妙用</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#this-on" class="sidebar-link reco-side-this-on" data-v-b57cc07c>this.$on</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#this-emit" class="sidebar-link reco-side-this-emit" data-v-b57cc07c>this.$emit</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#this-off" class="sidebar-link reco-side-this-off" data-v-b57cc07c>this.$off</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#this-once" class="sidebar-link reco-side-this-once" data-v-b57cc07c>this.$once</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/vue2-source.html#面试官微笑而又不失礼貌的问道-9" class="sidebar-link reco-side-面试官微笑而又不失礼貌的问道-9" data-v-b57cc07c>面试官微笑而又不失礼貌的问道：</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/media/starsky.m4a" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:20px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/media/starsky.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/media/starsky.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>Star Sky</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>Two Steps From Hell</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/vuepress-blog/assets/js/app.d7c20d16.js" defer></script><script src="/vuepress-blog/assets/js/7.52cd3cfd.js" defer></script><script src="/vuepress-blog/assets/js/2.5e77f0d2.js" defer></script><script src="/vuepress-blog/assets/js/1.c3e4b76d.js" defer></script><script src="/vuepress-blog/assets/js/17.d2f8beac.js" defer></script>
  </body>
</html>
