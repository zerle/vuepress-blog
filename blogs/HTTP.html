<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP灵魂之问(上篇) | 张垒的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="记录好的技术文档">
    
    <link rel="preload" href="/assets/css/0.styles.1884e8e7.css" as="style"><link rel="preload" href="/assets/js/app.276fe4ed.js" as="script"><link rel="preload" href="/assets/js/7.52cd3cfd.js" as="script"><link rel="preload" href="/assets/js/2.5e77f0d2.js" as="script"><link rel="preload" href="/assets/js/1.c3e4b76d.js" as="script"><link rel="preload" href="/assets/js/16.b75b2a2c.js" as="script"><link rel="prefetch" href="/assets/js/10.fce7151c.js"><link rel="prefetch" href="/assets/js/11.665820a8.js"><link rel="prefetch" href="/assets/js/14.93e60e41.js"><link rel="prefetch" href="/assets/js/15.06542fc4.js"><link rel="prefetch" href="/assets/js/17.d2f8beac.js"><link rel="prefetch" href="/assets/js/18.3dbe40f4.js"><link rel="prefetch" href="/assets/js/19.a0f84501.js"><link rel="prefetch" href="/assets/js/20.8cf233fc.js"><link rel="prefetch" href="/assets/js/21.dc553e85.js"><link rel="prefetch" href="/assets/js/22.3f0558f8.js"><link rel="prefetch" href="/assets/js/23.c6cd4af0.js"><link rel="prefetch" href="/assets/js/24.6e5b88ce.js"><link rel="prefetch" href="/assets/js/25.e8704ed0.js"><link rel="prefetch" href="/assets/js/26.ea2f5a39.js"><link rel="prefetch" href="/assets/js/27.87921c42.js"><link rel="prefetch" href="/assets/js/28.f31d39ff.js"><link rel="prefetch" href="/assets/js/29.5c2c99a1.js"><link rel="prefetch" href="/assets/js/3.eff7fee9.js"><link rel="prefetch" href="/assets/js/30.b375e77b.js"><link rel="prefetch" href="/assets/js/31.53b35284.js"><link rel="prefetch" href="/assets/js/32.82fe56b9.js"><link rel="prefetch" href="/assets/js/33.c7707b2a.js"><link rel="prefetch" href="/assets/js/34.5977256e.js"><link rel="prefetch" href="/assets/js/35.14d16212.js"><link rel="prefetch" href="/assets/js/36.0d04e6fc.js"><link rel="prefetch" href="/assets/js/37.f85a8b69.js"><link rel="prefetch" href="/assets/js/38.a49efe7f.js"><link rel="prefetch" href="/assets/js/39.98053ef4.js"><link rel="prefetch" href="/assets/js/4.15d7a48b.js"><link rel="prefetch" href="/assets/js/40.a1d0539b.js"><link rel="prefetch" href="/assets/js/41.a61ecc9b.js"><link rel="prefetch" href="/assets/js/42.02fa6597.js"><link rel="prefetch" href="/assets/js/43.0102712f.js"><link rel="prefetch" href="/assets/js/44.fc0cf83d.js"><link rel="prefetch" href="/assets/js/45.b24876fd.js"><link rel="prefetch" href="/assets/js/46.01752611.js"><link rel="prefetch" href="/assets/js/47.5cfca3d0.js"><link rel="prefetch" href="/assets/js/48.d70d2f6c.js"><link rel="prefetch" href="/assets/js/49.80d9cea6.js"><link rel="prefetch" href="/assets/js/5.fb9624e5.js"><link rel="prefetch" href="/assets/js/50.0c550db3.js"><link rel="prefetch" href="/assets/js/51.a6b49e93.js"><link rel="prefetch" href="/assets/js/52.7f08f076.js"><link rel="prefetch" href="/assets/js/53.2a888b74.js"><link rel="prefetch" href="/assets/js/54.b39c22d6.js"><link rel="prefetch" href="/assets/js/55.f2e5b060.js"><link rel="prefetch" href="/assets/js/56.c7500a61.js"><link rel="prefetch" href="/assets/js/57.af85ad1c.js"><link rel="prefetch" href="/assets/js/58.b21e620f.js"><link rel="prefetch" href="/assets/js/59.f774584a.js"><link rel="prefetch" href="/assets/js/6.09f6a933.js"><link rel="prefetch" href="/assets/js/60.d0b6fce9.js"><link rel="prefetch" href="/assets/js/61.54065b41.js"><link rel="prefetch" href="/assets/js/62.216fdd97.js"><link rel="prefetch" href="/assets/js/63.957d10ac.js"><link rel="prefetch" href="/assets/js/64.e34b4a6b.js"><link rel="prefetch" href="/assets/js/65.be389c66.js"><link rel="prefetch" href="/assets/js/66.875cecec.js"><link rel="prefetch" href="/assets/js/67.9077ac06.js"><link rel="prefetch" href="/assets/js/68.652130e7.js"><link rel="prefetch" href="/assets/js/69.0e54693e.js"><link rel="prefetch" href="/assets/js/70.017b9424.js"><link rel="prefetch" href="/assets/js/71.d7f6b53f.js"><link rel="prefetch" href="/assets/js/8.0899600d.js"><link rel="prefetch" href="/assets/js/9.1f42c771.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.680926dd.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1884e8e7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>张垒的博客</h3> <p class="description" data-v-59e6cb88>记录好的技术文档</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">张垒的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/me.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>33</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>31</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>HTTP灵魂之问(上篇)</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">HTTP灵魂之问(上篇)</h1> <div data-v-8a445198><!----> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2020/10/25</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>HTTP</span></i></div></div> <div class="theme-reco-content content__default"><p>这篇文章就是为了帮助大家树立完整的 HTTP 知识体系，并达到一定的深度，从容地应对各种灵魂之问，也同时提升自己作为一个 web 开发的专业素养吧。</p> <p><img src="/assets/img/01.93eb306d.png" alt=""></p> <h2 id="_001-http-报文结构是怎样的"><a href="#_001-http-报文结构是怎样的" class="header-anchor">#</a> 001. HTTP 报文结构是怎样的？</h2> <p>对于 TCP 而言，在传输的时候分为两个部分:TCP头和数据部分。</p> <p>而 HTTP 类似，也是header + body的结构，具体而言:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>起始行 + 头部 + 空行 + 实体
</code></pre></div><p>由于 http 请求报文和响应报文是有一定区别，因此我们分开介绍。</p> <h3 id="起始行"><a href="#起始行" class="header-anchor">#</a> 起始行</h3> <p>对于请求报文来说，起始行类似下面这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>GET /home HTTP/1.1
</code></pre></div><p>也就是方法 + 路径 + http版本。</p> <p>对于响应报文来说，起始行一般张这个样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>HTTP/1.1 <span class="token number">200</span> OK
</code></pre></div><p>响应报文的起始行也叫做状态行。由http版本、状态码和原因三部分组成。</p> <p>值得注意的是，在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接一个换行，严格遵循ABNF语法规范。</p> <h3 id="头部"><a href="#头部" class="header-anchor">#</a> 头部</h3> <p>展示一下请求头和响应头在报文中的位置:</p> <p><img src="/assets/img/02.83b52354.png" alt=""></p> <p><img src="/assets/img/03.35e79c8b.png" alt=""></p> <p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到http非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p> <ul><li>字段名不区分大小写</li> <li>字段名不允许出现空格，不可以出现下划线_</li> <li>字段名后面必须紧接着:</li></ul> <h3 id="空行"><a href="#空行" class="header-anchor">#</a> 空行</h3> <p>很重要，用来区分开头部和实体。</p> <p>问: 如果说在头部中间故意加一个空行会怎么样？</p> <p>那么空行后的内容全部被视为实体。</p> <h3 id="实体"><a href="#实体" class="header-anchor">#</a> 实体</h3> <p>就是具体的数据了，也就是body部分。请求报文对应请求体, 响应报文对应响应体。</p> <h2 id="_002-如何理解-http-的请求方法"><a href="#_002-如何理解-http-的请求方法" class="header-anchor">#</a> 002. 如何理解 HTTP 的请求方法？</h2> <h3 id="有哪些请求方法"><a href="#有哪些请求方法" class="header-anchor">#</a> 有哪些请求方法？</h3> <p>http/1.1规定了以下请求方法(注意，都是大写):</p> <ul><li>GET: 通常用来获取资源</li> <li>HEAD: 获取资源的元信息</li> <li>POST: 提交数据，即上传数据</li> <li>PUT: 修改数据</li> <li>DELETE: 删除资源(几乎用不到)</li> <li>CONNECT: 建立连接隧道，用于代理服务器</li> <li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li> <li>TRACE: 追踪请求-响应的传输路径</li></ul> <h3 id="get-和-post-有什么区别"><a href="#get-和-post-有什么区别" class="header-anchor">#</a> GET 和 POST 有什么区别？</h3> <p>首先最直观的是语义上的区别。
而后又有这样一些具体的差别:</p> <ul><li>从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li> <li>从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li> <li>从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li> <li>从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)</li> <li>从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li></ul> <h2 id="_003-如何理解-uri"><a href="#_003-如何理解-uri" class="header-anchor">#</a> 003: 如何理解 URI？</h2> <p>URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。
但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p> <h3 id="uri-的结构"><a href="#uri-的结构" class="header-anchor">#</a> URI 的结构</h3> <p>URI 真正最完整的结构是这样的。</p> <p><img src="/assets/img/04.a3dd2a2e.png" alt=""></p> <p>可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。
<strong>scheme</strong> 表示协议名，比如http, https, file等等。后面必须和://连在一起。
<strong>user:passwd@</strong> 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。
<strong>host:port</strong>表示主机名和端口。
<strong>path</strong>表示请求路径，标记资源所在位置。
<strong>query</strong>表示查询参数，为key=val这种形式，多个键值对之间用&amp;隔开。
<strong>fragment</strong>表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。
举个例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>https://www.baidu.com/s?wd<span class="token operator">=</span>HTTP<span class="token operator">&amp;</span><span class="token assign-left variable">rsv_spt</span><span class="token operator">=</span><span class="token number">1</span>
</code></pre></div><p>这个 URI 中，https即scheme部分，<font color="red">www.baidu.com</font>为host:port部分（注意，http 和 https 的默认端口分别为80、443），/s为path部分，而wd=HTTP&amp;rsv_spt=1就是query部分。</p> <h3 id="uri-编码"><a href="#uri-编码" class="header-anchor">#</a> URI 编码</h3> <p>URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。
因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。
如，空格被转义成了%20，三元被转义成了%E4%B8%89%E5%85%83。</p> <h2 id="_004-如何理解-http-状态码"><a href="#_004-如何理解-http-状态码" class="header-anchor">#</a> 004: 如何理解 HTTP 状态码？</h2> <p>RFC 规定 HTTP 的状态码为三位数，被分为五类:</p> <ul><li>1xx: 表示目前是协议处理的中间状态，还需要后续操作。</li> <li>2xx: 表示成功状态。</li> <li>3xx: 重定向状态，资源位置发生变动，需要重新请求。</li> <li>4xx: 请求报文有误。</li> <li>5xx: 服务器端发生错误。</li></ul> <p>接下来就一一分析这里面具体的状态码。</p> <h3 id="_1xx"><a href="#_1xx" class="header-anchor">#</a> 1xx</h3> <p>101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。</p> <h3 id="_2xx"><a href="#_2xx" class="header-anchor">#</a> 2xx</h3> <p>200 OK是见得最多的成功状态码。通常在响应体中放有数据。
204 No Content含义与 200 相同，但响应头后没有 body 数据。
206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段Content-Range。</p> <h3 id="_3xx"><a href="#_3xx" class="header-anchor">#</a> 3xx</h3> <p>301 Moved Permanently即永久重定向，对应着302 Found，即临时重定向。
比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。
而如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。
304 Not Modified: 当协商缓存命中时会返回这个状态码。</p> <h3 id="_4xx"><a href="#_4xx" class="header-anchor">#</a> 4xx</h3> <p>400 Bad Request: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。
403 Forbidden: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。
404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。
405 Method Not Allowed: 请求方法不被服务器端允许。
406 Not Acceptable: 资源无法满足客户端的条件。
408 Request Timeout: 服务器等待了太长时间。
409 Conflict: 多个请求发生了冲突。
413 Request Entity Too Large: 请求体的数据过大。
414 Request-URI Too Long: 请求行里的 URI 太大。
429 Too Many Request: 客户端发送的请求过多。
431 Request Header Fields Too Large请求头的字段内容太大。</p> <h3 id="_5xx"><a href="#_5xx" class="header-anchor">#</a> 5xx</h3> <p>500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。
501 Not Implemented: 表示客户端请求的功能还不支持。
502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。</p> <h2 id="_005-简要概括一下-http-的特点-http-有哪些缺点"><a href="#_005-简要概括一下-http-的特点-http-有哪些缺点" class="header-anchor">#</a> 005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h2> <h3 id="http-特点"><a href="#http-特点" class="header-anchor">#</a> HTTP 特点</h3> <p>HTTP 的特点概括如下:</p> <p>1.灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p> <p>2.可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</p> <p>3.请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</p> <p>4.无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</p> <h3 id="http-缺点"><a href="#http-缺点" class="header-anchor">#</a> HTTP 缺点</h3> <h4 id="无状态"><a href="#无状态" class="header-anchor">#</a> 无状态</h4> <p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。
在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p> <h4 id="明文传输"><a href="#明文传输" class="header-anchor">#</a> 明文传输</h4> <p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。
这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p> <h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="header-anchor">#</a> 队头阻塞问题</h4> <p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p> <h2 id="_006-对-accept-系列字段了解多少"><a href="#_006-对-accept-系列字段了解多少" class="header-anchor">#</a> 006: 对 Accept 系列字段了解多少？</h2> <p>对于Accept系列字段的介绍分为四个部分: 数据格式、压缩方式、支持语言和字符集。</p> <h3 id="数据格式"><a href="#数据格式" class="header-anchor">#</a> 数据格式</h3> <p>上一节谈到 HTTP 灵活的特性，它支持非常多的数据格式，那么这么多格式的数据一起到达客户端，客户端怎么知道它的格式呢？
当然，最低效的方式是直接猜，有没有更好的方式呢？直接指定可以吗？
答案是肯定的。不过首先需要介绍一个标准——MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。
因此，HTTP 从MIME type取了一部分来标记报文 body 部分的数据类型，这些类型体现在Content-Type这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用Accept字段。
具体而言，这两个字段的取值可以分为下面几类:</p> <p>text： text/html, text/plain, text/css 等
image: image/gif, image/jpeg, image/png 等
audio/video: audio/mpeg, video/mp4 等
application: application/json, application/javascript, application/pdf, application/octet-stream</p> <h3 id="压缩方式"><a href="#压缩方式" class="header-anchor">#</a> 压缩方式</h3> <p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的Content-Encoding字段上， 同样的，接收什么样的压缩方式体现在了接受方的Accept-Encoding字段上。这个字段的取值有下面几种：</p> <p>gzip: 当今最流行的压缩格式
deflate: 另外一种著名的压缩格式
br: 一种专门为 HTTP 发明的压缩算法</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 发送端
Content-Encoding: <span class="token function">gzip</span>
// 接收端
Accept-Encoding: <span class="token function">gzip</span>
</code></pre></div><h3 id="支持语言"><a href="#支持语言" class="header-anchor">#</a> 支持语言</h3> <p>对于发送方而言，还有一个Content-Language字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为Accept-Language。如:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 发送端
Content-Language: zh-CN, zh, en
// 接收端
Accept-Language: zh-CN, zh, en
</code></pre></div><h3 id="字符集"><a href="#字符集" class="header-anchor">#</a> 字符集</h3> <p>最后是一个比较特殊的字段, 在接收端对应为Accept-Charset，指定可以接受的字符集，而在发送端并没有对应的Content-Charset, 而是直接放在了Content-Type中，以charset属性指定。如:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 发送端
Content-Type: text/html<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
// 接收端
Accept-Charset: <span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
</code></pre></div><p>最后以一张图来总结一下吧:</p> <p><img src="/assets/img/05.fe83b18a.png" alt=""></p> <h2 id="_007-对于定长和不定长的数据-http-是怎么传输的"><a href="#_007-对于定长和不定长的数据-http-是怎么传输的" class="header-anchor">#</a> 007: 对于定长和不定长的数据，HTTP 是怎么传输的？</h2> <h3 id="定长包体"><a href="#定长包体" class="header-anchor">#</a> 定长包体</h3> <p>对于定长包体而言，发送端在传输的时候一般会带上 Content-Length, 来指明包体的长度。</p> <p>我们用一个nodejs服务器来模拟一下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const http <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

const server <span class="token operator">=</span> http.createServer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server.on<span class="token punctuation">(</span><span class="token string">'request'</span>, <span class="token punctuation">(</span>req, res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span>req.url <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res.setHeader<span class="token punctuation">(</span><span class="token string">'Content-Type'</span>, <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res.setHeader<span class="token punctuation">(</span><span class="token string">'Content-Length'</span>, <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res.write<span class="token punctuation">(</span><span class="token string">&quot;helloworld&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

server.listen<span class="token punctuation">(</span><span class="token number">8081</span>, <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;成功启动&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>启动后访问: localhost:8081。</p> <p>浏览器中显示如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>helloworld
</code></pre></div><p>这是长度正确的情况，那不正确的情况是如何处理的呢？</p> <p>我们试着把这个长度设置的小一些:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>res.setHeader<span class="token punctuation">(</span><span class="token string">'Content-Length'</span>, <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>重启服务，再次访问，现在浏览器中内容如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>hellowor
</code></pre></div><p>那后面的ld哪里去了呢？实际上在 http 的响应体中直接被截去了。</p> <p>然后我们试着将这个长度设置得大一些:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>res.setHeader<span class="token punctuation">(</span><span class="token string">'Content-Length'</span>, <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>此时浏览器显示如下:</p> <p><img src="/assets/img/06.8879a439.png" alt=""></p> <p>直接无法显示了。可以看到Content-Length对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p> <h3 id="不定长包体"><a href="#不定长包体" class="header-anchor">#</a> 不定长包体</h3> <p>上述是针对于定长包体，那么对于不定长包体而言是如何传输的呢？</p> <p>这里就必须介绍另外一个 http 头部字段了:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Transfer-Encoding: chunked
</code></pre></div><p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p> <ul><li>Content-Length 字段会被忽略</li> <li>基于长连接持续推送动态内容</li></ul> <p>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const http <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

const server <span class="token operator">=</span> http.createServer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server.on<span class="token punctuation">(</span><span class="token string">'request'</span>, <span class="token punctuation">(</span>req, res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span>req.url <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res.setHeader<span class="token punctuation">(</span><span class="token string">'Content-Type'</span>, <span class="token string">'text/html; charset=utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res.setHeader<span class="token punctuation">(</span><span class="token string">'Content-Length'</span>, <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res.setHeader<span class="token punctuation">(</span><span class="token string">'Transfer-Encoding'</span>, <span class="token string">'chunked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res.write<span class="token punctuation">(</span><span class="token string">&quot;&lt;p&gt;来啦&lt;/p&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      res.write<span class="token punctuation">(</span><span class="token string">&quot;第一次传输&lt;br/&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>, <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      res.write<span class="token punctuation">(</span><span class="token string">&quot;第二次传输&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      res.end<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>, <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

server.listen<span class="token punctuation">(</span><span class="token number">8009</span>, <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;成功启动&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><img src="data:image/png;base64,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28l71ign2J9g5lQfBi9fNo6zq320ADkHRy9IyoeDS+g8LK9ruKwfNuP0aswEOXUxg0cNx6V56VHTrkE513KOIdOr5ZRwWUOn/t+TxzijnK/tT/3XVrvXhjUeNRTYP9FrXvnyuiZ7sc52zyrXlDWHQKkhUxc7Ny+9bVrah11Z1/n6z7FMvLajhmGQJAnqI+5FYGtSe9hPkzolY6vW51IA03jJcb43D/su+HMmLHtxIXY79Q4W7M3E1nEJwMe7dbvrCzZOR3L0c/jjbU4zcnZjIVIxpL9uZ5Ft/bzDwOZktJfisBBbkdxJQuLGPACpyJZlyHI+jOPUfSV6dQuDyBMGWantICvXd0gw5cN+mnzWiARt8QgkZciO8715ZCRp3fvmtcmAKR8LHEJi7cqf/R4SkYndOvfa8n7qg+xFrl39BXmHASxEnJvAR0zItJYnG6lIgPGsjMwJUQ14SIlq535ESsckZMoLoHdHq87OmbBM755czodIhhF/7B+BpNl9kDzb9eZ07CL9stjC5PQwpwIAUmcnubnvqAa2PZI31/2lEbnjvnmp1zSslwKYZiejj9kpPOdMSIw9DONfrOHo/0cYkYzpHjXvlGavS1PwnAmJsQuRapadalSV0ryUXtkNveYlkS8YbE3IBCSM02leyjLyTQlAdFTDjFDRajO7aedMSOyUjD7mTNhGyEQgKSMbfZLaI83tqJAIJGXkI/Hj9pDU0S7WbTo3Yc2vqB8kcVhobV7Ki4aANR2JYjC/IkHqlIfn5Ew8F62/UN5PW/Vn1IF550KHpp6y/0wkntWrjWKxQM4GYqVaxkmqrNebZijhsQYu06kJG7tItrums+da00VMyHRZn6i+DMtuy4fscs3m2EsZ92ICjJMa5qoudpEaLmUfcciGLNvXcC5rYIGcD2NunAfBA9B/gRacrUkf6ozxJGpcBv1PcudeytpCUVfWfej0RNZvWdvy+abDiPPmWjQnzdq8VAZMF2xMtN02WTykYTuTqNmSZFkZlkJEYvCPWIkEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiARj6IgEY+iIBGPoiAT7f1ya3W/VPUBjAAAAAElFTkSuQmCC" alt=""></p> <p>用 telnet 抓到的响应如下:</p> <p><img src="/assets/img/08.fb9dac2b.png" alt=""></p> <p>注意，Connection: keep-alive及之前的为响应行和响应头，后面的内容为响应体，这两部分用换行符隔开。</p> <p>响应体的结构比较有意思，如下所示:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>chunk长度<span class="token punctuation">(</span><span class="token number">16</span>进制的数<span class="token punctuation">)</span>
第一个chunk的内容
chunk长度<span class="token punctuation">(</span><span class="token number">16</span>进制的数<span class="token punctuation">)</span>
第二个chunk的内容
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token number">0</span>
</code></pre></div><p>最后是留有有一个空行的，这一点请大家注意。</p> <p>以上便是 http 对于定长数据和不定长数据的传输方式。</p> <h2 id="_008-http-如何处理大文件的传输"><a href="#_008-http-如何处理大文件的传输" class="header-anchor">#</a> 008: HTTP 如何处理大文件的传输？</h2> <p>对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。</p> <p>###如何支持</p> <p>当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Accept-Ranges: none
</code></pre></div><p>用来告知客户端这边是支持范围请求的。</p> <p>###Range 字段拆解</p> <p>而对于客户端而言，它需要指定请求哪一部分，通过Range这个请求头字段确定，格式为bytes=x-y。接下来就来讨论一下这个 Range 的书写格式:</p> <ul><li>0-499表示从开始到第 499 个字节。</li> <li>500- 表示从第 500 字节到文件终点。</li> <li>-100表示文件的最后100个字节。</li></ul> <p>服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回416错误码，否则读取相应片段，返回206状态码。
同时，服务器需要添加Content-Range字段，这个字段的格式根据请求头中Range字段的不同而有所差异。
具体来说，请求单段数据和请求多段数据，响应头是不一样的。
举个例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 单段数据
Range: <span class="token assign-left variable">bytes</span><span class="token operator">=</span><span class="token number">0</span>-9
// 多段数据
Range: <span class="token assign-left variable">bytes</span><span class="token operator">=</span><span class="token number">0</span>-9, <span class="token number">30</span>-39

</code></pre></div><p>接下来我们就分别来讨论着两种情况。</p> <h3 id="单段数据"><a href="#单段数据" class="header-anchor">#</a> 单段数据</h3> <p>对于单段数据的请求，返回的响应如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>HTTP/1.1 <span class="token number">206</span> Partial Content
Content-Length: <span class="token number">10</span>
Accept-Ranges: bytes
Content-Range: bytes <span class="token number">0</span>-9/100

i am xxxxx
</code></pre></div><p>值得注意的是Content-Range字段，0-9表示请求的返回，100表示资源的总大小，很好理解。</p> <h3 id="多段数据"><a href="#多段数据" class="header-anchor">#</a> 多段数据</h3> <p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>HTTP/1.1 <span class="token number">206</span> Partial Content
Content-Type: multipart/byteranges<span class="token punctuation">;</span> <span class="token assign-left variable">boundary</span><span class="token operator">=</span>00000010101
Content-Length: <span class="token number">189</span>
Connection: keep-alive
Accept-Ranges: bytes


<span class="token parameter variable">--00000010101</span>
Content-Type: text/plain
Content-Range: bytes <span class="token number">0</span>-9/96

i am xxxxx
<span class="token parameter variable">--00000010101</span>
Content-Type: text/plain
Content-Range: bytes <span class="token number">20</span>-29/96

eex jspy e
--00000010101--
</code></pre></div><p>这个时候出现了一个非常关键的字段Content-Type: multipart/byteranges;boundary=00000010101，它代表了信息量是这样的:</p> <ul><li>请求一定是多段数据请求</li> <li>响应体中的分隔符是 00000010101</li></ul> <p>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上--表示结束。
以上就是 http 针对大文件传输所采用的手段。</p> <h2 id="_009-http-中如何处理表单数据的提交"><a href="#_009-http-中如何处理表单数据的提交" class="header-anchor">#</a> 009: HTTP 中如何处理表单数据的提交？</h2> <p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的Content-Type取值:</p> <ul><li>application/x-www-form-urlencoded</li> <li>multipart/form-data</li></ul> <p>由于表单提交一般是POST请求，很少考虑GET，因此这里我们将默认提交的数据放在请求体中。</p> <h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="header-anchor">#</a> application/x-www-form-urlencoded</h3> <p>对于application/x-www-form-urlencoded格式的表单内容，有以下特点:</p> <p>其中的数据会被编码成以&amp;分隔的键值对
字符以URL编码方式编码。</p> <p>如：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 转换过程: <span class="token punctuation">{</span>a: <span class="token number">1</span>, b: <span class="token number">2</span><span class="token punctuation">}</span> -<span class="token operator">&gt;</span> <span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">2</span> -<span class="token operator">&gt;</span> 如下<span class="token punctuation">(</span>最终形式<span class="token punctuation">)</span>
<span class="token string">&quot;a%3D1%26b%3D2&quot;</span>
</code></pre></div><h3 id="multipart-form-data"><a href="#multipart-form-data" class="header-anchor">#</a> multipart/form-data</h3> <p>对于multipart/form-data而言:</p> <p>请求头中的Content-Type字段会包含boundary，且boundary的值有浏览器默认指定。例: Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe。
数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如Content-Type，在最后的分隔符会加上--表示结束。</p> <p>相应的请求体是下面这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Content-Disposition: form-data<span class="token punctuation">;</span><span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;data1&quot;</span><span class="token punctuation">;</span>
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data<span class="token punctuation">;</span><span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;data2&quot;</span><span class="token punctuation">;</span>
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
</code></pre></div><h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>值得一提的是，multipart/form-data 格式最大的特点在于:每一个表单元素都是独立的资源表述。另外，你可能在写业务的过程中，并没有注意到其中还有boundary的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。
而且，在实际的场景中，对于图片等文件的上传，基本采用multipart/form-data而不用application/x-www-form-urlencoded，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。</p> <h2 id="_010-http1-1-如何解决-http-的队头阻塞问题"><a href="#_010-http1-1-如何解决-http-的队头阻塞问题" class="header-anchor">#</a> 010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h2> <h3 id="什么是-http-队头阻塞"><a href="#什么是-http-队头阻塞" class="header-anchor">#</a> 什么是 HTTP 队头阻塞？</h3> <p>从前面的小节可以知道，HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的HTTP队头阻塞问题。</p> <h3 id="并发连接"><a href="#并发连接" class="header-anchor">#</a> 并发连接</h3> <p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。
但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p> <h3 id="域名分片"><a href="#域名分片" class="header-anchor">#</a> 域名分片</h3> <p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。
比如 content1.sanyuan.com 、content2.sanyuan.com。
这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p> <h2 id="_011-对-cookie-了解多少"><a href="#_011-对-cookie-了解多少" class="header-anchor">#</a> 011: 对 Cookie 了解多少？</h2> <h3 id="cookie-简介"><a href="#cookie-简介" class="header-anchor">#</a> Cookie 简介</h3> <p>前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？
HTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的Set-Cookie字段来对客户端写入Cookie。举例如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 请求头
Cookie: <span class="token assign-left variable">a</span><span class="token operator">=</span>xxx<span class="token punctuation">;</span><span class="token assign-left variable">b</span><span class="token operator">=</span>xxx
// 响应头
Set-Cookie: <span class="token assign-left variable">a</span><span class="token operator">=</span>xxx
set-Cookie: <span class="token assign-left variable">b</span><span class="token operator">=</span>xxx
</code></pre></div><h3 id="cookie-属性"><a href="#cookie-属性" class="header-anchor">#</a> Cookie 属性</h3> <h4 id="生存周期"><a href="#生存周期" class="header-anchor">#</a> 生存周期</h4> <p>Cookie 的有效期可以通过Expires和Max-Age两个属性来设置。</p> <ul><li>Expires即过期时间</li> <li>Max-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。</li></ul> <p>若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。</p> <h4 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h4> <p>关于作用域也有两个属性: Domain和path, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 Cookie。</p> <h4 id="安全相关"><a href="#安全相关" class="header-anchor">#</a> 安全相关</h4> <p>如果带上Secure，说明只能通过 HTTPS 传输 cookie。
如果 cookie 字段带上HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。
相应的，对于 CSRF 攻击的预防，也有SameSite属性。
SameSite可以设置为三个值，Strict、Lax和None。
a. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。
b. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
c. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。</p> <h3 id="cookie-的缺点"><a href="#cookie-的缺点" class="header-anchor">#</a> Cookie 的缺点</h3> <p>1.容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。</p> <p>2.性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过Domain和Path指定作用域来解决。</p> <p>3.安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</p> <h2 id="_012-如何理解-http-代理"><a href="#_012-如何理解-http-代理" class="header-anchor">#</a> 012: 如何理解 HTTP 代理？</h2> <p>我们知道在 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。
当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。
那代理服务器到底是用来做什么的呢？</p> <h3 id="功能"><a href="#功能" class="header-anchor">#</a> 功能</h3> <p>1.负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性hash、LRU(最近最少使用)等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</p> <p>2.保障安全。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</p> <p>3.缓存代理。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。</p> <h3 id="相关头部字段"><a href="#相关头部字段" class="header-anchor">#</a> 相关头部字段</h3> <h4 id="via"><a href="#via" class="header-anchor">#</a> Via</h4> <p>代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？
通过Via字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>客户端 -<span class="token operator">&gt;</span> 代理1 -<span class="token operator">&gt;</span> 代理2 -<span class="token operator">&gt;</span> 源服务器
</code></pre></div><p>在源服务器收到请求后，会在请求头拿到这个字段:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Via: proxy_server1, proxy_server2
</code></pre></div><p>而源服务器响应时，最终在客户端会拿到这样的响应头:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Via: proxy_server2, proxy_server1
</code></pre></div><p>可以看到，Via中代理的顺序即为在 HTTP 传输中报文传达的顺序。</p> <h4 id="x-forwarded-for"><a href="#x-forwarded-for" class="header-anchor">#</a> X-Forwarded-For</h4> <p>字面意思就是为谁转发, 它记录的是请求方的IP地址(注意，和Via区分开，X-Forwarded-For记录的是请求方这一个IP)。</p> <h4 id="x-real-ip"><a href="#x-real-ip" class="header-anchor">#</a> X-Real-IP</h4> <p>是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP。
相应的，还有X-Forwarded-Host和X-Forwarded-Proto，分别记录客户端(注意哦，不包括代理)的域名和协议名。</p> <p>####X-Forwarded-For产生的问题</p> <p>前面可以看到，X-Forwarded-For这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从客户端到代理1，这个字段是客户端的 IP，从代理1到代理2，这个字段就变为了代理1的 IP。
但是这会产生两个问题:</p> <p>1.意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。</p> <p>2.在 HTTPS 通信加密的过程中，原始报文是不允许修改的。</p> <p>由此产生了代理协议，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 <span class="token number">0.0</span>.0.1 <span class="token number">0.0</span>.0.2 <span class="token number">1111</span> <span class="token number">2222</span>
GET / HTTP/1.1
<span class="token punctuation">..</span>.
</code></pre></div><p>这样就可以解决X-Forwarded-For带来的问题了。</p> <h2 id="_013-如何理解-http-缓存及缓存代理"><a href="#_013-如何理解-http-缓存及缓存代理" class="header-anchor">#</a> 013: 如何理解 HTTP 缓存及缓存代理？</h2> <p>关于强缓存和协商缓存的内容，我已经在能不能说一说浏览器缓存做了详细分析，小结如下:
首先通过 Cache-Control 验证强缓存是否可用</p> <ul><li><p>如果强缓存可用，直接使用</p></li> <li><p>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新</p> <ul><li>若资源更新，返回资源和200状态码</li> <li>否则，返回304，告诉浏览器直接从缓存获取资源</li></ul></li></ul> <p>这一节我们主要来说说另外一种缓存方式: 代理缓存。</p> <h3 id="为什么产生代理缓存"><a href="#为什么产生代理缓存" class="header-anchor">#</a> 为什么产生代理缓存？</h3> <p>对于源服务器来说，它也是有缓存的，比如Redis, Memcache，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。
由此引入了缓存代理的机制。让代理服务器接管一部分的服务端HTTP缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。
那缓存代理究竟是如何做到的呢？
总的来说，缓存代理的控制分为两部分，一部分是源服务器端的控制，一部分是客户端的控制。</p> <h3 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="header-anchor">#</a> 源服务器的缓存控制</h3> <h4 id="private-和-public"><a href="#private-和-public" class="header-anchor">#</a> private 和 public</h4> <p>在源服务器的响应头中，会加上Cache-Control这个字段进行缓存控制字段，那么它的值当中可以加入private或者public表示是否允许代理服务器缓存，前者禁止，后者为允许。
比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的Cache-Control设为private，而不是public。</p> <h4 id="proxy-revalidate"><a href="#proxy-revalidate" class="header-anchor">#</a> proxy-revalidate</h4> <p>must-revalidate的意思是客户端缓存过期就去源服务器获取，而proxy-revalidate则表示代理服务器的缓存过期后到源服务器获取。</p> <h4 id="s-maxage"><a href="#s-maxage" class="header-anchor">#</a> s-maxage</h4> <p>s是share的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突。
讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Cache-Control: public, max-age<span class="token operator">=</span><span class="token number">1000</span>, s-maxage<span class="token operator">=</span><span class="token number">2000</span>
</code></pre></div><p>相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。</p> <h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="header-anchor">#</a> 客户端的缓存控制</h3> <h4 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="header-anchor">#</a> max-stale 和 min-fresh</h4> <p>在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作。比如</p> <div class="language-bash extra-class"><pre class="language-bash"><code>max-stale: <span class="token number">5</span>
</code></pre></div><p>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在5秒之内，还是可以从代理中获取的。</p> <p>又比如:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>min-fresh: <span class="token number">5</span>
</code></pre></div><p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。</p> <h4 id="only-if-cached"><a href="#only-if-cached" class="header-anchor">#</a> only-if-cached</h4> <p>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504（Gateway Timeout）。
以上便是缓存代理的内容，涉及的字段比较多，希望能好好回顾一下，加深理解。</p> <h2 id="_014-什么是跨域-浏览器如何拦截响应-如何解决"><a href="#_014-什么是跨域-浏览器如何拦截响应-如何解决" class="header-anchor">#</a> 014: 什么是跨域？浏览器如何拦截响应？如何解决？</h2> <p>在前后端分离的开发模式中，经常会遇到跨域问题，即 Ajax 请求发出去了，服务器也成功响应了，前端就是拿不到这个响应。接下来我们就来好好讨论一下这个问题。</p> <h3 id="什么是跨域"><a href="#什么是跨域" class="header-anchor">#</a> 什么是跨域</h3> <p>回顾一下 URI 的组成:</p> <p><img src="/assets/img/09.1a341378.png" alt=""></p> <p>浏览器遵循同源政策(scheme(协议)、host(主机)和port(端口)都相同则为同源)。非同源站点有这样一些限制:</p> <ul><li>不能读取和修改对方的 DOM</li> <li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li> <li>限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)</li></ul> <p>当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为跨域请求。
跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。那这个拦截是如何发生呢？
首先要知道的是，浏览器是多进程的，以 Chrome 为例，进程组成如下：</p> <p><img src="/assets/img/10.92fb4aa2.png" alt=""></p> <p>WebKit 渲染引擎和V8 引擎都在渲染进程当中。</p> <p>当xhr.send被调用，即 Ajax 请求准备发送的时候，其实还只是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并且为了防止 CPU 芯片一直存在的Spectre 和 Meltdown漏洞，采取了站点隔离的手段，给每一个不同的站点(一级域名不同)分配了沙箱，互不干扰。</p> <p>在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过网络进程来发送。那这样就涉及到进程间通信(IPC，Inter Process Communication)了。接下来我们看看 chromium 当中进程间通信是如何完成的，在 chromium 源码中调用顺序如下:</p> <p><img src="/assets/img/11.d04b6f7f.png" alt=""></p> <p>总的来说就是利用Unix Domain Socket套接字，配合事件驱动的高性能网络并发库libevent完成进程的 IPC 过程。</p> <p>好，现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。</p> <p>在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。
接下来我们来说一说解决跨域问题的几种方案。</p> <h3 id="cors"><a href="#cors" class="header-anchor">#</a> CORS</h3> <p>CORS 其实是 W3C 的一个标准，全称是跨域资源共享。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: 简单请求和非简单请求。
浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于简单请求:</p> <p>请求方法为 GET、POST 或者 HEAD
请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)</p> <p>浏览器画了这样一个圈，在这个圈里面的就是简单请求, 圈外面的就是非简单请求，然后针对这两种不同的请求进行不同的处理。</p> <h4 id="简单请求"><a href="#简单请求" class="header-anchor">#</a> 简单请求</h4> <p>请求发出去之前，浏览器做了什么？
它会自动在请求头当中，添加一个Origin字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应地添加Access-Control-Allow-Origin字段，如果Origin不在这个字段的范围中，那么浏览器就会将响应拦截。
因此，Access-Control-Allow-Origin字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。
Access-Control-Allow-Credentials。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为true, 并且在前端也需要设置withCredentials属性:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> xhr <span class="token operator">=</span> new XMLHttpRequest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr.withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p>Access-Control-Expose-Headers。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）, 还能拿到这个字段声明的响应头字段。比如这样设置:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Access-Control-Expose-Headers: aaa
</code></pre></div><p>那么在前端可以通过 XMLHttpRequest.getResponseHeader('aaa') 拿到 aaa 这个字段的值。</p> <h4 id="非简单请求"><a href="#非简单请求" class="header-anchor">#</a> 非简单请求</h4> <p>非简单请求相对而言会有些不同，体现在两个方面: 预检请求和响应字段。</p> <p>我们以 PUT 方法为例。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>var url <span class="token operator">=</span> <span class="token string">'http://xxx.com'</span><span class="token punctuation">;</span>
var xhr <span class="token operator">=</span> new XMLHttpRequest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr.open<span class="token punctuation">(</span><span class="token string">'PUT'</span>, url, <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr.setRequestHeader<span class="token punctuation">(</span><span class="token string">'X-Custom-Header'</span>, <span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr.send<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当这段代码执行后，首先会发送预检请求。这个预检请求的请求行和请求体是下面这个格式:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>OPTIONS / HTTP/1.1
Origin: 当前地址
Host: xxx.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
</code></pre></div><p>预检请求的方法是OPTIONS，同时会加上Origin源地址和Host目标地址，这很简单。同时也会加上两个关键的字段:</p> <p>Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法
Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头</p> <p>这是预检请求。接下来是响应字段，响应字段也分为两部分，一部分是对于预检请求的响应，一部分是对于 CORS 请求的响应。
预检请求的响应。如下面的格式:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>HTTP/1.1 <span class="token number">200</span> OK
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: <span class="token boolean">true</span>
Access-Control-Max-Age: <span class="token number">1728000</span>
Content-Type: text/html<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
Content-Encoding: <span class="token function">gzip</span>
Content-Length: <span class="token number">0</span>
</code></pre></div><p>其中有这样几个关键的响应头字段:</p> <ul><li>Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。</li> <li>Access-Control-Allow-Methods: 表示允许的请求方法列表。</li> <li>Access-Control-Allow-Credentials: 简单请求中已经介绍。</li> <li>Access-Control-Allow-Headers: 表示允许发送的请求头字段</li> <li>Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</li></ul> <p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。
CORS 请求的响应。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上Origin字段，服务端响应头返回Access-Control-Allow-Origin。可以参考以上简单请求部分的内容。</p> <h3 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h3> <p>虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const jsonp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> url, params, callbackName <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  const generateURL <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> dataStr <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
    for<span class="token punctuation">(</span>let key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dataStr <span class="token operator">+=</span> <span class="token variable"><span class="token variable">`</span>$<span class="token punctuation">{</span>key<span class="token punctuation">}</span><span class="token operator">=</span>$<span class="token punctuation">{</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">&amp;</span><span class="token variable">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dataStr <span class="token operator">+=</span> <span class="token variable"><span class="token variable">`</span><span class="token assign-left variable">callback</span><span class="token operator">=</span>$<span class="token punctuation">{</span>callbackName<span class="token punctuation">}</span><span class="token variable">`</span></span><span class="token punctuation">;</span>
    <span class="token builtin class-name">return</span> <span class="token variable"><span class="token variable">`</span>$<span class="token punctuation">{</span>url<span class="token punctuation">}</span>?$<span class="token punctuation">{</span>dataStr<span class="token punctuation">}</span><span class="token variable">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token builtin class-name">return</span> new Promise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    // 初始化回调函数名称
    callbackName <span class="token operator">=</span> callbackName <span class="token operator">||</span> Math.random<span class="token punctuation">(</span><span class="token punctuation">)</span>.toString.replace<span class="token punctuation">(</span><span class="token string">','</span>, <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    // 创建 script 元素并加入到当前文档中
    <span class="token builtin class-name">let</span> scriptEle <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    scriptEle.src <span class="token operator">=</span> generateURL<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    document.body.appendChild<span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    // 绑定到 window 上，为了后面调用
    window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      resolve<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild<span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然在服务端也会有响应的操作, 以 express 为例:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> express <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span>
<span class="token builtin class-name">let</span> app <span class="token operator">=</span> express<span class="token punctuation">(</span><span class="token punctuation">)</span>
app.get<span class="token punctuation">(</span><span class="token string">'/'</span>, function<span class="token punctuation">(</span>req, res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> <span class="token punctuation">{</span> a, b, callback <span class="token punctuation">}</span> <span class="token operator">=</span> req.query
  console.log<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token number">1</span>
  console.log<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token number">2</span>
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>$<span class="token punctuation">{</span>callback<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token string">'数据包'</span><span class="token punctuation">)</span><span class="token variable">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
app.listen<span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
</code></pre></div><p>前端这样简单地调用一下就好了:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>jsonp<span class="token punctuation">(</span><span class="token punctuation">{</span>
  url: <span class="token string">'http://localhost:3000'</span>,
  params: <span class="token punctuation">{</span> 
    a: <span class="token number">1</span>,
    b: <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  // 拿到数据进行处理
  console.log<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> // 数据包
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>和CORS相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p> <h3 id="nginx"><a href="#nginx" class="header-anchor">#</a> Nginx</h3> <p>Nginx 是一种高性能的反向代理服务器，可以用来轻松解决跨域问题。</p> <p>what？反向代理？我给你看一张图你就懂了。</p> <p><img src="/assets/img/12.9045415b.png" alt=""></p> <p>正向代理帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端。
反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的负载均衡，换句话说，反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。
因此，两者的区别就很明显了，正向代理服务器是帮客户端做事情，而反向代理服务器是帮其它的服务器做事情。
好了，那 Nginx 是如何来解决跨域的呢？
比如说现在客户端的域名为client.com，服务器的域名为server.com，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>server <span class="token punctuation">{</span>
  listen  <span class="token number">80</span><span class="token punctuation">;</span>
  server_name  client.com<span class="token punctuation">;</span>
  location /api <span class="token punctuation">{</span>
    proxy_pass server.com<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是client.com，让客户端首先访问 client.com/api，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给server.com，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。
其实还有一些不太常用的方式，大家了解即可，比如postMessage，当然WebSocket也是一种方式，但是已经不属于 HTTP 的范畴，另外一些奇技淫巧就不建议大家去死记硬背了，一方面从来不用，名字都难得记住，另一方面临时背下来，面试官也不会对你印象加分，因为看得出来是背的。当然没有背并不代表减分，把跨域原理和前面三种主要的跨域方式理解清楚，经得起更深一步的推敲，反而会让别人觉得你是一个靠谱的人。</p> <h2 id="_015-tls1-2-握手的过程是怎样的"><a href="#_015-tls1-2-握手的过程是怎样的" class="header-anchor">#</a> 015: TLS1.2 握手的过程是怎样的？</h2> <p>之前谈到了 HTTP 是明文传输的协议，传输保文对外完全透明，非常不安全，那如何进一步保证安全性呢？
由此产生了 HTTPS，其实它并不是一个新的协议，而是在 HTTP 下面增加了一层 SSL/TLS 协议，简单的讲，HTTPS = HTTP + SSL/TLS。
那什么是 SSL/TLS 呢？
SSL 即安全套接层（Secure Sockets Layer），在 OSI 七层模型中处于会话层(第 5 层)。之前 SSL 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 TLS（传输层安全，Transport Layer Security），并被当做 TLS1.0 的版本，准确地说，TLS1.0 = SSL3.1。
现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。因此我们接下来主要讨论的是 TLS1.2, 当然在 2018 年推出了更加优秀的 TLS1.3，大大优化了 TLS 握手过程，这个我们放在下一节再去说。
TLS 握手的过程比较复杂，写文章之前我查阅了大量的资料，发现对 TLS 初学者非常不友好，也有很多知识点说的含糊不清，可以说这个整理的过程是相当痛苦了。希望我下面的拆解能够帮你理解得更顺畅些吧 : ）</p> <h3 id="传统-rsa-握手"><a href="#传统-rsa-握手" class="header-anchor">#</a> 传统 RSA 握手</h3> <p>先来说说传统的 TLS 握手，也是大家在网上经常看到的。我之前也写过这样的文章，<a href="http://47.98.159.95/my_blog/browser-security/003.html" target="_blank" rel="noopener noreferrer">(传统RSA版本)HTTPS为什么让数据传输更安全<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，其中也介绍到了对称加密和非对称加密的概念，建议大家去读一读，不再赘述。之所以称它为 RSA 版本，是因为它在加解密pre_random的时候采用的是 RSA 算法。</p> <h3 id="tls-1-2-握手过程"><a href="#tls-1-2-握手过程" class="header-anchor">#</a> TLS 1.2 握手过程</h3> <p>现在我们来讲讲主流的 TLS 1.2 版本所采用的方式。</p> <p><img src="/assets/img/13.03092810.png" alt=""></p> <p>刚开始你可能会比较懵，先别着急，过一遍下面的流程再来看会豁然开朗。</p> <h4 id="step-1-client-hello"><a href="#step-1-client-hello" class="header-anchor">#</a> step 1: Client Hello</h4> <p>首先，浏览器发送 client_random、TLS版本、加密套件列表。
client_random 是什么？用来最终 secret 的一个参数。
加密套件列表是什么？我举个例子，加密套件列表一般张这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>TLS_ECDHE_WITH_AES_128_GCM_SHA256
</code></pre></div><p>意思是TLS握手过程中，使用ECDHE算法生成pre_random(这个数后面会介绍)，128位的AES算法进行对称加密，在对称加密的过程中使用主流的GCM分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是哈希摘要算法，采用SHA256算法。
其中值得解释一下的是这个哈希摘要算法，试想一个这样的场景，服务端现在给客户端发消息来了，客户端并不知道此时的消息到底是服务端发的，还是中间人伪造的消息呢？现在引入这个哈希摘要算法，将服务端的证书信息通过这个算法生成一个摘要(可以理解为比较短的字符串)，用来标识这个服务端的身份，用私钥加密后把加密后的标识和自己的公钥传给客户端。客户端拿到这个公钥来解密，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务端的身份。这也就是所谓数字签名的原理。其中除了哈希算法，最重要的过程是私钥加密，公钥解密。</p> <h3 id="step-2-server-hello"><a href="#step-2-server-hello" class="header-anchor">#</a> step 2: Server Hello</h3> <p>可以看到服务器一口气给客户端回复了非常多的内容。
server_random也是最后生成secret的一个参数, 同时确认 TLS 版本、需要使用的加密套件和自己的证书，这都不难理解。那剩下的server_params是干嘛的呢？
我们先埋个伏笔，现在你只需要知道，server_random到达了客户端。</p> <p>###step 3: Client 验证证书，生成secret</p> <p>客户端验证服务端传来的证书和签名是否通过，如果验证通过，则传递client_params这个参数给服务器。
接着客户端通过ECDHE算法计算出pre_random，其中传入两个参数:server_params和client_params。现在你应该清楚这个两个参数的作用了吧，由于ECDHE基于椭圆曲线离散对数，这两个参数也称作椭圆曲线的公钥。
客户端现在拥有了client_random、server_random和pre_random，接下来将这三个数通过一个伪随机数函数来计算出最终的secret。</p> <h3 id="step4-server-生成-secret"><a href="#step4-server-生成-secret" class="header-anchor">#</a> step4: Server 生成 secret</h3> <p>刚刚客户端不是传了client_params过来了吗？
现在服务端开始用ECDHE算法生成pre_random，接着用和客户端同样的伪随机数函数生成最后的secret。</p> <h3 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h3> <p>TLS的过程基本上讲完了，但还有两点需要注意。
第一、实际上 TLS 握手是一个双向认证的过程，从 step1 中可以看到，客户端有能力验证服务器的身份，那服务器能不能验证客户端的身份呢？
当然是可以的。具体来说，在 step3中，客户端传送client_params，实际上给服务器传一个验证消息，让服务器将相同的验证流程(哈希摘要 + 私钥加密 + 公钥解密)走一遍，确认客户端的身份。
第二、当客户端生成secret后，会给服务端发送一个收尾的消息，告诉服务器之后的都用对称加密，对称加密的算法就用第一次约定的。服务器生成完secret也会向客户端发送一个收尾的消息，告诉客户端以后就直接用对称加密来通信。
这个收尾的消息包括两部分，一部分是Change Cipher Spec，意味着后面加密传输了，另一个是Finished消息，这个消息是对之前所有发送的数据做的摘要，对摘要进行加密，让对方验证一下。
当双方都验证通过之后，握手才正式结束。后面的 HTTP 正式开始传输加密报文。</p> <h3 id="rsa-和-ecdhe-握手过程的区别"><a href="#rsa-和-ecdhe-握手过程的区别" class="header-anchor">#</a> RSA 和 ECDHE 握手过程的区别</h3> <p>1.ECDHE 握手，也就是主流的 TLS1.2 握手中，使用ECDHE实现pre_random的加密解密，没有用到 RSA。</p> <p>2.使用 ECDHE 还有一个特点，就是客户端发送完收尾消息后可以提前抢跑，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫TLS False Start。</p> <h2 id="_016-tls-1-3-做了哪些改进"><a href="#_016-tls-1-3-做了哪些改进" class="header-anchor">#</a> 016: TLS 1.3 做了哪些改进？</h2> <p>TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在2018年就推出了 TLS1.3，对于TLS1.2做了一系列的改进，主要分为这几个部分:强化安全、提高性能。</p> <h3 id="强化安全"><a href="#强化安全" class="header-anchor">#</a> 强化安全</h3> <p>在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:</p> <ul><li>TLS_AES_128_GCM_SHA256</li> <li>TLS_AES_256_GCM_SHA384</li> <li>TLS_CHACHA20_POLY1305_SHA256</li> <li>TLS_AES_128_GCM_SHA256</li> <li>TLS_AES_128_GCM_8_SHA256</li></ul> <p>可以看到，最后剩下的对称加密算法只有 AES 和 CHACHA20，之前主流的也会这两种。分组模式也只剩下 GCM 和 POLY1305, 哈希摘要算法只剩下了 SHA256 和 SHA384 了。
那你可能会问了, 之前RSA这么重要的非对称加密算法怎么不在了？</p> <p>我觉得有两方面的原因:</p> <p>第一、2015年发现了FREAK攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。
第二、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的secret，破解之前所有的密文。</p> <p>为什么？回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成pre_random并用公钥加密传给服务器，服务器通过私钥解密，从而拿到真实的pre_random。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到pre_random、server_random和client_random并根据对应的随机数函数生成secret，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。
但ECDHE在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫前向安全性。
RSA 算法不具备前向安全性，而 ECDHE 具备，因此在 TLS1.3 中彻底取代了RSA。</p> <h3 id="提升性能"><a href="#提升性能" class="header-anchor">#</a> 提升性能</h3> <h4 id="握手改进"><a href="#握手改进" class="header-anchor">#</a> 握手改进</h4> <p>流程如下:</p> <p><img src="/assets/img/14.02275065.png" alt=""></p> <p>大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到client_params，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算secret，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。</p> <p>这种 TLS 1.3 握手方式也被叫做1-RTT握手。但其实这种1-RTT的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。</p> <h4 id="会话复用"><a href="#会话复用" class="header-anchor">#</a> 会话复用</h4> <p>会话复用有两种方式: Session ID和Session Ticket。</p> <p>先说说最早出现的Seesion ID，具体做法是客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送ID过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。
但这种方式也存在一个弊端，就是当客户端数量庞大的时候，对服务端的存储压力非常大。</p> <p>因而出现了第二种方式——Session Ticket。它的思路就是: 服务端的压力大，那就把压力分摊给客户端呗。具体来说，双方连接成功后，服务器加密会话信息，用Session Ticket消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。</p> <p>这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。</p> <p>总的来说，这些会话复用的技术在保证1-RTT的同时，也节省了生成会话密钥这些算法所消耗的时间，是一笔可观的性能提升。</p> <p>####PSK</p> <p>刚刚说的都是1-RTT情况下的优化，那能不能优化到0-RTT呢？</p> <p>答案是可以的。做法其实也很简单，在发送Session Ticket的同时带上应用数据，不用等到服务端确认，这种方式被称为Pre-Shared Key，即 PSK。</p> <p>这种方式虽然方便，但也带来了安全问题。中间人截获PSK的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>TLS1.3 在 TLS1.2 的基础上废除了大量的算法，提升了安全性。同时利用会话复用节省了重新生成密钥的时间，利用 PSK 做到了0-RTT连接。</p> <h2 id="_017-http-2-有哪些改进"><a href="#_017-http-2-有哪些改进" class="header-anchor">#</a> 017: HTTP/2 有哪些改进？</h2> <p>由于 HTTPS 在安全方面已经做的非常好了，HTTP 改进的关注点放在了性能方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:</p> <ul><li>头部压缩</li> <li>多路复用</li></ul> <p>当然还有一些颠覆性的功能实现:</p> <ul><li>设置请求优先级</li> <li>服务器推送</li></ul> <p>这些重大的提升本质上也是为了解决 HTTP 本身的问题而产生的。接下来我们来看看 HTTP/2 解决了哪些问题，以及解决方式具体是如何的。</p> <h3 id="头部压缩"><a href="#头部压缩" class="header-anchor">#</a> 头部压缩</h3> <p>在 HTTP/1.1 及之前的时代，请求体一般会有响应的压缩编码过程，通过Content-Encoding头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。
HPACK 算法是专门为 HTTP/2 服务的，它主要的亮点有两个：</p> <ul><li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用。</li></ul> <p><img src="/assets/img/15.749a5dc2.png" alt=""></p> <div class="language-bash extra-class"><pre class="language-bash"><code>HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个<span class="token string">&quot;:&quot;</span>前缀，用来和其它请求头区分开。
</code></pre></div><ul><li>其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率</li></ul> <h3 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> 多路复用</h3> <h4 id="http-队头阻塞"><a href="#http-队头阻塞" class="header-anchor">#</a> HTTP 队头阻塞</h4> <p>我们之前讨论了 HTTP 队头阻塞的问题，其根本原因在于HTTP 基于请求-响应的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。</p> <p>后面我们又讨论到用并发连接和域名分片的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接会竞争有限的带宽，让真正优先级高的请求不能优先处理。</p> <p>而 HTTP/2 便从 HTTP 协议本身解决了队头阻塞问题。注意，这里并不是指的TCP队头阻塞，而是HTTP队头阻塞，两者并不是一回事。TCP 的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而HTTP 的队头阻塞是在 HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。</p> <p>那么 HTTP/2 如何来解决所谓的队头阻塞呢？</p> <h4 id="二进制分帧"><a href="#二进制分帧" class="header-anchor">#</a> 二进制分帧</h4> <p>首先，HTTP/2 认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把报文全部换成二进制格式，全部传输01串，方便了机器的解析。</p> <p>原来Headers + Body的报文格式如今被拆分成了一个个二进制的帧，用Headers帧存放头部字段，Data帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。</p> <p>通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念。</p> <p>可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p> <p>首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能，我们放到下一节再来介绍。</p> <h3 id="服务器推送"><a href="#服务器推送" class="header-anchor">#</a> 服务器推送</h3> <p>另外值得一说的是 HTTP/2 的服务器推送(Server Push)。在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p> <h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <p>当然，HTTP/2 新增那么多的特性，是不是 HTTP 的语法要重新学呢？不需要，HTTP/2 完全兼容之前 HTTP 的语法和语义，如请求头、URI、状态码、头部字段都没有改变，完全不用担心。同时，在安全方面，HTTP 也支持 TLS，并且现在主流的浏览器都公开只支持加密的 HTTP/2, 因此你现在能看到的 HTTP/2 也基本上都是跑在 TLS 上面的了。最后放一张分层图给大家参考:</p> <p><img src="/assets/img/16.1d1c6e2e.png" alt=""></p> <h2 id="_018-http-2-中的二进制帧是如何设计的"><a href="#_018-http-2-中的二进制帧是如何设计的" class="header-anchor">#</a> 018: HTTP/2 中的二进制帧是如何设计的？</h2> <h3 id="帧结构"><a href="#帧结构" class="header-anchor">#</a> 帧结构</h3> <p>HTTP/2 中传输的帧结构如下图所示:</p> <p><img src="/assets/img/17.b30c69fa.png" alt=""></p> <p>每个帧分为帧头和帧体。先是三个字节的帧长度，这个长度表示的是帧体的长度。</p> <p>然后是帧类型，大概可以分为数据帧和控制帧两种。数据帧用来存放 HTTP 报文，控制帧用来管理流的传输。</p> <p>接下来的一个字节是帧标志，里面一共有 8 个标志位，常用的有 END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束。</p> <p>后 4 个字节是Stream ID, 也就是流标识符，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。</p> <h3 id="流的状态变化"><a href="#流的状态变化" class="header-anchor">#</a> 流的状态变化</h3> <p>从前面可以知道，在 HTTP/2 中，所谓的流，其实就是二进制帧的双向传输的序列。那么在 HTTP/2 请求和响应的过程中，流的状态是如何变化的呢？</p> <p>HTTP/2 其实也是借鉴了 TCP 状态变化的思想，根据帧的标志位来实现具体的状态改变。这里我们以一个普通的请求-响应过程为例来说明：</p> <p><img src="/assets/img/18.e83639aa.png" alt=""></p> <p>最开始两者都是空闲状态，当客户端发送Headers帧后，开始分配Stream ID, 此时客户端的流打开, 服务端接收之后服务端的流也打开，两端的流都打开之后，就可以互相传递数据帧和控制帧了。</p> <p>当客户端要关闭时，向服务端发送END_STREAM帧，进入半关闭状态, 这个时候客户端只能接收数据，而不能发送数据。</p> <p>服务端收到这个END_STREAM帧后也进入半关闭状态，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送END_STREAM帧，表示数据发送完毕，双方进入关闭状态。</p> <p>如果下次要开启新的流，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个。</p> <h3 id="流的特性"><a href="#流的特性" class="header-anchor">#</a> 流的特性</h3> <p>刚刚谈到了流的状态变化过程，这里顺便就来总结一下流传输的特性:</p> <p>并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现多路复用的基础。</p> <p>自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</p> <p>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方或者接收方。</p> <p>可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</p> <p>以上就是对 HTTP/2 中二进制帧的介绍，希望对你有所启发。</p> <p><font color="#ff502c">申明：此篇文章转载于</font><a href="https://juejin.im/post/6844904100035821575#heading-58" target="_blank" rel="noopener noreferrer">此处<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><font color="#ff502c">，如有侵权，请联系删除，谢谢！</font></p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_001-http-报文结构是怎样的" class="sidebar-link reco-side-_001-http-报文结构是怎样的" data-v-b57cc07c>001. HTTP 报文结构是怎样的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#起始行" class="sidebar-link reco-side-起始行" data-v-b57cc07c>起始行</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#头部" class="sidebar-link reco-side-头部" data-v-b57cc07c>头部</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#空行" class="sidebar-link reco-side-空行" data-v-b57cc07c>空行</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#实体" class="sidebar-link reco-side-实体" data-v-b57cc07c>实体</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_002-如何理解-http-的请求方法" class="sidebar-link reco-side-_002-如何理解-http-的请求方法" data-v-b57cc07c>002. 如何理解 HTTP 的请求方法？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#有哪些请求方法" class="sidebar-link reco-side-有哪些请求方法" data-v-b57cc07c>有哪些请求方法？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#get-和-post-有什么区别" class="sidebar-link reco-side-get-和-post-有什么区别" data-v-b57cc07c>GET 和 POST 有什么区别？</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_003-如何理解-uri" class="sidebar-link reco-side-_003-如何理解-uri" data-v-b57cc07c>003: 如何理解 URI？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#uri-的结构" class="sidebar-link reco-side-uri-的结构" data-v-b57cc07c>URI 的结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#uri-编码" class="sidebar-link reco-side-uri-编码" data-v-b57cc07c>URI 编码</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_004-如何理解-http-状态码" class="sidebar-link reco-side-_004-如何理解-http-状态码" data-v-b57cc07c>004: 如何理解 HTTP 状态码？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#_1xx" class="sidebar-link reco-side-_1xx" data-v-b57cc07c>1xx</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#_2xx" class="sidebar-link reco-side-_2xx" data-v-b57cc07c>2xx</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#_3xx" class="sidebar-link reco-side-_3xx" data-v-b57cc07c>3xx</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#_4xx" class="sidebar-link reco-side-_4xx" data-v-b57cc07c>4xx</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#_5xx" class="sidebar-link reco-side-_5xx" data-v-b57cc07c>5xx</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_005-简要概括一下-http-的特点-http-有哪些缺点" class="sidebar-link reco-side-_005-简要概括一下-http-的特点-http-有哪些缺点" data-v-b57cc07c>005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#http-特点" class="sidebar-link reco-side-http-特点" data-v-b57cc07c>HTTP 特点</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#http-缺点" class="sidebar-link reco-side-http-缺点" data-v-b57cc07c>HTTP 缺点</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_006-对-accept-系列字段了解多少" class="sidebar-link reco-side-_006-对-accept-系列字段了解多少" data-v-b57cc07c>006: 对 Accept 系列字段了解多少？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#数据格式" class="sidebar-link reco-side-数据格式" data-v-b57cc07c>数据格式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#压缩方式" class="sidebar-link reco-side-压缩方式" data-v-b57cc07c>压缩方式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#支持语言" class="sidebar-link reco-side-支持语言" data-v-b57cc07c>支持语言</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#字符集" class="sidebar-link reco-side-字符集" data-v-b57cc07c>字符集</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_007-对于定长和不定长的数据-http-是怎么传输的" class="sidebar-link reco-side-_007-对于定长和不定长的数据-http-是怎么传输的" data-v-b57cc07c>007: 对于定长和不定长的数据，HTTP 是怎么传输的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#定长包体" class="sidebar-link reco-side-定长包体" data-v-b57cc07c>定长包体</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#不定长包体" class="sidebar-link reco-side-不定长包体" data-v-b57cc07c>不定长包体</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_008-http-如何处理大文件的传输" class="sidebar-link reco-side-_008-http-如何处理大文件的传输" data-v-b57cc07c>008: HTTP 如何处理大文件的传输？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#单段数据" class="sidebar-link reco-side-单段数据" data-v-b57cc07c>单段数据</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#多段数据" class="sidebar-link reco-side-多段数据" data-v-b57cc07c>多段数据</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_009-http-中如何处理表单数据的提交" class="sidebar-link reco-side-_009-http-中如何处理表单数据的提交" data-v-b57cc07c>009: HTTP 中如何处理表单数据的提交？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#application-x-www-form-urlencoded" class="sidebar-link reco-side-application-x-www-form-urlencoded" data-v-b57cc07c>application/x-www-form-urlencoded</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#multipart-form-data" class="sidebar-link reco-side-multipart-form-data" data-v-b57cc07c>multipart/form-data</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#小结" class="sidebar-link reco-side-小结" data-v-b57cc07c>小结</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_010-http1-1-如何解决-http-的队头阻塞问题" class="sidebar-link reco-side-_010-http1-1-如何解决-http-的队头阻塞问题" data-v-b57cc07c>010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#什么是-http-队头阻塞" class="sidebar-link reco-side-什么是-http-队头阻塞" data-v-b57cc07c>什么是 HTTP 队头阻塞？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#并发连接" class="sidebar-link reco-side-并发连接" data-v-b57cc07c>并发连接</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#域名分片" class="sidebar-link reco-side-域名分片" data-v-b57cc07c>域名分片</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_011-对-cookie-了解多少" class="sidebar-link reco-side-_011-对-cookie-了解多少" data-v-b57cc07c>011: 对 Cookie 了解多少？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#cookie-简介" class="sidebar-link reco-side-cookie-简介" data-v-b57cc07c>Cookie 简介</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#cookie-属性" class="sidebar-link reco-side-cookie-属性" data-v-b57cc07c>Cookie 属性</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#cookie-的缺点" class="sidebar-link reco-side-cookie-的缺点" data-v-b57cc07c>Cookie 的缺点</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_012-如何理解-http-代理" class="sidebar-link reco-side-_012-如何理解-http-代理" data-v-b57cc07c>012: 如何理解 HTTP 代理？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#功能" class="sidebar-link reco-side-功能" data-v-b57cc07c>功能</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#相关头部字段" class="sidebar-link reco-side-相关头部字段" data-v-b57cc07c>相关头部字段</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_013-如何理解-http-缓存及缓存代理" class="sidebar-link reco-side-_013-如何理解-http-缓存及缓存代理" data-v-b57cc07c>013: 如何理解 HTTP 缓存及缓存代理？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#为什么产生代理缓存" class="sidebar-link reco-side-为什么产生代理缓存" data-v-b57cc07c>为什么产生代理缓存？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#源服务器的缓存控制" class="sidebar-link reco-side-源服务器的缓存控制" data-v-b57cc07c>源服务器的缓存控制</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#客户端的缓存控制" class="sidebar-link reco-side-客户端的缓存控制" data-v-b57cc07c>客户端的缓存控制</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_014-什么是跨域-浏览器如何拦截响应-如何解决" class="sidebar-link reco-side-_014-什么是跨域-浏览器如何拦截响应-如何解决" data-v-b57cc07c>014: 什么是跨域？浏览器如何拦截响应？如何解决？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#什么是跨域" class="sidebar-link reco-side-什么是跨域" data-v-b57cc07c>什么是跨域</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#cors" class="sidebar-link reco-side-cors" data-v-b57cc07c>CORS</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#jsonp" class="sidebar-link reco-side-jsonp" data-v-b57cc07c>JSONP</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#nginx" class="sidebar-link reco-side-nginx" data-v-b57cc07c>Nginx</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_015-tls1-2-握手的过程是怎样的" class="sidebar-link reco-side-_015-tls1-2-握手的过程是怎样的" data-v-b57cc07c>015: TLS1.2 握手的过程是怎样的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#传统-rsa-握手" class="sidebar-link reco-side-传统-rsa-握手" data-v-b57cc07c>传统 RSA 握手</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#tls-1-2-握手过程" class="sidebar-link reco-side-tls-1-2-握手过程" data-v-b57cc07c>TLS 1.2 握手过程</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#step-2-server-hello" class="sidebar-link reco-side-step-2-server-hello" data-v-b57cc07c>step 2: Server Hello</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#step4-server-生成-secret" class="sidebar-link reco-side-step4-server-生成-secret" data-v-b57cc07c>step4: Server 生成 secret</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#注意事项" class="sidebar-link reco-side-注意事项" data-v-b57cc07c>注意事项</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#rsa-和-ecdhe-握手过程的区别" class="sidebar-link reco-side-rsa-和-ecdhe-握手过程的区别" data-v-b57cc07c>RSA 和 ECDHE 握手过程的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_016-tls-1-3-做了哪些改进" class="sidebar-link reco-side-_016-tls-1-3-做了哪些改进" data-v-b57cc07c>016: TLS 1.3 做了哪些改进？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#强化安全" class="sidebar-link reco-side-强化安全" data-v-b57cc07c>强化安全</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#提升性能" class="sidebar-link reco-side-提升性能" data-v-b57cc07c>提升性能</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#总结" class="sidebar-link reco-side-总结" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_017-http-2-有哪些改进" class="sidebar-link reco-side-_017-http-2-有哪些改进" data-v-b57cc07c>017: HTTP/2 有哪些改进？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#头部压缩" class="sidebar-link reco-side-头部压缩" data-v-b57cc07c>头部压缩</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#多路复用" class="sidebar-link reco-side-多路复用" data-v-b57cc07c>多路复用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#服务器推送" class="sidebar-link reco-side-服务器推送" data-v-b57cc07c>服务器推送</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#总结-2" class="sidebar-link reco-side-总结-2" data-v-b57cc07c>总结</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/HTTP.html#_018-http-2-中的二进制帧是如何设计的" class="sidebar-link reco-side-_018-http-2-中的二进制帧是如何设计的" data-v-b57cc07c>018: HTTP/2 中的二进制帧是如何设计的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#帧结构" class="sidebar-link reco-side-帧结构" data-v-b57cc07c>帧结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#流的状态变化" class="sidebar-link reco-side-流的状态变化" data-v-b57cc07c>流的状态变化</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/HTTP.html#流的特性" class="sidebar-link reco-side-流的特性" data-v-b57cc07c>流的特性</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/media/starsky.m4a" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:20px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/media/starsky.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/media/starsky.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>Star Sky</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>Two Steps From Hell</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/assets/js/app.276fe4ed.js" defer></script><script src="/assets/js/7.52cd3cfd.js" defer></script><script src="/assets/js/2.5e77f0d2.js" defer></script><script src="/assets/js/1.c3e4b76d.js" defer></script><script src="/assets/js/16.b75b2a2c.js" defer></script>
  </body>
</html>
