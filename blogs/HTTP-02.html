<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TCP协议灵魂之问(下篇) | 张垒的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="记录好的技术文档">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.06cff2a7.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.5d9f3e6e.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/7.52cd3cfd.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.5e77f0d2.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/1.c3e4b76d.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/23.7f170fad.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.fce7151c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.665820a8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.1cfbcfc6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.06542fc4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.5a7a423b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.d2f8beac.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.3366a66f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.a0f84501.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.8cf233fc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.d142c8ff.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.3f0558f8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.ca3d8f1b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.e8704ed0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.ea2f5a39.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.87921c42.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.f31d39ff.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.5c2c99a1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.eff7fee9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.b375e77b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.e44aa03f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.82fe56b9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.c7707b2a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.5977256e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.7648c433.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.0d04e6fc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.f85a8b69.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.a49efe7f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.98053ef4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.15d7a48b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.2ed1c6b3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.665e6da9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.bba66369.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.0102712f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.fc0cf83d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.b24876fd.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.999a2df2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.5cfca3d0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.d70d2f6c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/49.80d9cea6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.fb9624e5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/50.ca82dac4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/51.a6b49e93.js"><link rel="prefetch" href="/vuepress-blog/assets/js/52.7f08f076.js"><link rel="prefetch" href="/vuepress-blog/assets/js/53.2a888b74.js"><link rel="prefetch" href="/vuepress-blog/assets/js/54.b39c22d6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/55.a9a9bc24.js"><link rel="prefetch" href="/vuepress-blog/assets/js/56.c9ba9d63.js"><link rel="prefetch" href="/vuepress-blog/assets/js/57.af85ad1c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/58.b21e620f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/59.604943d3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.09f6a933.js"><link rel="prefetch" href="/vuepress-blog/assets/js/60.d0b6fce9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/61.54065b41.js"><link rel="prefetch" href="/vuepress-blog/assets/js/62.f0028e7f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/63.195ddca5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/64.761c82aa.js"><link rel="prefetch" href="/vuepress-blog/assets/js/65.6002006f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/66.97ef0021.js"><link rel="prefetch" href="/vuepress-blog/assets/js/67.ac085f10.js"><link rel="prefetch" href="/vuepress-blog/assets/js/68.e3587494.js"><link rel="prefetch" href="/vuepress-blog/assets/js/69.22b18dd6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/70.017b9424.js"><link rel="prefetch" href="/vuepress-blog/assets/js/71.1c39dd94.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.0899600d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.1f42c771.js"><link rel="prefetch" href="/vuepress-blog/assets/js/vendors~docsearch.680926dd.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.06cff2a7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>张垒的博客</h3> <p class="description" data-v-59e6cb88>记录好的技术文档</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">张垒的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/vuepress-blogme.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>33</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>31</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>TCP协议灵魂之问(下篇)</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">TCP协议灵魂之问(下篇)</h1> <div data-v-8a445198><!----> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2020/10/25</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>TCP</span></i></div></div> <div class="theme-reco-content content__default"><p>TCP 作为传输层的协议，是一个软件工程师素养的体现，也是面试中经常被问到的知识点。在此，我将 TCP 核心的一些问题梳理了一下，希望能帮到各位。</p> <h2 id="_001-能不能说一说-tcp-和-udp-的区别"><a href="#_001-能不能说一说-tcp-和-udp-的区别" class="header-anchor">#</a> 001. 能不能说一说 TCP 和 UDP 的区别？</h2> <p>首先概括一下基本的区别:
TCP是一个面向连接的、可靠的、基于字节流的传输层协议。
而UDP是一个面向无连接的传输层协议。(就这么简单，其它TCP的特性也就没有了)。
具体来分析，和 UDP 相比，TCP 有三大核心特性:</p> <p>1.面向连接。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。</p> <p>2.可靠性。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。</p> <p>TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。
当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。
相应的，UDP 就是无状态, 不可控的。</p> <p>3.面向字节流。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。</p> <h2 id="_002-说说-tcp-三次握手的过程-为什么是三次而不是两次、四次"><a href="#_002-说说-tcp-三次握手的过程-为什么是三次而不是两次、四次" class="header-anchor">#</a> 002: 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？</h2> <h3 id="恋爱模拟"><a href="#恋爱模拟" class="header-anchor">#</a> 恋爱模拟</h3> <p>以谈恋爱为例，两个人能够在一起最重要的事情是首先确认各自爱和被爱的能力。接下来我们以此来模拟三次握手的过程。
第一次:
男: 我爱你。
女方收到。
由此证明男方拥有爱的能力。
第二次:
女: 我收到了你的爱，我也爱你。
男方收到。
OK，现在的情况说明，女方拥有爱和被爱的能力。
第三次:
男: 我收到了你的爱。
女方收到。
现在能够保证男方具备被爱的能力。
由此完整地确认了双方爱和被爱的能力，两人开始一段甜蜜的爱情。</p> <h3 id="真实握手"><a href="#真实握手" class="header-anchor">#</a> 真实握手</h3> <p>当然刚刚那段属于扯淡，不代表本人价值观，目的是让大家理解整个握手过程的意义，因为两个过程非常相似。对应到 TCP 的三次握手，也是需要确认双方的两样能力: 发送的能力和接收的能力。于是便会有下面的三次握手的过程:</p> <p><img src="/vuepress-blogassets/img/01.a89f1f9e.png" alt=""></p> <p>从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。
然后客户端主动发起连接，发送 SYN , 自己变成了SYN-SENT状态。
服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。
之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。
另外需要提醒你注意的是，从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1，为什么呢？只需要记住一个规则:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>凡是需要对端确认的，一定消耗TCP报文的序列号。
</code></pre></div><p>SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。</p> <h3 id="为什么不是两次"><a href="#为什么不是两次" class="header-anchor">#</a> 为什么不是两次？</h3> <p>根本原因: 无法确认客户端的接收能力。
分析如下:
如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。
看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。
看到问题的吧，这就带来了连接资源的浪费。</p> <h3 id="为什么不是四次"><a href="#为什么不是四次" class="header-anchor">#</a> 为什么不是四次？</h3> <p>三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？
当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。
三次握手过程中可以携带数据么？
第三次握手的时候，可以携带。前两次握手不能携带数据。
如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。
第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。</p> <h3 id="同时打开会怎样"><a href="#同时打开会怎样" class="header-anchor">#</a> 同时打开会怎样？</h3> <p>如果双方同时发 SYN报文，状态变化会是怎样的呢？
这是一个可能会发生的情况。
状态变迁如下:</p> <p><img src="/vuepress-blogassets/img/02.47932c68.png" alt=""></p> <p>在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文，两个人刚上了!
发完SYN，两者的状态都变为SYN-SENT。
在各自收到对方的SYN后，两者状态都变为SYN-REVD。
接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。
这就是同时打开情况下的状态变迁。</p> <h2 id="_003-说说-tcp-四次挥手的过程"><a href="#_003-说说-tcp-四次挥手的过程" class="header-anchor">#</a> 003: 说说 TCP 四次挥手的过程</h2> <h3 id="过程拆解"><a href="#过程拆解" class="header-anchor">#</a> 过程拆解</h3> <p><img src="/vuepress-blogassets/img/03.69244cc1.png" alt=""></p> <p>刚开始双方处于ESTABLISHED状态。</p> <p>客户端要断开了，向服务器发送 FIN 报文，在 TCP 报文中的位置如下图:</p> <p><img src="/vuepress-blogassets/img/04.79b87108.png" alt=""></p> <p>发送后客户端变成了FIN-WAIT-1状态。注意, 这时候客户端同时也变成了half-close(半关闭)状态，即无法向服务端发送报文，只能接收。
服务端接收后向客户端确认，变成了CLOSED-WAIT状态。
客户端接收到了服务端的确认，变成了FIN-WAIT2状态。
随后，服务端向客户端发送FIN，自己进入LAST-ACK状态，
客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。
注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。</p> <h3 id="等待2msl的意义"><a href="#等待2msl的意义" class="header-anchor">#</a> 等待2MSL的意义</h3> <p>如果不等待会怎样？
如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。
那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?</p> <p>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</p> <p>这就是等待 2MSL 的意义。</p> <p>###为什么是四次挥手而不是三次？</p> <p>因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。
如果是三次挥手会有什么问题？
等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。</p> <h3 id="同时关闭会怎样"><a href="#同时关闭会怎样" class="header-anchor">#</a> 同时关闭会怎样？</h3> <p>如果客户端和服务端同时发送 FIN ，状态会如何变化？如图所示:</p> <p><img src="/vuepress-blogassets/img/05.37f66287.png" alt=""></p> <h2 id="_004-说说半连接队列和-syn-flood-攻击的关系"><a href="#_004-说说半连接队列和-syn-flood-攻击的关系" class="header-anchor">#</a> 004: 说说半连接队列和 SYN Flood 攻击的关系</h2> <p>三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。</p> <h3 id="半连接队列"><a href="#半连接队列" class="header-anchor">#</a> 半连接队列</h3> <p>当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。</p> <h3 id="全连接队列"><a href="#全连接队列" class="header-anchor">#</a> 全连接队列</h3> <p>当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。</p> <h3 id="syn-flood-攻击原理"><a href="#syn-flood-攻击原理" class="header-anchor">#</a> SYN Flood 攻击原理</h3> <p>SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:</p> <p>1.处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。</p> <p>2.由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</p> <h3 id="如何应对-syn-flood-攻击"><a href="#如何应对-syn-flood-攻击" class="header-anchor">#</a> 如何应对 SYN Flood 攻击？</h3> <p>1.增加 SYN 连接，也就是增加半连接队列的容量。
2.减少 SYN + ACK 重试次数，避免大量的超时重发。
3.利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。</p> <h2 id="_005-介绍一下-tcp-报文头部的字段"><a href="#_005-介绍一下-tcp-报文头部的字段" class="header-anchor">#</a> 005: 介绍一下 TCP 报文头部的字段</h2> <p>报文头部结构如下(单位为字节):</p> <p><img src="/vuepress-blogassets/img/06.f0882f8c.png" alt=""></p> <p>请大家牢记这张图！</p> <p>###源端口、目标端口</p> <p>如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。
那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。</p> <h3 id="序列号"><a href="#序列号" class="header-anchor">#</a> 序列号</h3> <p>即Sequence number, 指的是本报文段第一个字节的序列号。
从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到0。
序列号在 TCP 通信的过程中有两个作用:</p> <p>在 SYN 报文中交换彼此的初始序列号。
保证数据包按正确的顺序组装。</p> <h3 id="isn"><a href="#isn" class="header-anchor">#</a> ISN</h3> <p>即Initial Sequence Number（初始序列号）,在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN。
ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？
如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。
而动态增长的 ISN 大大提高了猜测 ISN 的难度。</p> <h3 id="确认号"><a href="#确认号" class="header-anchor">#</a> 确认号</h3> <p>即ACK(Acknowledgment number)。用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到。</p> <h3 id="标记位"><a href="#标记位" class="header-anchor">#</a> 标记位</h3> <p>常见的标记位有SYN,ACK,FIN,RST,PSH。
SYN 和 ACK 已经在上文说过，后三个解释如下:
FIN： 即 Finish，表示发送方准备断开连接。
RST：即 Reset，用来强制断开连接。
PSH： 即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。</p> <h3 id="窗口大小"><a href="#窗口大小" class="header-anchor">#</a> 窗口大小</h3> <p>占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。</p> <h3 id="校验和"><a href="#校验和" class="header-anchor">#</a> 校验和</h3> <p>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。</p> <h3 id="可选项"><a href="#可选项" class="header-anchor">#</a> 可选项</h3> <p>可选项的格式如下:</p> <p><img src="/vuepress-blogassets/img/07.a89d1358.png" alt=""></p> <p>常用的可选项有以下几个:</p> <ul><li>TimeStamp: TCP 时间戳，后面详细介绍。</li> <li>MSS: 指的是 TCP 允许的从对方接收的最大报文段。</li> <li>SACK: 选择确认选项。</li> <li>Window Scale： 窗口缩放选项。</li></ul> <h2 id="_006-说说-tcp-快速打开的原理-tfo"><a href="#_006-说说-tcp-快速打开的原理-tfo" class="header-anchor">#</a> 006: 说说 TCP 快速打开的原理(TFO)</h2> <p>第一节讲了 TCP 三次握手，可能有人会说，每次都三次握手好麻烦呀！能不能优化一点？
可以啊。今天来说说这个优化后的 TCP 握手流程，也就是 TCP 快速打开(TCP Fast Open, 即TFO)的原理。
优化的过程是这样的，还记得我们说 SYN Flood 攻击时提到的 SYN Cookie 吗？这个 Cookie 可不是浏览器的Cookie, 用它同样可以实现 TFO。</p> <h3 id="tfo-流程"><a href="#tfo-流程" class="header-anchor">#</a> TFO 流程</h3> <h4 id="首轮三次握手"><a href="#首轮三次握手" class="header-anchor">#</a> 首轮三次握手</h4> <p>首先客户端发送SYN给服务端，服务端接收到。
注意哦！现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个SYN Cookie, 将这个Cookie放到 TCP 报文的 Fast Open选项中，然后才给客户端返回。
客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。
首轮三次握手就是这样的流程。而后面的三次握手就不一样啦！</p> <h4 id="后面的三次握手"><a href="#后面的三次握手" class="header-anchor">#</a> 后面的三次握手</h4> <p>在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和HTTP请求(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回SYN + ACK。
重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。
当然，客户端的ACK还得正常传过来，不然怎么叫三次握手嘛。
流程如下:</p> <p><img src="/vuepress-blogassets/img/08.e403a484.png" alt=""></p> <p>注意: 客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。</p> <p>###TFO 的优势</p> <p>TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输，积累起来还是一个比较大的优势。</p> <h2 id="_007-能不能说说tcp报文中时间戳的作用"><a href="#_007-能不能说说tcp报文中时间戳的作用" class="header-anchor">#</a> 007: 能不能说说TCP报文中时间戳的作用？</h2> <p>timestamp是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>kind<span class="token punctuation">(</span><span class="token number">1</span> 字节<span class="token punctuation">)</span> + length<span class="token punctuation">(</span><span class="token number">1</span> 字节<span class="token punctuation">)</span> + info<span class="token punctuation">(</span><span class="token number">8</span> 个字节<span class="token punctuation">)</span>
</code></pre></div><p>其中 kind = 8， length = 10， info 有两部分构成: timestamp和timestamp echo，各占 4 个字节。
那么这些字段都是干嘛的呢？它们用来解决那些问题？
接下来我们就来一一梳理，TCP 的时间戳主要解决两大问题:</p> <ul><li>计算往返时延 RTT(Round-Trip Time)</li> <li>防止序列号的回绕问题</li></ul> <h3 id="计算往返时延-rtt"><a href="#计算往返时延-rtt" class="header-anchor">#</a> 计算往返时延 RTT</h3> <p>在没有时间戳的时候，计算 RTT 会遇到的问题如下图所示:</p> <p><img src="/vuepress-blogassets/img/09.48292130.png" alt=""></p> <p>如果以第一次发包为开始时间的话，就会出现左图的问题，RTT 明显偏大，开始时间应该采用第二次的；
如果以第二次发包为开始时间的话，就会导致右图的问题，RTT 明显偏小，开始时间应该采用第一次发包的。
实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的。
那这个时候引入时间戳就很好的解决了这个问题。
比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 ACK 的报文 s2 那么：</p> <ul><li>step 1: a 向 b 发送的时候，timestamp 中存放的内容就是 a 主机发送时的内核时刻 ta1。</li> <li>step 2: b 向 a 回复 s2 报文的时候，timestamp 中存放的是 b 主机的时刻 tb, timestamp echo字段为从 s1 报文中解析出来的 ta1。</li> <li>step 3: a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 ta1, 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值。</li></ul> <h3 id="防止序列号回绕问题"><a href="#防止序列号回绕问题" class="header-anchor">#</a> 防止序列号回绕问题</h3> <p>现在我们来模拟一下这个问题。
序列号的范围其实是在0 ~ 2 ^ 32 - 1, 为了方便演示，我们缩小一下这个区间，假设范围是 0 ~ 4，那么到达 4 的时候会回到 0。</p> <table><thead><tr><th>第几次发包</th> <th>发送字节</th> <th>对应序列号</th> <th>状态</th></tr></thead> <tbody><tr><td>1</td> <td>0 ~ 1</td> <td>0 ~ 1</td> <td>成功接收</td></tr> <tr><td>2</td> <td>1 ~ 2</td> <td>1 ~ 2</td> <td>滞留在网络中</td></tr> <tr><td>3</td> <td>2 ~ 3</td> <td>2 ~ 3</td> <td>成功接收</td></tr> <tr><td>4</td> <td>3 ~ 4</td> <td>3 ~ 4</td> <td>成功接收</td></tr> <tr><td>5</td> <td>4 ~ 5</td> <td>0 ~ 1</td> <td>成功接收，序列号从0开始</td></tr> <tr><td>6</td> <td>5 ~ 6</td> <td>1 ~ 2</td> <td>？？？</td></tr></tbody></table> <p>假设在第 6 次的时候，之前还滞留在网路中的包回来了，那么就有两个序列号为1 ~ 2的数据包了，怎么区分谁是谁呢？这个时候就产生了序列号回绕的问题。
那么用 timestamp 就能很好地解决这个问题，因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。</p> <h2 id="_008-tcp-的超时重传时间是如何计算的"><a href="#_008-tcp-的超时重传时间是如何计算的" class="header-anchor">#</a> 008: TCP 的超时重传时间是如何计算的？</h2> <p>TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。
那么这个重传间隔是如何来计算的呢？
今天我们就来讨论一下这个问题。
这个重传间隔也叫做超时重传时间(Retransmission TimeOut, 简称RTO)，它的计算跟上一节提到的 RTT 密切相关。这里我们将介绍两种主要的方法，一个是经典方法，一个是标准方法。</p> <h3 id="经典方法"><a href="#经典方法" class="header-anchor">#</a> 经典方法</h3> <p>经典方法引入了一个新的概念——SRTT(Smoothed round trip time，即平滑往返时间)，没产生一次新的 RTT. 就根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下(SRTT 初始值为0):</p> <div class="language-bash extra-class"><pre class="language-bash"><code>SRTT <span class="token operator">=</span>  <span class="token punctuation">(</span>α * SRTT<span class="token punctuation">)</span> + <span class="token punctuation">((</span><span class="token number">1</span> - α<span class="token punctuation">)</span> * RTT<span class="token punctuation">)</span>
</code></pre></div><p>其中，α 是平滑因子，建议值是0.8，范围是0.8 ~ 0.9。</p> <p>拿到 SRTT，我们就可以计算 RTO 的值了:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>RTO <span class="token operator">=</span> min<span class="token punctuation">(</span>ubound, max<span class="token punctuation">(</span>lbound, β * SRTT<span class="token punctuation">))</span>
</code></pre></div><p>其实这个算法过程还是很简单的，但是也存在一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为平滑因子 α 的范围是0.8 ~ 0.9, RTT 对于 RTO 的影响太小。</p> <h3 id="标准方法"><a href="#标准方法" class="header-anchor">#</a> 标准方法</h3> <p>为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫Jacobson / Karels 算法。
一共有三步。
第一步: 计算SRTT，公式如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>SRTT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> - α<span class="token punctuation">)</span> * SRTT + α * RTT
</code></pre></div><p>注意这个时候的 α跟经典方法中的α取值不一样了，建议值是1/8，也就是0.125。</p> <p>第二步: 计算RTTVAR(round-trip time variation)这个中间变量。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>RTTVAR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> - β<span class="token punctuation">)</span> * RTTVAR + β * <span class="token punctuation">(</span><span class="token operator">|</span>RTT - SRTT<span class="token operator">|</span><span class="token punctuation">)</span>
</code></pre></div><p>β 建议值为 0.25。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手。</p> <p>第三步: 计算最终的RTO:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>RTO <span class="token operator">=</span> µ * SRTT + ∂ * RTTVAR 
</code></pre></div><p>µ建议值取1, ∂建议值取4。</p> <p>这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算法下，RTO 与 RTT 变化的差值关系更加密切。</p> <h2 id="_009-能不能说一说-tcp-的流量控制"><a href="#_009-能不能说一说-tcp-的流量控制" class="header-anchor">#</a> 009: 能不能说一说 TCP 的流量控制？</h2> <p>对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。
而流量控制索要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。
要具体理解流量控制，首先需要了解滑动窗口的概念。</p> <h3 id="tcp-滑动窗口"><a href="#tcp-滑动窗口" class="header-anchor">#</a> TCP 滑动窗口</h3> <p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。</p> <h4 id="发送窗口"><a href="#发送窗口" class="header-anchor">#</a> 发送窗口</h4> <p>发送端的滑动窗口结构如下:</p> <p><img src="/vuepress-blogassets/img/10.4f9154db.png" alt=""></p> <p>其中包含四大部分:</p> <ul><li>已发送且已确认</li> <li>已发送但未确认</li> <li>未发送但可以发送</li> <li>未发送也不可以发送</li></ul> <p>其中有一些重要的概念，我标注在图中:</p> <p><img src="/vuepress-blogassets/img/11.69e3d808.png" alt=""></p> <p>发送窗口就是图中被框住的范围。SND 即send, WND 即window, UNA 即unacknowledged, 表示未被确认，NXT 即next, 表示下一个发送的位置。</p> <h4 id="接收窗口"><a href="#接收窗口" class="header-anchor">#</a> 接收窗口</h4> <p>接收端的窗口结构如下:</p> <p><img src="/vuepress-blogassets/img/12.8b0a4a4b.png" alt=""></p> <p>REV 即 receive，NXT 表示下一个接收的位置，WND 表示接收窗口大小。</p> <h3 id=""><a href="#" class="header-anchor">#</a></h3> <p>流量控制过程
这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。
首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。
假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。
现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。
注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。
因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。
此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。
这也就是流量控制的过程。尽管回合再多，整个控制的过程和原理是一样的。</p> <h2 id="_010-能不能说说-tcp-的拥塞控制"><a href="#_010-能不能说说-tcp-的拥塞控制" class="header-anchor">#</a> 010: 能不能说说 TCP 的拥塞控制？</h2> <p>上一节所说的流量控制发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是拥塞控制需要处理的问题。
对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:</p> <ul><li>拥塞窗口（Congestion Window，cwnd）</li> <li>慢启动阈值（Slow Start Threshold，ssthresh）</li></ul> <p>涉及到的算法有这几个:</p> <ul><li>慢启动</li> <li>拥塞避免</li> <li>快速重传和快速恢复</li></ul> <p>接下来，我们就来一一拆解这些状态和算法。首先，从拥塞窗口说起。</p> <h3 id="拥塞窗口"><a href="#拥塞窗口" class="header-anchor">#</a> 拥塞窗口</h3> <p>拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。
那么之前介绍了接收窗口的概念，两者有什么区别呢？</p> <ul><li>接收窗口(rwnd)是接收端给的限制</li> <li>拥塞窗口(cwnd)是发送端的限制</li></ul> <p>限制谁呢？
限制的是发送窗口的大小。
有了这两个窗口，如何来计算发送窗口？</p> <div class="language-bash extra-class"><pre class="language-bash"><code>发送窗口大小 <span class="token operator">=</span> min<span class="token punctuation">(</span>rwnd, cwnd<span class="token punctuation">)</span>
</code></pre></div><p>取两者的较小值。而拥塞控制，就是来控制cwnd的变化。</p> <h3 id="慢启动"><a href="#慢启动" class="header-anchor">#</a> 慢启动</h3> <p>刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。
因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下:</p> <ul><li>首先，三次握手，双方宣告自己的接收窗口大小</li> <li>双方初始化自己的拥塞窗口(cwnd)大小</li> <li>在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。</li></ul> <p>难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做慢启动阈值，当 cwnd 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！
在到达阈值后，如何来控制 cwnd 的大小呢？
这就是拥塞避免做的事情了。</p> <h3 id="拥塞避免"><a href="#拥塞避免" class="header-anchor">#</a> 拥塞避免</h3> <p>原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: 1 / cwnd。那你仔细算算，一轮 RTT 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。
也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。
当然，慢启动和拥塞避免是一起作用的，是一体的。</p> <h3 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="header-anchor">#</a> 快速重传和快速恢复</h3> <h4 id="快速重传"><a href="#快速重传" class="header-anchor">#</a> 快速重传</h4> <p>在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。
比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。
这就是快速重传，它解决的是是否需要重传的问题。</p> <h4 id="选择性重传"><a href="#选择性重传" class="header-anchor">#</a> 选择性重传</h4> <p>那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？
当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。
在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做选择性重传(SACK，Selective Acknowledgment)，它解决的是如何重传的问题。</p> <h4 id="快速恢复"><a href="#快速恢复" class="header-anchor">#</a> 快速恢复</h4> <p>当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。
在这个阶段，发送端如下改变：</p> <ul><li>拥塞阈值降低为 cwnd 的一半</li> <li>cwnd 的大小变为拥塞阈值</li> <li>cwnd 线性增加</li></ul> <p>以上就是 TCP 拥塞控制的经典算法: 慢启动、拥塞避免、快速重传和快速恢复。</p> <h2 id="_011-能不能说说-nagle-算法和延迟确认"><a href="#_011-能不能说说-nagle-算法和延迟确认" class="header-anchor">#</a> 011: 能不能说说 Nagle 算法和延迟确认？</h2> <h3 id="nagle-算法"><a href="#nagle-算法" class="header-anchor">#</a> Nagle 算法</h3> <p>试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。
而避免小包的频繁发送，这就是 Nagle 算法要做的事情。
具体来说，Nagle 算法的规则如下:</p> <ul><li>当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送</li> <li>后面发送满足下面条件之一就可以发了:
<ul><li>数据包大小达到最大段大小(Max Segment Size, 即 MSS)</li> <li>之前所有包的 ACK 都已接收到</li></ul></li></ul> <h3 id="延迟确认"><a href="#延迟确认" class="header-anchor">#</a> 延迟确认</h3> <p>试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？
延迟确认(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。
不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:</p> <ul><li>接收到了大于一个 frame 的报文，且需要调整窗口大小</li> <li>TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置）</li> <li>发现了乱序包</li></ul> <h3 id="两者一起使用会怎样"><a href="#两者一起使用会怎样" class="header-anchor">#</a> 两者一起使用会怎样？</h3> <p>前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。</p> <h2 id="_012-如何理解-tcp-的-keep-alive"><a href="#_012-如何理解-tcp-的-keep-alive" class="header-anchor">#</a> 012. 如何理解 TCP 的 keep-alive？</h2> <p>大家都听说过 http 的keep-alive, 不过 TCP 层面也是有keep-alive机制，而且跟应用层不太一样。
试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。
这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。
在 Linux 下，可以这样查看相关的配置:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">sysctl</span> <span class="token parameter variable">-a</span> <span class="token operator">|</span> <span class="token function">grep</span> keepalive

// 每隔 <span class="token number">7200</span> s 检测一次
net.ipv4.tcp_keepalive_time <span class="token operator">=</span> <span class="token number">7200</span>
// 一次最多重传 <span class="token number">9</span> 个包
net.ipv4.tcp_keepalive_probes <span class="token operator">=</span> <span class="token number">9</span>
// 每个包的间隔重传间隔 <span class="token number">75</span> s
net.ipv4.tcp_keepalive_intvl <span class="token operator">=</span> <span class="token number">75</span>
</code></pre></div><p>不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么？</p> <p>站在应用的角度:</p> <ul><li>7200s 也就是两个小时检测一次，时间太长</li> <li>时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接</li></ul> <p>因此是一个比较尴尬的设计。</p> <p><font color="#ff502c">申明：此篇文章转载于</font><a href="https://juejin.im/post/6844904070889603085#heading-28" target="_blank" rel="noopener noreferrer">此处<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><font color="#ff502c">，如有侵权，请联系删除，谢谢！</font></p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_001-能不能说一说-tcp-和-udp-的区别" class="sidebar-link reco-side-_001-能不能说一说-tcp-和-udp-的区别" data-v-b57cc07c>001. 能不能说一说 TCP 和 UDP 的区别？</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_002-说说-tcp-三次握手的过程-为什么是三次而不是两次、四次" class="sidebar-link reco-side-_002-说说-tcp-三次握手的过程-为什么是三次而不是两次、四次" data-v-b57cc07c>002: 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#恋爱模拟" class="sidebar-link reco-side-恋爱模拟" data-v-b57cc07c>恋爱模拟</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#真实握手" class="sidebar-link reco-side-真实握手" data-v-b57cc07c>真实握手</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#为什么不是两次" class="sidebar-link reco-side-为什么不是两次" data-v-b57cc07c>为什么不是两次？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#为什么不是四次" class="sidebar-link reco-side-为什么不是四次" data-v-b57cc07c>为什么不是四次？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#同时打开会怎样" class="sidebar-link reco-side-同时打开会怎样" data-v-b57cc07c>同时打开会怎样？</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_003-说说-tcp-四次挥手的过程" class="sidebar-link reco-side-_003-说说-tcp-四次挥手的过程" data-v-b57cc07c>003: 说说 TCP 四次挥手的过程</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#过程拆解" class="sidebar-link reco-side-过程拆解" data-v-b57cc07c>过程拆解</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#等待2msl的意义" class="sidebar-link reco-side-等待2msl的意义" data-v-b57cc07c>等待2MSL的意义</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#同时关闭会怎样" class="sidebar-link reco-side-同时关闭会怎样" data-v-b57cc07c>同时关闭会怎样？</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_004-说说半连接队列和-syn-flood-攻击的关系" class="sidebar-link reco-side-_004-说说半连接队列和-syn-flood-攻击的关系" data-v-b57cc07c>004: 说说半连接队列和 SYN Flood 攻击的关系</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#半连接队列" class="sidebar-link reco-side-半连接队列" data-v-b57cc07c>半连接队列</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#全连接队列" class="sidebar-link reco-side-全连接队列" data-v-b57cc07c>全连接队列</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#syn-flood-攻击原理" class="sidebar-link reco-side-syn-flood-攻击原理" data-v-b57cc07c>SYN Flood 攻击原理</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#如何应对-syn-flood-攻击" class="sidebar-link reco-side-如何应对-syn-flood-攻击" data-v-b57cc07c>如何应对 SYN Flood 攻击？</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_005-介绍一下-tcp-报文头部的字段" class="sidebar-link reco-side-_005-介绍一下-tcp-报文头部的字段" data-v-b57cc07c>005: 介绍一下 TCP 报文头部的字段</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#序列号" class="sidebar-link reco-side-序列号" data-v-b57cc07c>序列号</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#isn" class="sidebar-link reco-side-isn" data-v-b57cc07c>ISN</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#确认号" class="sidebar-link reco-side-确认号" data-v-b57cc07c>确认号</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#标记位" class="sidebar-link reco-side-标记位" data-v-b57cc07c>标记位</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#窗口大小" class="sidebar-link reco-side-窗口大小" data-v-b57cc07c>窗口大小</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#校验和" class="sidebar-link reco-side-校验和" data-v-b57cc07c>校验和</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#可选项" class="sidebar-link reco-side-可选项" data-v-b57cc07c>可选项</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_006-说说-tcp-快速打开的原理-tfo" class="sidebar-link reco-side-_006-说说-tcp-快速打开的原理-tfo" data-v-b57cc07c>006: 说说 TCP 快速打开的原理(TFO)</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#tfo-流程" class="sidebar-link reco-side-tfo-流程" data-v-b57cc07c>TFO 流程</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_007-能不能说说tcp报文中时间戳的作用" class="sidebar-link reco-side-_007-能不能说说tcp报文中时间戳的作用" data-v-b57cc07c>007: 能不能说说TCP报文中时间戳的作用？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#计算往返时延-rtt" class="sidebar-link reco-side-计算往返时延-rtt" data-v-b57cc07c>计算往返时延 RTT</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#防止序列号回绕问题" class="sidebar-link reco-side-防止序列号回绕问题" data-v-b57cc07c>防止序列号回绕问题</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_008-tcp-的超时重传时间是如何计算的" class="sidebar-link reco-side-_008-tcp-的超时重传时间是如何计算的" data-v-b57cc07c>008: TCP 的超时重传时间是如何计算的？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#经典方法" class="sidebar-link reco-side-经典方法" data-v-b57cc07c>经典方法</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#标准方法" class="sidebar-link reco-side-标准方法" data-v-b57cc07c>标准方法</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_009-能不能说一说-tcp-的流量控制" class="sidebar-link reco-side-_009-能不能说一说-tcp-的流量控制" data-v-b57cc07c>009: 能不能说一说 TCP 的流量控制？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#tcp-滑动窗口" class="sidebar-link reco-side-tcp-滑动窗口" data-v-b57cc07c>TCP 滑动窗口</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#" class="sidebar-link reco-side-" data-v-b57cc07c></a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_010-能不能说说-tcp-的拥塞控制" class="sidebar-link reco-side-_010-能不能说说-tcp-的拥塞控制" data-v-b57cc07c>010: 能不能说说 TCP 的拥塞控制？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#拥塞窗口" class="sidebar-link reco-side-拥塞窗口" data-v-b57cc07c>拥塞窗口</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#慢启动" class="sidebar-link reco-side-慢启动" data-v-b57cc07c>慢启动</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#拥塞避免" class="sidebar-link reco-side-拥塞避免" data-v-b57cc07c>拥塞避免</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#快速重传和快速恢复" class="sidebar-link reco-side-快速重传和快速恢复" data-v-b57cc07c>快速重传和快速恢复</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_011-能不能说说-nagle-算法和延迟确认" class="sidebar-link reco-side-_011-能不能说说-nagle-算法和延迟确认" data-v-b57cc07c>011: 能不能说说 Nagle 算法和延迟确认？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#nagle-算法" class="sidebar-link reco-side-nagle-算法" data-v-b57cc07c>Nagle 算法</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#延迟确认" class="sidebar-link reco-side-延迟确认" data-v-b57cc07c>延迟确认</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#两者一起使用会怎样" class="sidebar-link reco-side-两者一起使用会怎样" data-v-b57cc07c>两者一起使用会怎样？</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/HTTP-02.html#_012-如何理解-tcp-的-keep-alive" class="sidebar-link reco-side-_012-如何理解-tcp-的-keep-alive" data-v-b57cc07c>012. 如何理解 TCP 的 keep-alive？</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/media/starsky.m4a" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:20px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/media/starsky.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/media/starsky.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>Star Sky</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>Two Steps From Hell</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/vuepress-blog/assets/js/app.5d9f3e6e.js" defer></script><script src="/vuepress-blog/assets/js/7.52cd3cfd.js" defer></script><script src="/vuepress-blog/assets/js/2.5e77f0d2.js" defer></script><script src="/vuepress-blog/assets/js/1.c3e4b76d.js" defer></script><script src="/vuepress-blog/assets/js/23.7f170fad.js" defer></script>
  </body>
</html>
