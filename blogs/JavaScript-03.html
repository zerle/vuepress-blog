<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原生JS灵魂之问(下篇) | 张垒的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="记录好的技术文档">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.3d11a1f1.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.d7c20d16.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/7.52cd3cfd.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.5e77f0d2.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/1.c3e4b76d.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/24.6e5b88ce.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.fce7151c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.665820a8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.93e60e41.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.06542fc4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.b75b2a2c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.d2f8beac.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.3dbe40f4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.a0f84501.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.8cf233fc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.dc553e85.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.3f0558f8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.c6cd4af0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.e8704ed0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.ea2f5a39.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.87921c42.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.f31d39ff.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.5c2c99a1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.eff7fee9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.b375e77b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.f9c89aba.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.82fe56b9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.c7707b2a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.86e919c8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.7648c433.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.0d04e6fc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.f85a8b69.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.a49efe7f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.98053ef4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.15d7a48b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.a1d0539b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.877bc118.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.8364ac82.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.0102712f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.fc0cf83d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.3165fae7.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.37997938.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.5cfca3d0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.d70d2f6c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/49.80d9cea6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.fb9624e5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/50.0c550db3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/51.95b61c9e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/52.7f08f076.js"><link rel="prefetch" href="/vuepress-blog/assets/js/53.2a888b74.js"><link rel="prefetch" href="/vuepress-blog/assets/js/54.b39c22d6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/55.bf49caf4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/56.c7500a61.js"><link rel="prefetch" href="/vuepress-blog/assets/js/57.af85ad1c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/58.b21e620f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/59.f774584a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.09f6a933.js"><link rel="prefetch" href="/vuepress-blog/assets/js/60.993a0809.js"><link rel="prefetch" href="/vuepress-blog/assets/js/61.07c3a9a6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/62.13e7ddc1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/63.2490424e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/64.45eaa646.js"><link rel="prefetch" href="/vuepress-blog/assets/js/65.7bbae9b3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/66.97ef0021.js"><link rel="prefetch" href="/vuepress-blog/assets/js/67.615bec9f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/68.e3587494.js"><link rel="prefetch" href="/vuepress-blog/assets/js/69.0e54693e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/70.017b9424.js"><link rel="prefetch" href="/vuepress-blog/assets/js/71.d7f6b53f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.0899600d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.1f42c771.js"><link rel="prefetch" href="/vuepress-blog/assets/js/vendors~docsearch.680926dd.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.3d11a1f1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>张垒的博客</h3> <p class="description" data-v-59e6cb88>记录好的技术文档</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">张垒的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/vuepress-blog/me.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>33</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>31</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/刷题/" class="nav-link"><i class="undefined"></i>
  刷题
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      zhang lei 的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/4495277269197975" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/zerle" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>原生JS灵魂之问(下篇)</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">原生JS灵魂之问(下篇)</h1> <div data-v-8a445198><!----> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2020/10/27</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>JavaScript</span></i></div></div> <div class="theme-reco-content content__default"><p>本次分享的主题是JS执行原理和深入异步，是一块比较系统且有深度的内容，相信对进阶的小伙伴是一个很大的提升。</p> <h2 id="第24篇-javascript内存机制之问-数据是如何存储的"><a href="#第24篇-javascript内存机制之问-数据是如何存储的" class="header-anchor">#</a> 第24篇: JavaScript内存机制之问——数据是如何存储的？</h2> <p>网上的资料基本是这样说的: 基本数据类型用栈存储，引用数据类型用堆存储。</p> <p>看起来没有错误，但实际上是有问题的。可以考虑一下闭包的情况，如果变量存在栈中，那函数调用完栈顶空间销毁，闭包变量不就没了吗？</p> <p>其实还是需要补充一句:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>闭包变量是存在堆内存中的。
</code></pre></div><p>具体而言，以下数据类型存储在栈中:</p> <ul><li>boolean</li> <li>null</li> <li>undefined</li> <li>number</li> <li>string</li> <li>symbol</li> <li>bigint</li></ul> <p>而所有的对象数据类型存放在堆中。
值得注意的是，对于赋值操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。
因此会有下面的情况:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a: <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> newObj <span class="token operator">=</span> obj<span class="token punctuation">;</span>
newObj.a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>obj.a<span class="token punctuation">)</span><span class="token punctuation">;</span>//变成了2
</code></pre></div><p>之所以会这样，是因为 obj 和 newObj 是同一份堆空间的地址，改变newObj，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。
当然，你可能会问: 为什么不全部用栈来保存呢？
首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> f<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> func<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  f<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

func<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程：</p> <p>1.调用func, 将 func 函数的上下文压栈，ESP指向栈顶。</p> <p>2.执行func，又调用f函数，将 f 函数的上下文压栈，ESP 指针上移。</p> <p>3.执行完 f 函数，将ESP 下移，f函数对应的栈顶空间被回收。</p> <p>4.执行完 func，ESP 下移，func对应的空间被回收。</p> <p>图示如下:</p> <p><img src="/vuepress-blog/assets/img/01.6cd2eed9.png" alt=""></p> <p>因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！</p> <p>不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销，下一篇就来分析一下堆内存到底是如何进行垃圾回收并进行优化的。</p> <h2 id="第25篇-v8-引擎如何进行垃圾内存的回收"><a href="#第25篇-v8-引擎如何进行垃圾内存的回收" class="header-anchor">#</a> 第25篇：V8 引擎如何进行垃圾内存的回收？</h2> <p>JS 语言不像 C/C++, 让程序员自己去开辟或者释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。作为一名资深的前端工程师，对于JS内存回收的机制是需要非常清楚, 以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习这其中的机制，也对我们深入理解JS的闭包特性、以及对内存的高效使用，都有很大的帮助。</p> <h3 id="v8-内存限制"><a href="#v8-内存限制" class="header-anchor">#</a> V8 内存限制</h3> <p>在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，在64位系统下，V8最多只能分配1.4G, 在 32 位系统中，最多只能分配0.7G。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。
我们知道对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。
上一篇我们提到过了，所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。
那么问题来了，V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？
究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。
首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>以 <span class="token number">1</span>.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式<span class="token punctuation">(</span>ps:后面会解释<span class="token punctuation">)</span>的垃圾回收甚至要 1s 以上。
</code></pre></div><p>可见其耗时之久，而且在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。
不过，如果你想调整这个内存的限制也不是不行。配置命令如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存
<span class="token function">node</span> --max-old-space-size<span class="token operator">=</span><span class="token number">2048</span> xxx.js 
</code></pre></div><p>或者</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 这是调整新生代这部分的内存，单位是 KB。
<span class="token function">node</span> --max-new-space-size<span class="token operator">=</span><span class="token number">2048</span> xxx.js
</code></pre></div><h3 id="新生代内存的回收"><a href="#新生代内存的回收" class="header-anchor">#</a> 新生代内存的回收</h3> <p>V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。</p> <p><img src="/vuepress-blog/assets/img/02.c20dfd57.png" alt=""></p> <p>根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。
首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。
那好了，新生代的垃圾回收是怎么做的呢？
首先将新生代内存空间一分为二:</p> <p><img src="/vuepress-blog/assets/img/03.973743ee.png" alt=""></p> <p>其中From部分表示正在使用的内存，To 是目前闲置的内存。
当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。
当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。
那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？
注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景:</p> <p><img src="/vuepress-blog/assets/img/04.a918b955.png" alt=""></p> <p>深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做内存碎片。刚刚介绍的新生代垃圾回收算法也叫Scavenge算法。
Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:</p> <p><img src="/vuepress-blog/assets/img/05.3aed8ce2.png" alt=""></p> <p>是不是整齐了许多？这样就大大方便了后续连续空间的分配。</p> <p>不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。</p> <h3 id="老生代内存的回收"><a href="#老生代内存的回收" class="header-anchor">#</a> 老生代内存的回收</h3> <p>刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。
发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:</p> <ul><li>已经经历过一次 Scavenge 回收。</li> <li>To（闲置）空间的内存占用超过25%。</li></ul> <p>现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用Scavenge算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？
那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？
第一步，进行标记-清除。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。
当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？
第二步，整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。</p> <p><img src="/vuepress-blog/assets/img/06.6b49e006.png" alt=""></p> <p>由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。</p> <h3 id="增量标记"><a href="#增量标记" class="header-anchor">#</a> 增量标记</h3> <p>由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就&quot;歇&quot;一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。
经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。
JS垃圾回收的原理就介绍到这里了，其实理解起来是非常简单的，重要的是理解它为什么要这么做，而不仅仅是如何做的，希望这篇总结能够对你有所启发。</p> <h2 id="第26篇-描述一下-v8-执行一段js代码的过程"><a href="#第26篇-描述一下-v8-执行一段js代码的过程" class="header-anchor">#</a> 第26篇: 描述一下 V8 执行一段JS代码的过程？</h2> <p>前端相对来说是一个比较新兴的领域，因此各种前端框架和工具层出不穷，让人眼花缭乱，尤其是各大厂商推出小程序之后各自制定标准，让前端开发的工作更加繁琐，在此背景下为了抹平平台之间的差异，诞生的各种编译工具/框架也数不胜数。但无论如何，想要赶上这些框架和工具的更新速度是非常难的，即使赶上了也很难产生自己的技术积淀，一个更好的方式便是学习那些本质的知识，抓住上层应用中不变的底层机制，这样我们便能轻松理解上层的框架而不仅仅是被动地使用，甚至能够在适当的场景下自己造出轮子，以满足开发效率的需求。
站在 V8 的角度，理解其中的执行机制，也能够帮助我们理解很多的上层应用，包括Babel、Eslint、前端框架的底层机制。那么，一段 JavaScript 代码放在 V8 当中究竟是如何执行的呢？
首先需要明白的是，机器是读不懂 JS 代码，机器只能理解特定的机器码，那如果要让 JS 的逻辑在机器上运行起来，就必须将 JS 的代码翻译成机器码，然后让机器识别。JS属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:</p> <ul><li>通过词法分析和语法分析生成 AST(抽象语法树)</li> <li>生成字节码</li></ul> <p>然后解释器根据字节码来执行程序。但 JS 整个执行的过程其实会比这个更加复杂，接下来就来一一地拆解。</p> <h3 id="_1-生成-ast"><a href="#_1-生成-ast" class="header-anchor">#</a> 1.生成 AST</h3> <p>生成 AST 分为两步——词法分析和语法分析。
词法分析即分词，它的工作就是将一行行的代码分解成一个个token。 比如下面一行代码:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> name <span class="token operator">=</span> <span class="token string">'sanyuan'</span>
</code></pre></div><p>其中会把句子分解成四个部分:</p> <p><img src="/vuepress-blog/assets/img/07.62ba0a8f.png" alt=""></p> <p>即解析成了四个token，这就是词法分析的作用。</p> <p>接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为AST。举个例子:</p> <p>最后生成的 AST 是这样的:</p> <p><img src="/vuepress-blog/assets/img/08.bf291833.png" alt=""></p> <p>当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。顺便补充一句，babel 的工作原理就是将 ES6 的代码解析生成ES6的AST，然后将 ES6 的 AST 转换为 ES5 的AST,最后才将 ES5 的 AST 转化为具体的 ES5 代码。由于本文着重阐述原理，关于 babel 编译的细节就不展开了，推荐大家去读一读荒山的<a href="https://juejin.im/post/6844903956905197576?_blank" target="_blank" rel="noopener noreferrer">babel文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, 帮你打开新世界的大门: )
回到 V8 本身，生成 AST 后，接下来会生成执行上下文，关于执行上下文，可以参考上上篇《JavaScript内存机制之问——数据是如何存储的？》中对于上下文压栈出栈过程的讲解。</p> <h3 id="_2-生成字节码"><a href="#_2-生成字节码" class="header-anchor">#</a> 2. 生成字节码</h3> <p>开头就已经提到过了，生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是字节码并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 AST 转换成机器码不就得了，让机器直接执行。确实，在 V8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。
给一张对比图让大家直观地感受以下三者代码量的差异:</p> <p><img src="/vuepress-blog/assets/img/09.f1496dd1.png" alt=""></p> <p>很容易得出，字节码是比机器码轻量得多的代码。那 V8 为什么要使用字节码，字节码到底是个什么东西？</p> <div class="language-bash extra-class"><pre class="language-bash"><code>字节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。
</code></pre></div><p>字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。</p> <ol start="3"><li>执行代码
接下来，就进入到字节码解释执行的阶段啦！
在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做热点代码(HotSpot)，然后将这么代码编译成机器码保存起来，这个用来编译的工具就是V8的编译器(也叫做TurboFan)
, 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。
其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的
根本区别在于前者会编译生成二进制文件但后者不会。
并且，这种字节码跟编译器和解释器结合的技术，我们称之为即时编译, 也就是我们经常听到的JIT。
这就是 V8 中执行一段JS代码的整个过程，梳理一下:</li></ol> <ul><li>1.首先通过词法分析和语法分析生成 AST</li> <li>2.将 AST 转换为字节码</li> <li>3.由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率</li></ul> <p>关于这个问题的拆解就到这里，希望对你有所启发。</p> <h2 id="第28篇-如何理解eventloop-宏任务和微任务篇"><a href="#第28篇-如何理解eventloop-宏任务和微任务篇" class="header-anchor">#</a> 第28篇：如何理解EventLoop——宏任务和微任务篇</h2> <h3 id="宏任务-macrotask-引入"><a href="#宏任务-macrotask-引入" class="header-anchor">#</a> 宏任务(MacroTask)引入</h3> <p>在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:</p> <ul><li>1.渲染事件</li> <li>2.用户交互事件</li> <li>3.js脚本执行</li> <li>4.网络请求、文件读写完成事件等等。</li></ul> <p>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种队列的方式来存储这些任务，
即先进来的先执行。模拟如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>bool keep_running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
void <span class="token function-name function">MainTherad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  for<span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    //执行队列中的任务
    Task task <span class="token operator">=</span> task_queue.takeTask<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ProcessTask<span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    //执行延迟队列中的任务
    ProcessDelayTask<span class="token punctuation">(</span><span class="token punctuation">)</span>

    if<span class="token punctuation">(</span><span class="token operator">!</span>keep_running<span class="token punctuation">)</span> //如果设置了退出标志，那么直接退出线程循环
        <span class="token builtin class-name">break</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里用到了一个 for 循环，将队列中的任务一一取出，然后执行，这个很好理解。但是其中包含了两种任务队列，除了上述提到的任务队列， 还有一个延迟队列，它专门处理诸如setTimeout/setInterval这样的定时器回调任务。
上述提到的，普通任务队列和延迟队列中的任务，都属于宏任务。</p> <h3 id="微任务-microtask-引入"><a href="#微任务-microtask-引入" class="header-anchor">#</a> 微任务(MicroTask)引入</h3> <p>对于每个宏任务而言，其内部都有一个微任务队列。那为什么要引入微任务？微任务在什么时候执行呢？
其实引入微任务的初衷是为了解决异步回调的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:</p> <p>将异步回调进行宏任务队列的入队操作。
将异步回调放到当前宏任务的末尾。</p> <p>如果采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。
为了规避这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。
常见的微任务有MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程。
Ok, 这便是宏任务和微任务的概念，接下来正式介绍JS非常重要的运行机制——EventLoop。</p> <h2 id="第29篇-如何理解eventloop-浏览器篇"><a href="#第29篇-如何理解eventloop-浏览器篇" class="header-anchor">#</a> 第29篇: 如何理解EventLoop——浏览器篇</h2> <p>干讲理论不容易理解，让我们直接以一个例子开始吧:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>console.log<span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise.resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>.then<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">'resolve'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们来分析一下:</p> <ul><li>1.刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈(关于执行栈，若不了解请移步之前的文章《JavaScript内存机制之问——数据是如何存储的？》)进行执行，因此先打印start和end</li> <li>2.setTimeout 作为一个宏任务放入宏任务队列</li> <li>3.Promise.then作为一个为微任务放入到微任务队列</li> <li>4.当本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行</li> <li>5.接下来进入到下一个宏任务——setTimeout, 执行</li></ul> <p>因此最后的顺序是:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>start
end
resolve
<span class="token function">timeout</span>
</code></pre></div><p>这样就带大家直观地感受到了浏览器环境下 EventLoop 的执行流程。不过，这只是其中的一部分情况，接下来我们来做一个更完整的总结。</p> <p>一开始整段脚本作为第一个宏任务执行
执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空
执行浏览器 UI 线程的渲染工作
检查是否有Web worker任务，有则执行
执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</p> <p>最后给大家留一道题目练习:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Promise.resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>.then<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">'Promise1'</span><span class="token punctuation">)</span>  
  setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
    console.log<span class="token punctuation">(</span><span class="token string">'setTimeout2'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>,0<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">'setTimeout1'</span><span class="token punctuation">)</span>
  Promise.resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>.then<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
    console.log<span class="token punctuation">(</span><span class="token string">'Promise2'</span><span class="token punctuation">)</span>    
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>,0<span class="token punctuation">)</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

// start
// Promise1
// setTimeout1
// Promise2
// setTimeout2
</code></pre></div><h2 id="第30篇-如何理解eventloop-nodejs篇"><a href="#第30篇-如何理解eventloop-nodejs篇" class="header-anchor">#</a> 第30篇: 如何理解EventLoop——nodejs篇</h2> <p>nodejs 和 浏览器的 eventLoop 还是有很大差别的，值得单独拿出来说一说。</p> <p>不知你是否看过关于 nodejs 中 eventLoop 的一些文章, 是否被这些流程图搞得眼花缭乱、一头雾水:</p> <p><img src="/vuepress-blog/assets/img/10.bcffc866.png" alt=""></p> <p>看到这你不用紧张，这里会抛开这些晦涩的流程图，以最清晰浅显的方式来一步步拆解 nodejs 的事件循环机制。</p> <h3 id="_1-三大关键阶段"><a href="#_1-三大关键阶段" class="header-anchor">#</a> 1. 三大关键阶段</h3> <p>首先，梳理一下 nodejs 三个非常重要的执行阶段:</p> <p>1.执行 定时器回调 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它timer。</p> <p>2.轮询(英文叫poll)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过'data'、</p> <p>'connect'等事件使得事件循环到达 poll 阶段。到达了这个阶段后:
如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。
如果没有定时器, 会去看回调函数队列。</p> <ul><li><p>如果队列不为空，拿出队列中的方法依次执行</p></li> <li><p>如果队列为空，检查是否有 setImmdiate 的回调</p> <ul><li>有则前往check阶段(下面会说)</li> <li>没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。</li></ul></li></ul> <p>3.check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p> <p>这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善。</p> <h3 id="_2-完善"><a href="#_2-完善" class="header-anchor">#</a> 2. 完善</h3> <p>首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。
并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()，
'close' 事件的回调就会在这个阶段执行。
梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:</p> <ul><li>1.timer 阶段</li> <li>2.I/O 异常回调阶段</li> <li>3.空闲、预备状态(第2阶段结束，poll 未触发之前)</li> <li>4.poll 阶段</li> <li>5.check 阶段</li> <li>6.关闭事件的回调阶段</li></ul> <p>是不是清晰了许多？</p> <h3 id="_3-实例演示"><a href="#_3-实例演示" class="header-anchor">#</a> 3. 实例演示</h3> <p>好，我们以上次的练习题来实践一把:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
    console.log<span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>
    Promise.resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span><span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console.log<span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>, <span class="token number">0</span><span class="token punctuation">)</span>
setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
    console.log<span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span>
    Promise.resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span><span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console.log<span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>, <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><p>这里我要说，node版本 &gt;= 11和在 11 以下的会有不同的表现。</p> <p>首先说 node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>timer1
promise1
time2
promise2
</code></pre></div><p>而 node 版本小于 11 的情况下，对于定时器的处理是:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务
</code></pre></div><p>因此会打印出这样的结果:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>timer1
timer2
promise1
promise2
</code></pre></div><h3 id="_4-nodejs-和-浏览器关于eventloop的主要区别"><a href="#_4-nodejs-和-浏览器关于eventloop的主要区别" class="header-anchor">#</a> 4.nodejs 和 浏览器关于eventLoop的主要区别</h3> <p>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</p> <h3 id="_5-关于process-nexttick的一点说明"><a href="#_5-关于process-nexttick的一点说明" class="header-anchor">#</a> 5.关于process.nextTick的一点说明</h3> <p>process.nextTick 是一个独立于 eventLoop 的任务队列。
在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。</p> <h2 id="第31篇-nodejs中的异步、非阻塞i-o是如何实现的"><a href="#第31篇-nodejs中的异步、非阻塞i-o是如何实现的" class="header-anchor">#</a> 第31篇: nodejs中的异步、非阻塞I/O是如何实现的？</h2> <p>在听到 nodejs 相关的特性时，经常会对 异步I/O、非阻塞I/O有所耳闻，听起来好像是差不多的意思，但其实是两码事，下面我们就以原理的角度来剖析一下对 nodejs 来说，这两种技术底层是如何实现的？</p> <h3 id="什么是i-o"><a href="#什么是i-o" class="header-anchor">#</a> 什么是I/O？</h3> <p>首先，我想有必要把 I/O 的概念解释一下。I/O 即Input/Output, 输入和输出的意思。在浏览器端，只有一种 I/O，那就是利用 Ajax 发送网络请求，然后读取返回的内容，这属于网络I/O。回到 nodejs 中，其实这种的 I/O 的场景就更加广泛了，主要分为两种:</p> <ul><li>文件 I/O。比如用 fs 模块对文件进行读写操作。</li> <li>网络 I/O。比如 http 模块发起网络请求。</li></ul> <h3 id="阻塞和非阻塞i-o"><a href="#阻塞和非阻塞i-o" class="header-anchor">#</a> 阻塞和非阻塞I/O</h3> <p>阻塞和非阻塞 I/O 其实是针对操作系统内核而言的，而不是 nodejs 本身。阻塞 I/O 的特点就是一定要等到操作系统完成所有操作后才表示调用结束，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。
对前者而言，在操作系统进行 I/O 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了。那如果换成非阻塞I/O，调用返回后我们的 nodejs 应用程序可以完成其他的事情，而操作系统同时也在进行 I/O。这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，nodejs 应用程序怎么知道操作系统已经完成了 I/O 操作呢？
为了让 nodejs 知道操作系统已经做完 I/O 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是轮询。对于轮询而言，有以下这么几种方案:</p> <ul><li><p>1.一直轮询检查I/O状态，直到 I/O 完成。这是最原始的方式，也是性能最低的，会让 CPU 一直耗用在等待上面。其实跟阻塞 I/O 的效果是一样的。</p></li> <li><p>2.遍历文件描述符(即 文件I/O 时操作系统和 nodejs 之间的文件凭证)的方式来确定 I/O 是否完成，I/O完成则文件描述符的状态改变。但 CPU 轮询消耗还是很大。</p></li> <li><p>3.epoll模式。即在进入轮询的时候如果I/O未完成CPU就休眠，完成之后唤醒CPU。</p></li></ul> <p>总之，CPU要么重复检查I/O，要么重复检查文件描述符，要么休眠，都得不到很好的利用，我们希望的是:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>nodejs 应用程序发起 I/O 调用后可以直接去执行别的逻辑，操作系统默默地做完 I/O 之后给 nodejs 发一个完成信号，nodejs 执行回调操作。
</code></pre></div><p>这是理想的情况，也是异步 I/O 的效果，那如何实现这样的效果呢？</p> <h3 id="异步-i-o-的本质"><a href="#异步-i-o-的本质" class="header-anchor">#</a> 异步 I/O 的本质</h3> <p>Linux 原生存在这样的一种方式，即(AIO), 但两个致命的缺陷:</p> <p>只有 Linux 下存在，在其他系统中没有异步 I/O 支持。
无法利用系统缓存。</p> <h4 id="nodejs中的异步-i-o-方案"><a href="#nodejs中的异步-i-o-方案" class="header-anchor">#</a> nodejs中的异步 I/O 方案</h4> <p>是不是没有办法了呢？在单线程的情况下确实是这样，但是如果把思路放开一点，利用多线程来考虑这个问题，就变得轻松多了。我们可以让一个进程进行计算操作，另外一些进行 I/O 调用，I/O 完成后把信号传给计算的线程，进而执行回调，这不就好了吗？没错，异步 I/O 就是使用这样的线程池来实现的。
只不过在不同的系统下面表现会有所差异，在 Linux 下可以直接使用线程池来完成，在Window系统下则采用 IOCP 这个系统API(其内部还是用线程池完成的)。
有了操作系统的支持，那 nodejs 如何来对接这些操作系统从而实现异步 I/O 呢？
以文件为 I/O 我们以一段代码为例:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> fs <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs.readFile<span class="token punctuation">(</span><span class="token string">'/test.txt'</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console.log<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="执行流程"><a href="#执行流程" class="header-anchor">#</a> 执行流程</h4> <p>执行代码的过程中大概发生了这些事情:</p> <p>首先，fs.readFile调用Node的核心模块fs.js ；
接下来，Node的核心模块调用内建模块node_file.cc，创建对应的文件I/O观察者对象(这个对象后面有大用！) ；
最后，根据不同平台（Linux或者window），内建模块通过libuv中间层进行系统调用</p> <p><img src="/vuepress-blog/assets/img/11.4aaa1012.png" alt=""></p> <h4 id=""><a href="#" class="header-anchor">#</a></h4> <p>libuv调用过程拆解
重点来了！libuv 中是如何来进行进行系统调用的呢？也就是 uv_fs_open() 中做了些什么？</p> <h5 id="_1-创建请求对象"><a href="#_1-创建请求对象" class="header-anchor">#</a> 1. 创建请求对象</h5> <p>以Windows系统为例来说，在这个函数的调用过程中，我们创建了一个文件I/O的请求对象，并往里面注入了回调函数。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>req_wrap-<span class="token operator">&gt;</span>object_-<span class="token operator">&gt;</span>Set<span class="token punctuation">(</span>oncomplete_sym, callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>req_wrap 便是这个请求对象，req_wrap 中 object_ 的 oncomplete_sym 属性对应的值便是我们 nodejs 应用程序代码中传入的回调函数。</p> <h5 id="_2-推入线程池-调用返回"><a href="#_2-推入线程池-调用返回" class="header-anchor">#</a> 2. 推入线程池，调用返回</h5> <p>在这个对象包装完成后，QueueUserWorkItem() 方法将这个对象推进线程池中等待执行。
好，至此现在js的调用就直接返回了，我们的 js 应用程序代码可以继续往下执行，当然，当前的 I/O 操作同时也在线程池中将被执行，这不就完成了异步么：）
等等，别高兴太早，回调都还没执行呢！接下来便是执行回调通知的环节。</p> <h5 id="_3-回调通知"><a href="#_3-回调通知" class="header-anchor">#</a> 3. 回调通知</h5> <p>事实上现在线程池中的 I/O 无论是阻塞还是非阻塞都已经无所谓了，因为异步的目的已经达成。重要的是 I/O 完成后会发生什么。
在介绍后续的故事之前，给大家介绍两个重要的方法: GetQueuedCompletionStatus 和 PostQueuedCompletionStatus。</p> <ul><li><p>1.还记得之前讲过的 eventLoop 吗？在每一个Tick当中会调用GetQueuedCompletionStatus检查线程池中是否有执行完的请求，如果有则表示时机已经成熟，可以执行回调了。</p></li> <li><p>2.PostQueuedCompletionStatus方法则是向 IOCP 提交状态，告诉它当前I/O完成了。</p></li></ul> <p>名字比较长，先介绍是为了让大家混个脸熟，至少后面出来不会感到太突兀：）
我们言归正传，把后面的过程串联起来。
当对应线程中的 I/O 完成后，会将获得的结果存储起来，保存到相应的请求对象中，然后调用PostQueuedCompletionStatus()向 IOCP 提交执行完成的状态，并且将线程还给操作系统。一旦 EventLoop 的轮询操作中，调用GetQueuedCompletionStatus检测到了完成的状态，就会把请求对象塞给I/O观察者(之前埋下伏笔，如今终于闪亮登场)。</p> <ul><li><p>1.I/O 观察者现在的行为就是取出请求对象的存储结果，同时也取出它的oncomplete_sym属性，即回调函数(不懂这个属性的回看第1步的操作)。将前者作为函数参数传入后者，并执行后者。
这里，回调函数就成功执行啦！
总结 :</p></li> <li><p>2.阻塞和非阻塞 I/O 其实是针对操作系统内核而言的。阻塞 I/O 的特点就是一定要等到操作系统完成所有操作后才表示调用结束，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。
nodejs中的异步 I/O 采用多线程的方式，由 EventLoop、I/O 观察者，请求对象、线程池四大要素相互配合，共同实现。</p></li></ul> <h2 id="第32篇-js异步编程有哪些方案-为什么会出现这些方案"><a href="#第32篇-js异步编程有哪些方案-为什么会出现这些方案" class="header-anchor">#</a> 第32篇：JS异步编程有哪些方案？为什么会出现这些方案？</h2> <p>关于 JS 单线程、EventLoop 以及异步 I/O 这些底层的特性，我们之前做过了详细的拆解，不在赘述。在探究了底层机制之后，我们还需要对代码的组织方式有所理解，这是离我们最日常开发最接近的部分，异步代码的组织方式直接决定了开发和维护的效率，其重要性也不可小觑。尽管底层机制没变，但异步代码的组织方式却随着 ES 标准的发展，一步步发生了巨大的变革。接着让我们来一探究竟吧！</p> <h3 id="回调函数时代"><a href="#回调函数时代" class="header-anchor">#</a> 回调函数时代</h3> <p>相信很多 nodejs 的初学者都或多或少踩过这样的坑，node 中很多原生的 api 就是诸如这样的:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>fs.readFile<span class="token punctuation">(</span><span class="token string">'xxx'</span>, <span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>典型的高阶函数，将回调函数作为函数参数传给了readFile。但久而久之，就会发现，这种传入回调的方式也存在大坑, 比如下面这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>fs.readFile<span class="token punctuation">(</span><span class="token string">'1.json'</span>, <span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    fs.readFile<span class="token punctuation">(</span><span class="token string">'2.json'</span>, <span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        fs.readFile<span class="token punctuation">(</span><span class="token string">'3.json'</span>, <span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
            fs.readFile<span class="token punctuation">(</span><span class="token string">'4.json'</span>, <span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>

            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>回调当中嵌套回调，也称回调地狱。这种代码的可读性和可维护性都是非常差的，因为嵌套的层级太多。而且还有一个严重的问题，就是每次任务可能会失败，需要在回调里面对每个任务的失败情况进行处理，增加了代码的混乱程度。</p> <h3 id="promise-时代"><a href="#promise-时代" class="header-anchor">#</a> Promise 时代</h3> <p>ES6 中新增的 Promise 就很好了解决了回调地狱的问题，同时了合并了错误处理。写出来的代码类似于下面这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>readFilePromise<span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'2.json'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'3.json'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'4.json'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>以链式调用的方式避免了大量的嵌套，也符合人的线性思维方式，大大方便了异步编程。</p> <h3 id="co-generator-方式"><a href="#co-generator-方式" class="header-anchor">#</a> co + Generator 方式</h3> <p>利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>co<span class="token punctuation">(</span>function* <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const r1 <span class="token operator">=</span> yield readFilePromise<span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  const r2 <span class="token operator">=</span> yield readFilePromise<span class="token punctuation">(</span><span class="token string">'2.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  const r3 <span class="token operator">=</span> yield readFilePromise<span class="token punctuation">(</span><span class="token string">'3.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  const r4 <span class="token operator">=</span> yield readFilePromise<span class="token punctuation">(</span><span class="token string">'4.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这四种经典的异步编程方式就简单回顾完了，由于是鸟瞰大局，我觉得知道是什么比了解细节要重要, 因此也没有展开。不过没关系，接下来，让我们针对这些具体的解决方案，一步步深入异步编程，理解其中的本质。</p> <h2 id="第33篇-能不能简单实现一下-node-中回调函数的机制"><a href="#第33篇-能不能简单实现一下-node-中回调函数的机制" class="header-anchor">#</a> 第33篇: 能不能简单实现一下 node 中回调函数的机制？</h2> <p>回调函数的方式其实内部利用了发布-订阅模式，在这里我们以模拟实现 node 中的 Event 模块为例来写实现回调函数的机制。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> <span class="token function-name function">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this.events <span class="token operator">=</span> new Map<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个 EventEmitter 一共需要实现这些方法: addListener, removeListener, once, removeAllListener, emit。</p> <p>首先是addListener：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// once 参数表示是否只是触发一次
const wrapCallback <span class="token operator">=</span> <span class="token punctuation">(</span>fn, once <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> callback: fn, once <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

EventEmitter.prototype.addListener <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type, fn, once <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> handler <span class="token operator">=</span> this.events.get<span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    // 为 <span class="token builtin class-name">type</span> 事件绑定回调
    this.events.set<span class="token punctuation">(</span>type, wrapCallback<span class="token punctuation">(</span>fn, once<span class="token punctuation">))</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>handler <span class="token operator">&amp;&amp;</span> typeof handler.callback <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    // 目前 <span class="token builtin class-name">type</span> 事件只有一个回调
    this.events.set<span class="token punctuation">(</span>type, <span class="token punctuation">[</span>handler, wrapCallback<span class="token punctuation">(</span>fn, once<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    // 目前 <span class="token builtin class-name">type</span> 事件回调数 <span class="token operator">&gt;=</span> <span class="token number">2</span>
    handler.push<span class="token punctuation">(</span>wrapCallback<span class="token punctuation">(</span>fn, once<span class="token punctuation">))</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>removeLisener 的实现如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>EventEmitter.prototype.removeListener <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type, listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> handler <span class="token operator">=</span> this.events.get<span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handler<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array.isArray<span class="token punctuation">(</span>handler<span class="token punctuation">))</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handler.callback <span class="token operator">==</span><span class="token operator">=</span> listener.callback<span class="token punctuation">)</span> this.events.delete<span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> handler.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> item <span class="token operator">=</span> handler<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>item.callback <span class="token operator">==</span><span class="token operator">=</span> listener.callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      // 删除该回调，注意数组塌陷的问题，即后面的元素会往前挪一位。i 要 -- 
      handler.splice<span class="token punctuation">(</span>i, <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      i--<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>handler.length <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        // 长度为 <span class="token number">1</span> 就不用数组存了
        this.events.set<span class="token punctuation">(</span>type, handler<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>once 实现思路很简单，先调用 addListener 添加上了once标记的回调对象, 然后在 emit 的时候遍历回调列表，将标记了once: true的项remove掉即可。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>EventEmitter.prototype.once <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type, fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this.addListener<span class="token punctuation">(</span>type, fn, <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

EventEmitter.prototype.emit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type, <span class="token punctuation">..</span>.args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> handler <span class="token operator">=</span> this.events.get<span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handler<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>handler<span class="token punctuation">))</span> <span class="token punctuation">{</span>
    // 遍历列表，执行回调
    handler.map<span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      item.callback.apply<span class="token punctuation">(</span>this, args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      // 标记的 once: <span class="token boolean">true</span> 的项直接移除
      <span class="token keyword">if</span> <span class="token punctuation">(</span>item.once<span class="token punctuation">)</span> this.removeListener<span class="token punctuation">(</span>type, item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    // 只有一个回调则直接执行
    handler.callback.apply<span class="token punctuation">(</span>this, args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后是 removeAllListener：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>EventEmitter.prototype.removeAllListener <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> handler <span class="token operator">=</span> this.events.get<span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handler<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> this.events.delete<span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们测试一下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> e <span class="token operator">=</span> new EventEmitter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
e.addListener<span class="token punctuation">(</span><span class="token string">'type'</span>, <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;type事件触发！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
e.addListener<span class="token punctuation">(</span><span class="token string">'type'</span>, <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;WOW!type事件又触发了！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function-name function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console.log<span class="token punctuation">(</span><span class="token string">&quot;type事件我只触发一次&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
e.once<span class="token punctuation">(</span><span class="token string">'type'</span>, f<span class="token punctuation">)</span>
e.emit<span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
e.emit<span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
e.removeAllListener<span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
e.emit<span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

// type事件触发！
// WOW<span class="token operator">!</span>type事件又触发了！
// type事件我只触发一次
// type事件触发！
// WOW<span class="token operator">!</span>type事件又触发了！
</code></pre></div><p>OK，一个简易的 Event 就这样实现完成了，为什么说它简易呢？因为还有很多细节的部分没有考虑:</p> <ul><li>1.在参数少的情况下，call 的性能优于 apply，反之 apply 的性能更好。因此在执行回调时候可以根据情况调用 call 或者 apply。</li> <li>2.考虑到内存容量，应该设置回调列表的最大值，当超过最大值的时候，应该选择部分回调进行删除操作。</li> <li>3.鲁棒性有待提高。对于参数的校验很多地方直接忽略掉了。</li></ul> <p>不过，这个案例的目的只是带大家掌握核心的原理，如果在这里洋洋洒洒写三四百行意义也不大，有兴趣的可以去看看Node中<a href="https://github.com/browserify/events/blob/master/events.js?_blank" target="_blank" rel="noopener noreferrer">Event 模块<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的源码，里面对各种细节和边界情况做了详细的处理。</p> <h2 id="第34篇-promise之问-一-promise-凭借什么消灭了回调地狱"><a href="#第34篇-promise之问-一-promise-凭借什么消灭了回调地狱" class="header-anchor">#</a> 第34篇: Promise之问(一)——Promise 凭借什么消灭了回调地狱？</h2> <h3 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h3> <p>首先，什么是回调地狱:</p> <p>1.多层嵌套的问题。
2.每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</p> <p>这两种问题在回调函数时代尤为突出。Promise 的诞生就是为了解决这两个问题。</p> <h3 id="解决方法"><a href="#解决方法" class="header-anchor">#</a> 解决方法</h3> <p>Promise 利用了三大技术手段来解决回调地狱:</p> <ul><li>回调函数延迟绑定。</li> <li>返回值穿透。</li> <li>错误冒泡。</li></ul> <p>首先来举个例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> readFilePromise <span class="token operator">=</span> <span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  fs.readFile<span class="token punctuation">(</span>filename, <span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    if<span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      reject<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>else <span class="token punctuation">{</span>
      resolve<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
readFilePromise<span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'2.json'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>看到没有，回调函数不是直接声明的，而是在通过后面的 then 方法传入的，即延迟传入。这就是<font color="#ff502c">回调函数延迟绑定</font>。</p> <p>然后我们做以下微调:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> x <span class="token operator">=</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'2.json'</span><span class="token punctuation">)</span>//这是返回的Promise
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
x.then<span class="token punctuation">(</span>/* 内部逻辑省略 */<span class="token punctuation">)</span>
</code></pre></div><p>我们会根据 then 中回调函数的传入值创建不同类型的Promise, 然后把返回的 Promise 穿透到外层, 以供后续的调用。这里的 x 指的就是内部返回的 Promise，然后在 x 后面可以依次完成链式调用。
这便是<font color="#ff502c">返回值穿透</font>的效果。
这两种技术一起作用便可以将深层的嵌套回调写成下面的形式:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>readFilePromise<span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'2.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'3.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'4.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样就显得清爽了许多，更重要的是，它更符合人的线性思维模式，开发体验也更好。
两种技术结合产生了链式调用的效果。
这解决的是多层嵌套的问题，那另一个问题，即每次任务执行结束后分别处理成功和失败的情况怎么解决的呢？
Promise 采用了错误冒泡的方式。其实很简单理解，我们来看看效果:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>readFilePromise<span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'2.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'3.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'4.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.catch<span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  // xxx
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这样前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。</p> <p>解决效果</p> <ul><li>1.实现链式调用，解决多层嵌套问题</li> <li>2.实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题</li></ul> <h2 id="第35篇-promise之问-二-为什么promise要引入微任务"><a href="#第35篇-promise之问-二-为什么promise要引入微任务" class="header-anchor">#</a> 第35篇: Promise之问(二)——为什么Promise要引入微任务？</h2> <p>在这里，如果你还没有接触过 Promise, 务必去看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">MDN 文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，了解使用方式，不然后面很会懵。
Promise 中的执行函数是同步进行的，但是里面存在着异步操作，在异步操作结束后会调用 resolve 方法，或者中途遇到错误调用 reject 方法，这两者都是作为微任务进入到 EventLoop 中。但是你有没有想过，Promise 为什么要引入微任务的方式来进行回调操作？</p> <h3 id="解决方式"><a href="#解决方式" class="header-anchor">#</a> 解决方式</h3> <p>回到问题本身，其实就是如何处理回调的问题。总结起来有三种方式:</p> <ul><li>1.使用同步回调，直到异步任务进行完，再进行后面的任务。</li> <li>2.使用异步回调，将回调函数放在进行宏任务队列的队尾。</li> <li>3.使用异步回调，将回调函数放到当前宏任务中的最后面。</li></ul> <h3 id="优劣对比"><a href="#优劣对比" class="header-anchor">#</a> 优劣对比</h3> <p>第一种方式显然不可取，因为同步的问题非常明显，会让整个脚本阻塞住，当前任务等待，后面的任务都无法得到执行，而这部分等待的时间是可以拿来完成其他事情的，导致 CPU 的利用率非常低，而且还有另外一个致命的问题，就是无法实现延迟绑定的效果。
如果采用第二种方式，那么执行回调(resolve/reject)的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。
为了解决上述方案的问题，另外也考虑到延迟绑定的需求，Promise 采取第三种方式, 即引入微任务, 即把 resolve(reject) 回调的执行放在当前宏任务的末尾。
这样，利用微任务解决了两大痛点:</p> <ul><li><p>1.采用异步回调替代同步回调解决了浪费 CPU 性能的问题。</p></li> <li><p>2.放到当前宏任务最后执行，解决了回调执行的实时性问题。</p></li></ul> <p>好，Promise 的基本实现思想已经讲清楚了，相信大家已经知道了它为什么这么设计，接下来就让我们一步步弄清楚它内部到底是怎么设计的。</p> <h2 id="第36篇-promise之问-三-promise-如何实现链式调用"><a href="#第36篇-promise之问-三-promise-如何实现链式调用" class="header-anchor">#</a> 第36篇: Promise之问(三)——Promise 如何实现链式调用？</h2> <p>从现在开始，我们就来动手实现一个功能完整的Promise，一步步深挖其中的细节。我们先从链式调用开始。</p> <h3 id="简易版实现"><a href="#简易版实现" class="header-anchor">#</a> 简易版实现</h3> <p>首先写出第一版的代码:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>//定义三种状态
const PENDING <span class="token operator">=</span> <span class="token string">&quot;pending&quot;</span><span class="token punctuation">;</span>
const FULFILLED <span class="token operator">=</span> <span class="token string">&quot;fulfilled&quot;</span><span class="token punctuation">;</span>
const REJECTED <span class="token operator">=</span> <span class="token string">&quot;rejected&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> MyPromise<span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> self <span class="token operator">=</span> this<span class="token punctuation">;</span> // 缓存当前promise实例
  self.value <span class="token operator">=</span> null<span class="token punctuation">;</span>
  self.error <span class="token operator">=</span> null<span class="token punctuation">;</span> 
  self.status <span class="token operator">=</span> PENDING<span class="token punctuation">;</span>
  self.onFulfilled <span class="token operator">=</span> null<span class="token punctuation">;</span> //成功的回调函数
  self.onRejected <span class="token operator">=</span> null<span class="token punctuation">;</span> //失败的回调函数

  const resolve <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    if<span class="token punctuation">(</span>self.status <span class="token operator">!=</span><span class="token operator">=</span> PENDING<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      self.status <span class="token operator">=</span> FULFILLED<span class="token punctuation">;</span>
      self.value <span class="token operator">=</span> value<span class="token punctuation">;</span>
      self.onFulfilled<span class="token punctuation">(</span>self.value<span class="token punctuation">)</span><span class="token punctuation">;</span>//resolve时执行成功回调
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  const reject <span class="token operator">=</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    if<span class="token punctuation">(</span>self.status <span class="token operator">!=</span><span class="token operator">=</span> PENDING<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      self.status <span class="token operator">=</span> REJECTED<span class="token punctuation">;</span>
      self.error <span class="token operator">=</span> error<span class="token punctuation">;</span>
      self.onRejected<span class="token punctuation">(</span>self.error<span class="token punctuation">)</span><span class="token punctuation">;</span>//resolve时执行成功回调
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  executor<span class="token punctuation">(</span>resolve, reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
MyPromise.prototype.then <span class="token operator">=</span> function<span class="token punctuation">(</span>onFulfilled, onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>this.status <span class="token operator">==</span><span class="token operator">=</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.onFulfilled <span class="token operator">=</span> onFulfilled<span class="token punctuation">;</span>
    this.onRejected <span class="token operator">=</span> onRejected<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>this.status <span class="token operator">==</span><span class="token operator">=</span> FULFILLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    //如果状态是fulfilled，直接执行成功回调，并将成功值传入
    onFulfilled<span class="token punctuation">(</span>this.value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    //如果状态是rejected，直接执行失败回调，并将失败原因传入
    onRejected<span class="token punctuation">(</span>this.error<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> this<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，Promise 的本质是一个有限状态机，存在三种状态:</p> <ul><li>PENDING(等待)</li> <li>FULFILLED(成功)</li> <li>REJECTED(失败)
状态改变规则如下图:</li></ul> <p><img src="/vuepress-blog/assets/img/12.6f0af233.png" alt=""></p> <p>对于 Promise 而言，状态的改变不可逆，即由等待态变为其他的状态后，就无法再改变了。</p> <p>不过，回到目前这一版的 Promise, 还是存在一些问题的。</p> <h3 id="设置回调数组"><a href="#设置回调数组" class="header-anchor">#</a> 设置回调数组</h3> <p>首先只能执行一个回调函数，对于多个回调的绑定就无能为力，比如下面这样:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> promise1 <span class="token operator">=</span> new MyPromise<span class="token variable"><span class="token punctuation">((</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
  fs.readFile<span class="token punctuation">(</span>'.<span class="token operator">/</span><span class="token number">001.</span>txt'<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
    if<span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span>{
      resolve<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    }else {
      reject<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    }
  }<span class="token punctuation">)</span>
}<span class="token punctuation">)</span><span class="token punctuation">;</span>

let x1 <span class="token operator">=</span> promise1.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> {
  console.log<span class="token punctuation">(</span>&quot;第一次展示&quot;<span class="token punctuation">,</span> data.toString<span class="token punctuation">(</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin class-name">let</span> x2 <span class="token operator">=</span> promise1.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;第二次展示&quot;</span>, data.toString<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin class-name">let</span> x3 <span class="token operator">=</span> promise1.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;第三次展示&quot;</span>, data.toString<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里我绑定了三个回调，想要在 resolve() 之后一起执行，那怎么办呢？</p> <p>需要将 onFulfilled 和 onRejected 改为数组，调用 resolve 时将其中的方法拿出来一一执行即可。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>self.onFulfilledCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
self.onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-bash extra-class"><pre class="language-bash"><code>MyPromise.prototype.then <span class="token operator">=</span> function<span class="token punctuation">(</span>onFulfilled, onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>this.status <span class="token operator">==</span><span class="token operator">=</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    this.onFulfilledCallbacks.push<span class="token punctuation">(</span>onFulfilled<span class="token punctuation">)</span><span class="token punctuation">;</span>
    this.onRejectedCallbacks.push<span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>this.status <span class="token operator">==</span><span class="token operator">=</span> FULFILLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    onFulfilled<span class="token punctuation">(</span>this.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    onRejected<span class="token punctuation">(</span>this.error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token builtin class-name">return</span> this<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>接下来将 resolve 和 reject 方法中执行回调的部分进行修改：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// resolve 中
self.onFulfilledCallbacks.forEach<span class="token variable"><span class="token punctuation">((</span>callback<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> callback<span class="token punctuation">(</span>self.value<span class="token punctuation">))</span></span><span class="token punctuation">;</span>
//reject 中
self.onRejectedCallbacks.forEach<span class="token variable"><span class="token punctuation">((</span>callback<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> callback<span class="token punctuation">(</span>self.error<span class="token punctuation">))</span></span><span class="token punctuation">;</span>
</code></pre></div><h3 id="链式调用完成"><a href="#链式调用完成" class="header-anchor">#</a> 链式调用完成</h3> <p>我们采用目前的代码来进行测试:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> fs <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> readFilePromise <span class="token operator">=</span> <span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> new MyPromise<span class="token variable"><span class="token punctuation">((</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
    fs.readFile<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
      if<span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span>{
        resolve<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      }else {
        reject<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
      }
    }<span class="token punctuation">)</span>
  }<span class="token punctuation">)</span>
}
readFilePromise<span class="token punctuation">(</span>'.<span class="token operator">/</span><span class="token number">001.</span>txt'<span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> {
  console.log<span class="token punctuation">(</span>data.toString<span class="token punctuation">(</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span>    
  <span class="token builtin class-name">return</span> readFilePromise<span class="token punctuation">(</span><span class="token string">'./002.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span>data.toString<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
// 001.txt的内容
// 001.txt的内容
</code></pre></div><p>咦？怎么打印了两个 001，第二次不是读的 002 文件吗？</p> <p>问题出在这里:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>MyPromise.prototype.then <span class="token operator">=</span> function<span class="token punctuation">(</span>onFulfilled, onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  //<span class="token punctuation">..</span>.
  <span class="token builtin class-name">return</span> this<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这么写每次返回的都是第一个 Promise。then 函数当中返回的第二个 Promise 直接被无视了！</p> <p>说明 then 当中的实现还需要改进, 我们现在需要对 then 中返回值重视起来。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>MyPromise.prototype.then <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>onFulfilled, onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> bridgePromise<span class="token punctuation">;</span>
  <span class="token builtin class-name">let</span> self <span class="token operator">=</span> this<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>self.status <span class="token operator">==</span><span class="token operator">=</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> bridgePromise <span class="token operator">=</span> new MyPromise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      self.onFulfilledCallbacks.push<span class="token punctuation">((</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        try <span class="token punctuation">{</span>
          // 看到了吗？要拿到 <span class="token keyword">then</span> 中回调返回的结果。
          <span class="token builtin class-name">let</span> x <span class="token operator">=</span> onFulfilled<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
          resolve<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          reject<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      self.onRejectedCallbacks.push<span class="token punctuation">((</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        try <span class="token punctuation">{</span>
          <span class="token builtin class-name">let</span> x <span class="token operator">=</span> onRejected<span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
          resolve<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          reject<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  //<span class="token punctuation">..</span>.
<span class="token punctuation">}</span>
</code></pre></div><p>假若当前状态为 PENDING，将回调数组中添加如上的函数，当 Promise 状态变化后，会遍历相应回调数组并执行回调。
但是这段程度还是存在一些问题:</p> <p>首先 then 中的两个参数不传的情况并没有处理，
假如 then 中的回调执行后返回的结果(也就是上面的x)是一个 Promise, 直接给 resolve 了，这是我们不希望看到的。</p> <p>怎么来解决这两个问题呢？
先对参数不传的情况做判断:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 成功回调不传给它一个默认函数
onFulfilled <span class="token operator">=</span> typeof onFulfilled <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;function&quot;</span> ? onFulfilled <span class="token builtin class-name">:</span> value <span class="token operator">=</span><span class="token operator">&gt;</span> value<span class="token punctuation">;</span>
// 对于失败回调直接抛错
onRejected <span class="token operator">=</span> typeof onRejected <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;function&quot;</span> ? onRejected <span class="token builtin class-name">:</span> error <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> throw error <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>然后对返回Promise的情况进行处理:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> resolvePromise<span class="token punctuation">(</span>bridgePromise, x, resolve, reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  //如果x是一个promise
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x instanceof MyPromise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    // 拆解这个 promise ，直到返回值不为 promise 为止
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x.status <span class="token operator">==</span><span class="token operator">=</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      x.then<span class="token punctuation">(</span>y <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        resolvePromise<span class="token punctuation">(</span>bridgePromise, y, resolve, reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>, error <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        reject<span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      x.then<span class="token punctuation">(</span>resolve, reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    // 非 Promise 的话直接 resolve 即可
    resolve<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后在 then 的方法实现中作如下修改:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>resolve<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  -<span class="token operator">&gt;</span>  resolvePromise<span class="token punctuation">(</span>bridgePromise, x, resolve, reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里大家好好体会一下拆解 Promise 的过程，其实不难理解，我要强调的是其中的递归调用始终传入的resolve和reject这两个参数是什么含义，其实他们控制的是最开始传入的bridgePromise的状态，这一点非常重要。
紧接着，我们实现一下当 Promise 状态不为 PENDING 时的逻辑。</p> <p>成功状态下调用then：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>self.status <span class="token operator">==</span><span class="token operator">=</span> FULFILLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> bridgePromise <span class="token operator">=</span> new MyPromise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    try <span class="token punctuation">{</span>
      // 状态变为成功，会有相应的 self.value
      <span class="token builtin class-name">let</span> x <span class="token operator">=</span> onFulfilled<span class="token punctuation">(</span>self.value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      // 暂时可以理解为 resolve<span class="token punctuation">(</span>x<span class="token punctuation">)</span>，后面具体实现中有拆解的过程
      resolvePromise<span class="token punctuation">(</span>bridgePromise, x, resolve, reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      reject<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>失败状态下调用then：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>self.status <span class="token operator">==</span><span class="token operator">=</span> REJECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> bridgePromise <span class="token operator">=</span> new MyPromise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    try <span class="token punctuation">{</span>
      // 状态变为失败，会有相应的 self.error
      <span class="token builtin class-name">let</span> x <span class="token operator">=</span> onRejected<span class="token punctuation">(</span>self.error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      resolvePromise<span class="token punctuation">(</span>bridgePromise, x, resolve, reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      reject<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Promise A+中规定成功和失败的回调都是微任务，由于浏览器中 JS 触碰不到底层微任务的分配，可以直接拿 setTimeout(属于宏任务的范畴) 来模拟，用 setTimeout将需要执行的任务包裹 ，当然，上面的 resolve 实现也是同理, 大家注意一下即可，其实并不是真正的微任务。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>self.status <span class="token operator">==</span><span class="token operator">=</span> FULFILLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> bridgePromise <span class="token operator">=</span> new MyPromise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      //<span class="token punctuation">..</span>.
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>self.status <span class="token operator">==</span><span class="token operator">=</span> REJECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> bridgePromise <span class="token operator">=</span> new MyPromise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      //<span class="token punctuation">..</span>.
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，到这里, 我们基本实现了 then 方法，现在我们拿刚刚的测试代码做一下测试, 依次打印如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>001.txt的内容
002.txt的内容
</code></pre></div><p>可以看到，已经可以顺利地完成链式调用。</p> <h3 id="错误捕获及冒泡机制分析"><a href="#错误捕获及冒泡机制分析" class="header-anchor">#</a> 错误捕获及冒泡机制分析</h3> <p>现在来实现 catch 方法:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Promise.prototype.catch <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> this.then<span class="token punctuation">(</span>null, onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对，就是这么几行，catch 原本就是 then 方法的语法糖。</p> <p>相比于实现来讲，更重要的是理解其中错误冒泡的机制，即中途一旦发生错误，可以在最后用 catch 捕获错误。</p> <p>我们回顾一下 Promise 的运作流程也不难理解，贴上一行关键的代码:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// <span class="token keyword">then</span> 的实现中
onRejected <span class="token operator">=</span> typeof onRejected <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;function&quot;</span> ? onRejected <span class="token builtin class-name">:</span> error <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> throw error <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>一旦其中有一个PENDING状态的 Promise 出现错误后状态必然会变为失败, 然后执行 onRejected函数，而这个 onRejected 执行又会抛错，把新的 Promise 状态变为失败，新的 Promise 状态变为失败后又会执行onRejected......就这样一直抛下去，直到用catch 捕获到这个错误，才停止往下抛。
这就是 Promise 的错误冒泡机制。
至此，Promise 三大法宝: <font color="#ff502c">回调函数延迟绑定、回调返回值穿透</font>和<font color="#ff502c">错误冒泡</font>。</p> <h2 id="第37篇-promise-之问-四-实现promise的-resolve、reject-和-finally"><a href="#第37篇-promise-之问-四-实现promise的-resolve、reject-和-finally" class="header-anchor">#</a> 第37篇: Promise 之问(四)——实现Promise的 resolve、reject 和 finally</h2> <h3 id="实现-promise-resolve"><a href="#实现-promise-resolve" class="header-anchor">#</a> 实现 Promise.resolve</h3> <p>实现 resolve 静态方法有三个要点:</p> <ul><li><p>1.传参为一个 Promise, 则直接返回它。</p></li> <li><p>2.传参为一个 thenable 对象，返回的 Promise 会跟随这个对象，采用它的最终状态作为自己的状态。</p></li> <li><p>3.其他情况，直接返回以该值为成功状态的promise对象。</p></li></ul> <p>具体实现如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Promise.resolve <span class="token operator">=</span> <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span>param instanceof Promise<span class="token punctuation">)</span> <span class="token builtin class-name">return</span> param<span class="token punctuation">;</span>
  <span class="token builtin class-name">return</span> new Promise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    if<span class="token punctuation">(</span>param <span class="token operator">&amp;&amp;</span> param.then <span class="token operator">&amp;&amp;</span> typeof param.then <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      // param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然
      param.then<span class="token punctuation">(</span>resolve, reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>else <span class="token punctuation">{</span>
      resolve<span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="实现-promise-reject"><a href="#实现-promise-reject" class="header-anchor">#</a> 实现 Promise.reject</h3> <p>Promise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Promise.reject <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> new Promise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        reject<span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="实现-promise-prototype-finally"><a href="#实现-promise-prototype-finally" class="header-anchor">#</a> 实现 Promise.prototype.finally</h3> <p>无论当前 Promise 是成功还是失败，调用finally之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Promise.prototype.finally <span class="token operator">=</span> function<span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this.then<span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> Promise.resolve<span class="token punctuation">(</span>callback<span class="token punctuation">(</span><span class="token punctuation">))</span>.then<span class="token variable"><span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
      return value<span class="token punctuation">;</span>
    }<span class="token punctuation">)</span>
  }<span class="token punctuation">,</span> error <span class="token operator">=</span><span class="token operator">&gt;</span> {
    return Promise.resolve<span class="token punctuation">(</span>callback<span class="token punctuation">(</span><span class="token punctuation">))</span></span>.then<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      throw error<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="第38篇-promise-之问-五-实现promise的-all-和-race"><a href="#第38篇-promise-之问-五-实现promise的-all-和-race" class="header-anchor">#</a> 第38篇: Promise 之问(五)——实现Promise的 all 和 race</h2> <p>实现 Promise.all
对于 all 方法而言，需要完成下面的核心功能:</p> <p>传入参数为一个空的可迭代对象，则直接进行resolve。
如果参数中有一个promise失败，那么Promise.all返回的promise对象失败。
在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</p> <p>具体实现如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Promise.all <span class="token operator">=</span> function<span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> new Promise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token builtin class-name">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token builtin class-name">let</span> len <span class="token operator">=</span> promises.length<span class="token punctuation">;</span>
    if<span class="token punctuation">(</span>len <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      resolve<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   
    for<span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      // 为什么不直接 promise<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.then, 因为promise<span class="token punctuation">[</span>i<span class="token punctuation">]</span>可能不是一个promise
      Promise.resolve<span class="token punctuation">(</span>promise<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>
        index++<span class="token punctuation">;</span>
        if<span class="token punctuation">(</span>index <span class="token operator">==</span><span class="token operator">=</span> len<span class="token punctuation">)</span> resolve<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>.catch<span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        reject<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="实现-promise-race"><a href="#实现-promise-race" class="header-anchor">#</a> 实现 Promise.race</h3> <p>race 的实现相比之下就简单一些，只要有一个 promise 执行完，直接 resolve 并停止执行。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Promise.race <span class="token operator">=</span> function<span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> new Promise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> len <span class="token operator">=</span> promises.length<span class="token punctuation">;</span>
    if<span class="token punctuation">(</span>len <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
    for<span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Promise.resolve<span class="token punctuation">(</span>promise<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        resolve<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>.catch<span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        reject<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>到此为止，一个完整的 Promise 就被我们实现完啦。从原理到细节，我们一步步拆解和实现，希望大家在知道 Promise 设计上的几大亮点之后，也能自己手动实现一个Promise，让自己的思维层次和动手能力更上一层楼！</p> <h2 id="第39篇-谈谈你对生成器以及协程的理解。"><a href="#第39篇-谈谈你对生成器以及协程的理解。" class="header-anchor">#</a> 第39篇: 谈谈你对生成器以及协程的理解。</h2> <p>生成器(Generator)是 ES6 中的新语法，相对于之前的异步语法，上手的难度还是比较大的。因此这里我们先来好好熟悉一下 Generator 语法。</p> <p>###生成器执行流程</p> <p>上面是生成器函数？
生成器是一个带星号的&quot;函数&quot;(注意：它并不是真正的函数)，可以通过yield关键字暂停执行和恢复执行的
举个例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>function* <span class="token function-name function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;enter&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin class-name">let</span> a <span class="token operator">=</span> yield <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin class-name">let</span> b <span class="token operator">=</span> yield <span class="token punctuation">(</span><span class="token function-name function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>return <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin class-name">return</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
var g <span class="token operator">=</span> gen<span class="token punctuation">(</span><span class="token punctuation">)</span> // 阻塞住，不会执行任何语句
console.log<span class="token punctuation">(</span>typeof g<span class="token punctuation">)</span>  // object  看到了吗？不是<span class="token string">&quot;function&quot;</span>

console.log<span class="token punctuation">(</span>g.next<span class="token punctuation">(</span><span class="token punctuation">))</span>  
console.log<span class="token punctuation">(</span>g.next<span class="token punctuation">(</span><span class="token punctuation">))</span>  
console.log<span class="token punctuation">(</span>g.next<span class="token punctuation">(</span><span class="token punctuation">))</span>  
console.log<span class="token punctuation">(</span>g.next<span class="token punctuation">(</span><span class="token punctuation">))</span> 


// enter
// <span class="token punctuation">{</span> value: <span class="token number">1</span>, done: <span class="token boolean">false</span> <span class="token punctuation">}</span>

// <span class="token punctuation">{</span> value: <span class="token number">2</span>, done: <span class="token boolean">false</span> <span class="token punctuation">}</span>
// <span class="token punctuation">{</span> value: <span class="token number">3</span>, done: <span class="token boolean">true</span> <span class="token punctuation">}</span>
// <span class="token punctuation">{</span> value: undefined, done: <span class="token boolean">true</span> <span class="token punctuation">}</span>
</code></pre></div><p>由此可以看到，生成器的执行有这样几个关键点:</p> <p>调用 gen() 后，程序会阻塞住，不会执行任何语句。
调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停。
next 方法返回一个对象， 有两个属性: value 和 done。value 为当前 yield 后面的结果，done 表示是否执行完，遇到了return 后，done 会由false变为true。</p> <h3 id="yield"><a href="#yield" class="header-anchor">#</a> yield*</h3> <p>当一个生成器要调用另一个生成器时，使用 yield* 就变得十分方便。比如下面的例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>function* <span class="token function-name function">gen1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    yield <span class="token number">1</span><span class="token punctuation">;</span>
    yield <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
function* <span class="token function-name function">gen2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    yield <span class="token number">2</span><span class="token punctuation">;</span>
    yield <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>我们想要按照1234的顺序执行，如何来做呢？</p> <p>在 gen1 中，修改如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>function* <span class="token function-name function">gen1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    yield <span class="token number">1</span><span class="token punctuation">;</span>
    yield* gen2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    yield <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>这样修改之后，之后依次调用next即可。</p> <h3 id="生成器实现机制-协程"><a href="#生成器实现机制-协程" class="header-anchor">#</a> 生成器实现机制——协程</h3> <p>可能你会比较好奇，生成器究竟是如何让函数暂停, 又会如何恢复的呢？接下来我们就来对其中的执行机制——协程一探究竟。</p> <h4 id="什么是协程"><a href="#什么是协程" class="header-anchor">#</a> 什么是协程？</h4> <p>协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。</p> <h4 id="协程的运作过程"><a href="#协程的运作过程" class="header-anchor">#</a> 协程的运作过程</h4> <p>那你可能要问了，JS 不是单线程执行的吗，开这么多协程难道可以一起执行吗？
答案是：并不能。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将 JS 线程的控制权转交给 B协程，那么现在 B 执行，A 就相当于处于暂停的状态。
举个具体的例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>function* <span class="token function-name function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;我是A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  yield B<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // A停住，在这里转交线程执行权给B
  console.log<span class="token punctuation">(</span><span class="token string">&quot;结束了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function-name function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token string">&quot;我是B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin class-name">return</span> <span class="token number">100</span><span class="token punctuation">;</span>// 返回，并且将线程执行权还给A
<span class="token punctuation">}</span>
<span class="token builtin class-name">let</span> gen <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
gen.next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
gen.next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

// 我是A
// 我是B
// 结束了
</code></pre></div><p>在这个过程中，A 将执行权交给 B，也就是 A 启动 B，我们也称 A 是 B 的父协程。因此 B 当中最后return 100其实是将 100 传给了父协程。
需要强调的是，对于协程来说，它并不受操作系统的控制，完全由用户自定义切换，因此并没有进程/线程上下文切换的开销，这是高性能的重要原因。
OK, 原理就说到这里。可能你还会有疑问: 这个生成器不就暂停-恢复、暂停-恢复这样执行的吗？它和异步有什么关系？而且，每次执行都要调用next，能不能让它一次性执行完毕呢？下一节我们就来仔细拆解这些问题。</p> <h2 id="第40篇-如何让-generator-的异步代码按顺序执行完毕"><a href="#第40篇-如何让-generator-的异步代码按顺序执行完毕" class="header-anchor">#</a> 第40篇: 如何让 Generator 的异步代码按顺序执行完毕？</h2> <p>这里面其实有两个问题:</p> <ul><li>1.Generator 如何跟异步产生关系？</li> <li>2.怎么把 Generator 按顺序执行完毕？</li></ul> <h3 id="thunk-函数"><a href="#thunk-函数" class="header-anchor">#</a> thunk 函数</h3> <p>要想知道 Generator 跟异步的关系，首先带大家搞清楚一个概念——thunk函数(即偏函数)，虽然这只是实现两者关系的方式之一。(另一种方式是Promise, 后面会讲到)
举个例子，比如我们现在要判断数据类型。可以写如下的判断逻辑:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> isString <span class="token operator">=</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> Object.prototype.toString.call<span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'[object String]'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> isFunction <span class="token operator">=</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> Object.prototype.toString.call<span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'[object Function]'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> isArray <span class="token operator">=</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> Object.prototype.toString.call<span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'[object Array]'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> isSet <span class="token operator">=</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> Object.prototype.toString.call<span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'[object Set]'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
// <span class="token punctuation">..</span>.
</code></pre></div><p>可以看到，出现了非常多重复的逻辑。我们将它们做一下封装:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> isType <span class="token operator">=</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">return</span> Object.prototype.toString.call<span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token variable"><span class="token variable">`</span><span class="token punctuation">[</span>object $<span class="token punctuation">{</span>type<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token variable">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们这样做即可:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> isString <span class="token operator">=</span> isType<span class="token punctuation">(</span><span class="token string">'String'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> isFunction <span class="token operator">=</span> isType<span class="token punctuation">(</span><span class="token string">'Function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//<span class="token punctuation">..</span>.
</code></pre></div><p>相应的 isString和isFunction是由isType生产出来的函数，但它们依然可以判断出参数是否为String（Function），而且代码简洁了不少。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>isString<span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
isFunction<span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">&gt;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>isType这样的函数我们称为thunk 函数。它的核心逻辑是接收一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能。thunk函数的实现会比单个的判断函数复杂一点点，但就是这一点点的复杂，大大方便了后续的操作。</p> <h3 id="generator-和-异步"><a href="#generator-和-异步" class="header-anchor">#</a> Generator 和 异步</h3> <h4 id="thunk-版本"><a href="#thunk-版本" class="header-anchor">#</a> thunk 版本</h4> <p>以文件操作为例，我们来看看 异步操作 如何应用于Generator。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const readFileThunk <span class="token operator">=</span> <span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    fs.readFile<span class="token punctuation">(</span>filename, callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>readFileThunk就是一个thunk函数。异步操作核心的一环就是绑定回调函数，而thunk函数可以帮我们做到。首先传入文件名，然后生成一个针对某个文件的定制化函数。这个函数中传入回调，这个回调就会成为异步操作的回调。这样就让 Generator 和异步关联起来了。
紧接者我们做如下的操作:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const gen <span class="token operator">=</span> function* <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const data1 <span class="token operator">=</span> yield readFileThunk<span class="token punctuation">(</span><span class="token string">'001.txt'</span><span class="token punctuation">)</span>
  console.log<span class="token punctuation">(</span>data1.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>
  const data2 <span class="token operator">=</span> yield readFileThunk<span class="token punctuation">(</span><span class="token string">'002.txt'</span><span class="token punctuation">)</span>
  console.log<span class="token punctuation">(</span>data2.toString<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着我们让它执行完:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> g <span class="token operator">=</span> gen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
// 第一步: 由于进场是暂停的，我们调用next，让它开始执行。
// next返回值中有一个value值，这个value是yield后面的结果，放在这里也就是是thunk函数生成的定制化函数，里面需要传一个回调函数作为参数
g.next<span class="token punctuation">(</span><span class="token punctuation">)</span>.value<span class="token punctuation">((</span>err, data1<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  // 第二步: 拿到上一次得到的结果，调用next, 将结果作为参数传入，程序继续执行。
  // 同理，value传入回调
  g.next<span class="token punctuation">(</span>data1<span class="token punctuation">)</span>.value<span class="token punctuation">((</span>err, data2<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    g.next<span class="token punctuation">(</span>data2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>打印结果如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>001.txt的内容
002.txt的内容
</code></pre></div><p>上面嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可操作性不强，有必要把执行的代码封装一下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> run<span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">{</span>
  const next <span class="token operator">=</span> <span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> res <span class="token operator">=</span> gen.next<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    if<span class="token punctuation">(</span>res.done<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
    res.value<span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
run<span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Ok,再次执行，依然打印正确的结果。代码虽然就这么几行，但包含了递归的过程，好好体会一下。</p> <p>这是通过thunk完成异步操作的情况。</p> <h4 id="promise-版本"><a href="#promise-版本" class="header-anchor">#</a> Promise 版本</h4> <p>还是拿上面的例子，用Promise来实现就轻松一些:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const readFilePromise <span class="token operator">=</span> <span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> new Promise<span class="token variable"><span class="token punctuation">((</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
    fs.readFile<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> {
      if<span class="token punctuation">(</span>err<span class="token punctuation">)</span> {
        reject<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
      }else {
        resolve<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      }
    }<span class="token punctuation">)</span>
  }<span class="token punctuation">)</span>.then<span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">&gt;</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
}
const gen <span class="token operator">=</span> function<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> {
  const data1 <span class="token operator">=</span> yield readFilePromise<span class="token punctuation">(</span>'<span class="token number">001.</span>txt'<span class="token punctuation">)</span>
  console.log<span class="token punctuation">(</span>data1.toString<span class="token punctuation">(</span><span class="token punctuation">))</span></span>
  const data2 <span class="token operator">=</span> yield readFilePromise<span class="token punctuation">(</span><span class="token string">'002.txt'</span><span class="token punctuation">)</span>
  console.log<span class="token punctuation">(</span>data2.toString<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行的代码如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> g <span class="token operator">=</span> gen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> getGenPromise<span class="token punctuation">(</span>gen, data<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token builtin class-name">return</span> gen.next<span class="token punctuation">(</span>data<span class="token punctuation">)</span>.value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
getGenPromise<span class="token punctuation">(</span>g<span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data1 <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> getGenPromise<span class="token punctuation">(</span>g, data1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>data2 <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> getGenPromise<span class="token punctuation">(</span>g, data2<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>打印结果如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>001.txt的内容
002.txt的内容
</code></pre></div><p>同样，我们可以对执行Generator的代码加以封装:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">function</span> run<span class="token punctuation">(</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const next <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> res <span class="token operator">=</span> g.next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    if<span class="token punctuation">(</span>res.done<span class="token punctuation">)</span> <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
    res.value.then<span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
      next<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同样能输出正确的结果。代码非常精炼，希望能参照刚刚链式调用的例子，仔细体会一下递归调用的过程。</p> <h3 id="采用-co-库"><a href="#采用-co-库" class="header-anchor">#</a> 采用 co 库</h3> <p>以上我们针对 thunk 函数和Promise两种Generator异步操作的一次性执行完毕做了封装，但实际场景中已经存在成熟的工具包了，如果大名鼎鼎的co库, 其实核心原理就是我们已经手写过了（就是刚刚封装的Promise情况下的执行代码），只不过源码会各种边界情况做了处理。使用起来非常简单:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>const co <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'co'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> g <span class="token operator">=</span> gen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
co<span class="token punctuation">(</span>g<span class="token punctuation">)</span>.then<span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>打印结果如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>001.txt的内容
002.txt的内容
<span class="token number">100</span>
</code></pre></div><p>简单几行代码就完成了Generator所有的操作，真不愧co和Generator天生一对啊！</p> <h2 id="第41篇-解释一下async-await的运行机制。"><a href="#第41篇-解释一下async-await的运行机制。" class="header-anchor">#</a> 第41篇: 解释一下async/await的运行机制。</h2> <p>async/await被称为 JS 中异步终极解决方案。它既能够像 co + Generator 一样用同步的方式来书写异步代码，又得到底层的语法支持，无需借助任何第三方库。接下来，我们从原理的角度来重新审视这个语法糖背后究竟做了些什么。</p> <h3 id="async"><a href="#async" class="header-anchor">#</a> async</h3> <p>什么是 async ?</p> <div class="language-bash extra-class"><pre class="language-bash"><code>MDN 的定义: async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。
</code></pre></div><p>注意重点: 返回结果为Promise。</p> <p>举个例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>async <span class="token keyword">function</span> <span class="token function-name function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">return</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console.log<span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
// Promise <span class="token punctuation">{</span><span class="token operator">&lt;</span>resolved<span class="token operator">&gt;</span>: <span class="token number">100</span><span class="token punctuation">}</span>
</code></pre></div><p>这就是隐式返回 Promise 的效果。</p> <h3 id="await"><a href="#await" class="header-anchor">#</a> await</h3> <p>我们来看看 await做了些什么事情。</p> <p>以一段代码为例:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>async <span class="token keyword">function</span> <span class="token function-name function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
  <span class="token builtin class-name">let</span> x <span class="token operator">=</span> await <span class="token number">200</span>
  console.log<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
  console.log<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console.log<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
test<span class="token punctuation">(</span><span class="token punctuation">)</span>
console.log<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span>
</code></pre></div><p>我们来分析一下这段程序。首先代码同步执行，打印出0，然后将test压入执行栈，打印出100, 下面注意了，遇到了关键角色await。</p> <p>放个慢镜头:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>await <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre></div><p>被 JS 引擎转换成一个 Promise :</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> promise <span class="token operator">=</span> new Promise<span class="token punctuation">((</span>resolve,reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
   resolve<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这里调用了 resolve，resolve的任务进入微任务队列。
然后，JS 引擎将暂停当前协程的运行，把线程的执行权交给父协程(父协程不懂是什么的，上上篇才讲，回去补课)。
回到父协程中，父协程的第一件事情就是对await返回的Promise调用then, 来监听这个 Promise 的状态改变 。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>promise.then<span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  // 相关逻辑，在resolve 执行之后来调用
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>然后往下执行，打印出300。</p> <p>根据EventLoop机制，当前主线程的宏任务完成，现在检查微任务队列, 发现还有一个Promise的 resolve，执行，现在父协程在then中传入的回调执行。我们来看看这个回调具体做的是什么。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>promise.then<span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  // <span class="token number">1</span>. 将线程的执行权交给test协程
  // <span class="token number">2</span>. 把 value 值传递给 <span class="token builtin class-name">test</span> 协程
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Ok, 现在执行权到了test协程手上，test 接收到父协程传来的200, 赋值给 a ,然后依次执行后面的语句，打印200、200。</p> <p>最后的输出为:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">0</span>
<span class="token number">100</span>
<span class="token number">300</span>
<span class="token number">200</span>
<span class="token number">200</span>
</code></pre></div><p>总结一下，async/await利用协程和Promise实现了同步方式编写异步代码的效果，其中Generator是对协程的一种实现，虽然语法简单，但引擎在背后做了大量的工作，我们也对这些工作做了一一的拆解。用async/await写出的代码也更加优雅、美观，相比于之前的Promise不断调用then的方式，语义化更加明显，相比于co + Generator性能更高，上手成本也更低，不愧是JS异步终极解决方案！</p> <h2 id="第42篇-foreach-中用-await-会产生什么问题-怎么解决这个问题"><a href="#第42篇-foreach-中用-await-会产生什么问题-怎么解决这个问题" class="header-anchor">#</a> 第42篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？</h2> <h3 id="问题-2"><a href="#问题-2" class="header-anchor">#</a> 问题</h3> <p>问题:对于异步代码，forEach 并不能保证按顺序执行。</p> <p>举个例子:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>async <span class="token keyword">function</span> <span class="token function-name function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">2</span>, <span class="token number">1</span><span class="token punctuation">]</span>
	arr.forEach<span class="token punctuation">(</span>async item <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
		const res <span class="token operator">=</span> await handle<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
		console.log<span class="token punctuation">(</span>res<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
	console.log<span class="token punctuation">(</span><span class="token string">'结束'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> handle<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">return</span> new Promise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
		setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
			resolve<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>, <span class="token number">1000</span> * x<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

test<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>我们期望的结果是:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">4</span> 
<span class="token number">2</span> 
<span class="token number">1</span>
结束
</code></pre></div><p>但是实际上会输出:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>结束
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">4</span>
</code></pre></div><h3 id="问题原因"><a href="#问题原因" class="header-anchor">#</a> 问题原因</h3> <p>这是为什么呢？我想我们有必要看看forEach底层怎么实现的。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>// 核心逻辑
<span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    var element <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    callback<span class="token punctuation">(</span>element, i, array<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，forEach 拿过来直接执行了，这就导致它无法保证异步任务的执行顺序。比如后面的任务用时短，那么就又可能抢在前面的任务之前执行。</p> <h3 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h3> <p>如何来解决这个问题呢？</p> <p>其实也很简单, 我们利用for...of就能轻松解决。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>async <span class="token keyword">function</span> <span class="token function-name function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">2</span>, <span class="token number">1</span><span class="token punctuation">]</span>
  for<span class="token punctuation">(</span>const item of arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	const res <span class="token operator">=</span> await handle<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
	console.log<span class="token punctuation">(</span>res<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
	console.log<span class="token punctuation">(</span><span class="token string">'结束'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="解决原理-iterator"><a href="#解决原理-iterator" class="header-anchor">#</a> 解决原理——Iterator</h3> <p>好了，这个问题看起来好像很简单就能搞定，你有想过这么做为什么可以成功吗？
其实，for...of并不像forEach那么简单粗暴的方式去遍历执行，而是采用一种特别的手段——迭代器去遍历。
首先，对于数组来讲，它是一种可迭代数据类型。那什么是可迭代数据类型呢？</p> <div class="language-bash extra-class"><pre class="language-bash"><code>原生具有<span class="token punctuation">[</span>Symbol.iterator<span class="token punctuation">]</span>属性数据类型为可迭代数据类型。如数组、类数组（如arguments、NodeList）、Set和Map。
</code></pre></div><p>可迭代对象可以通过迭代器进行遍历。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">2</span>, <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
// 这就是迭代器
<span class="token builtin class-name">let</span> iterator <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol.iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>iterator.next<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>iterator.next<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>iterator.next<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>iterator.next<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>


// <span class="token punctuation">{</span>value: <span class="token number">4</span>, done: false<span class="token punctuation">}</span>
// <span class="token punctuation">{</span>value: <span class="token number">2</span>, done: false<span class="token punctuation">}</span>
// <span class="token punctuation">{</span>value: <span class="token number">1</span>, done: false<span class="token punctuation">}</span>
// <span class="token punctuation">{</span>value: undefined, done: true<span class="token punctuation">}</span>
</code></pre></div><p>因此，我们的代码可以这样来组织:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>async <span class="token keyword">function</span> <span class="token function-name function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">2</span>, <span class="token number">1</span><span class="token punctuation">]</span>
  <span class="token builtin class-name">let</span> iterator <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol.iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin class-name">let</span> res <span class="token operator">=</span> iterator.next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  while<span class="token punctuation">(</span><span class="token operator">!</span>res.done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin class-name">let</span> value <span class="token operator">=</span> res.value<span class="token punctuation">;</span>
    console.log<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    await handle<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res <span class="token operator">=</span> iterater.next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	console.log<span class="token punctuation">(</span><span class="token string">'结束'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
// <span class="token number">4</span>
// <span class="token number">2</span>
// <span class="token number">1</span>
// 结束
</code></pre></div><p>多个任务成功地按顺序执行！其实刚刚的for...of循环代码就是这段代码的语法糖。</p> <h3 id="重新认识生成器"><a href="#重新认识生成器" class="header-anchor">#</a> 重新认识生成器</h3> <p>回头再看看用iterator遍历[4,2,1]这个数组的代码。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">2</span>, <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
// 迭代器
<span class="token builtin class-name">let</span> iterator <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol.iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>iterator.next<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>iterator.next<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>iterator.next<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>iterator.next<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>


// <span class="token punctuation">{</span>value: <span class="token number">4</span>, done: false<span class="token punctuation">}</span>
// <span class="token punctuation">{</span>value: <span class="token number">2</span>, done: false<span class="token punctuation">}</span>
// <span class="token punctuation">{</span>value: <span class="token number">1</span>, done: false<span class="token punctuation">}</span>
// <span class="token punctuation">{</span>value: undefined, done: true<span class="token punctuation">}</span>
</code></pre></div><p>咦？返回值有value和done属性，生成器也可以调用 next,返回的也是这样的数据结构，这么巧?!</p> <p>没错，生成器本身就是一个迭代器。</p> <p>既然属于迭代器，那它就可以用for...of遍历了吧？</p> <p>当然没错，不信来写一个简单的斐波那契数列(50以内)：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>function* <span class="token function-name function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token builtin class-name">let</span> <span class="token punctuation">[</span>prev, cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span>, <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  console.log<span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
  while<span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>prev, cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>cur, prev + cur<span class="token punctuation">]</span><span class="token punctuation">;</span>
    yield cur<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

for<span class="token punctuation">(</span>let item of fibonacci<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>
  if<span class="token punctuation">(</span>item <span class="token operator">&gt;</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token builtin class-name">break</span><span class="token punctuation">;</span>
  console.log<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
// <span class="token number">1</span>
// <span class="token number">1</span>
// <span class="token number">2</span>
// <span class="token number">3</span>
// <span class="token number">5</span>
// <span class="token number">8</span>
// <span class="token number">13</span>
// <span class="token number">21</span>
// <span class="token number">34</span>
</code></pre></div><p>是不是非常酷炫？这就是迭代器的魅力：）同时又对生成器有了更深入的理解，没想到我们的老熟人Generator还有这样的身份。</p> <p>以上便是本文的全部内容，希望对你有所启发。</p> <p><font color="#ff502c">申明：此篇文章转载于</font><a href="https://juejin.im/post/6844904004007247880" target="_blank" rel="noopener noreferrer">此处<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><font color="#ff502c">，如有侵权，请联系删除，谢谢！</font></p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第24篇-javascript内存机制之问-数据是如何存储的" class="sidebar-link reco-side-第24篇-javascript内存机制之问-数据是如何存储的" data-v-b57cc07c>第24篇: JavaScript内存机制之问——数据是如何存储的？</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第25篇-v8-引擎如何进行垃圾内存的回收" class="sidebar-link reco-side-第25篇-v8-引擎如何进行垃圾内存的回收" data-v-b57cc07c>第25篇：V8 引擎如何进行垃圾内存的回收？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#v8-内存限制" class="sidebar-link reco-side-v8-内存限制" data-v-b57cc07c>V8 内存限制</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#新生代内存的回收" class="sidebar-link reco-side-新生代内存的回收" data-v-b57cc07c>新生代内存的回收</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#老生代内存的回收" class="sidebar-link reco-side-老生代内存的回收" data-v-b57cc07c>老生代内存的回收</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#增量标记" class="sidebar-link reco-side-增量标记" data-v-b57cc07c>增量标记</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第26篇-描述一下-v8-执行一段js代码的过程" class="sidebar-link reco-side-第26篇-描述一下-v8-执行一段js代码的过程" data-v-b57cc07c>第26篇: 描述一下 V8 执行一段JS代码的过程？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#_1-生成-ast" class="sidebar-link reco-side-_1-生成-ast" data-v-b57cc07c>1.生成 AST</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#_2-生成字节码" class="sidebar-link reco-side-_2-生成字节码" data-v-b57cc07c>2. 生成字节码</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第28篇-如何理解eventloop-宏任务和微任务篇" class="sidebar-link reco-side-第28篇-如何理解eventloop-宏任务和微任务篇" data-v-b57cc07c>第28篇：如何理解EventLoop——宏任务和微任务篇</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#宏任务-macrotask-引入" class="sidebar-link reco-side-宏任务-macrotask-引入" data-v-b57cc07c>宏任务(MacroTask)引入</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#微任务-microtask-引入" class="sidebar-link reco-side-微任务-microtask-引入" data-v-b57cc07c>微任务(MicroTask)引入</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第29篇-如何理解eventloop-浏览器篇" class="sidebar-link reco-side-第29篇-如何理解eventloop-浏览器篇" data-v-b57cc07c>第29篇: 如何理解EventLoop——浏览器篇</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第30篇-如何理解eventloop-nodejs篇" class="sidebar-link reco-side-第30篇-如何理解eventloop-nodejs篇" data-v-b57cc07c>第30篇: 如何理解EventLoop——nodejs篇</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#_1-三大关键阶段" class="sidebar-link reco-side-_1-三大关键阶段" data-v-b57cc07c>1. 三大关键阶段</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#_2-完善" class="sidebar-link reco-side-_2-完善" data-v-b57cc07c>2. 完善</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#_3-实例演示" class="sidebar-link reco-side-_3-实例演示" data-v-b57cc07c>3. 实例演示</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#_4-nodejs-和-浏览器关于eventloop的主要区别" class="sidebar-link reco-side-_4-nodejs-和-浏览器关于eventloop的主要区别" data-v-b57cc07c>4.nodejs 和 浏览器关于eventLoop的主要区别</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#_5-关于process-nexttick的一点说明" class="sidebar-link reco-side-_5-关于process-nexttick的一点说明" data-v-b57cc07c>5.关于process.nextTick的一点说明</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第31篇-nodejs中的异步、非阻塞i-o是如何实现的" class="sidebar-link reco-side-第31篇-nodejs中的异步、非阻塞i-o是如何实现的" data-v-b57cc07c>第31篇: nodejs中的异步、非阻塞I/O是如何实现的？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#什么是i-o" class="sidebar-link reco-side-什么是i-o" data-v-b57cc07c>什么是I/O？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#阻塞和非阻塞i-o" class="sidebar-link reco-side-阻塞和非阻塞i-o" data-v-b57cc07c>阻塞和非阻塞I/O</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#异步-i-o-的本质" class="sidebar-link reco-side-异步-i-o-的本质" data-v-b57cc07c>异步 I/O 的本质</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第32篇-js异步编程有哪些方案-为什么会出现这些方案" class="sidebar-link reco-side-第32篇-js异步编程有哪些方案-为什么会出现这些方案" data-v-b57cc07c>第32篇：JS异步编程有哪些方案？为什么会出现这些方案？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#回调函数时代" class="sidebar-link reco-side-回调函数时代" data-v-b57cc07c>回调函数时代</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#promise-时代" class="sidebar-link reco-side-promise-时代" data-v-b57cc07c>Promise 时代</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#co-generator-方式" class="sidebar-link reco-side-co-generator-方式" data-v-b57cc07c>co + Generator 方式</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第33篇-能不能简单实现一下-node-中回调函数的机制" class="sidebar-link reco-side-第33篇-能不能简单实现一下-node-中回调函数的机制" data-v-b57cc07c>第33篇: 能不能简单实现一下 node 中回调函数的机制？</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第34篇-promise之问-一-promise-凭借什么消灭了回调地狱" class="sidebar-link reco-side-第34篇-promise之问-一-promise-凭借什么消灭了回调地狱" data-v-b57cc07c>第34篇: Promise之问(一)——Promise 凭借什么消灭了回调地狱？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#问题" class="sidebar-link reco-side-问题" data-v-b57cc07c>问题</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#解决方法" class="sidebar-link reco-side-解决方法" data-v-b57cc07c>解决方法</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第35篇-promise之问-二-为什么promise要引入微任务" class="sidebar-link reco-side-第35篇-promise之问-二-为什么promise要引入微任务" data-v-b57cc07c>第35篇: Promise之问(二)——为什么Promise要引入微任务？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#解决方式" class="sidebar-link reco-side-解决方式" data-v-b57cc07c>解决方式</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#优劣对比" class="sidebar-link reco-side-优劣对比" data-v-b57cc07c>优劣对比</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第36篇-promise之问-三-promise-如何实现链式调用" class="sidebar-link reco-side-第36篇-promise之问-三-promise-如何实现链式调用" data-v-b57cc07c>第36篇: Promise之问(三)——Promise 如何实现链式调用？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#简易版实现" class="sidebar-link reco-side-简易版实现" data-v-b57cc07c>简易版实现</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#设置回调数组" class="sidebar-link reco-side-设置回调数组" data-v-b57cc07c>设置回调数组</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#链式调用完成" class="sidebar-link reco-side-链式调用完成" data-v-b57cc07c>链式调用完成</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#错误捕获及冒泡机制分析" class="sidebar-link reco-side-错误捕获及冒泡机制分析" data-v-b57cc07c>错误捕获及冒泡机制分析</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第37篇-promise-之问-四-实现promise的-resolve、reject-和-finally" class="sidebar-link reco-side-第37篇-promise-之问-四-实现promise的-resolve、reject-和-finally" data-v-b57cc07c>第37篇: Promise 之问(四)——实现Promise的 resolve、reject 和 finally</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#实现-promise-resolve" class="sidebar-link reco-side-实现-promise-resolve" data-v-b57cc07c>实现 Promise.resolve</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#实现-promise-reject" class="sidebar-link reco-side-实现-promise-reject" data-v-b57cc07c>实现 Promise.reject</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#实现-promise-prototype-finally" class="sidebar-link reco-side-实现-promise-prototype-finally" data-v-b57cc07c>实现 Promise.prototype.finally</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第38篇-promise-之问-五-实现promise的-all-和-race" class="sidebar-link reco-side-第38篇-promise-之问-五-实现promise的-all-和-race" data-v-b57cc07c>第38篇: Promise 之问(五)——实现Promise的 all 和 race</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#实现-promise-race" class="sidebar-link reco-side-实现-promise-race" data-v-b57cc07c>实现 Promise.race</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第39篇-谈谈你对生成器以及协程的理解。" class="sidebar-link reco-side-第39篇-谈谈你对生成器以及协程的理解。" data-v-b57cc07c>第39篇: 谈谈你对生成器以及协程的理解。</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#yield" class="sidebar-link reco-side-yield" data-v-b57cc07c>yield*</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#生成器实现机制-协程" class="sidebar-link reco-side-生成器实现机制-协程" data-v-b57cc07c>生成器实现机制——协程</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第40篇-如何让-generator-的异步代码按顺序执行完毕" class="sidebar-link reco-side-第40篇-如何让-generator-的异步代码按顺序执行完毕" data-v-b57cc07c>第40篇: 如何让 Generator 的异步代码按顺序执行完毕？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#thunk-函数" class="sidebar-link reco-side-thunk-函数" data-v-b57cc07c>thunk 函数</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#generator-和-异步" class="sidebar-link reco-side-generator-和-异步" data-v-b57cc07c>Generator 和 异步</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#采用-co-库" class="sidebar-link reco-side-采用-co-库" data-v-b57cc07c>采用 co 库</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第41篇-解释一下async-await的运行机制。" class="sidebar-link reco-side-第41篇-解释一下async-await的运行机制。" data-v-b57cc07c>第41篇: 解释一下async/await的运行机制。</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#async" class="sidebar-link reco-side-async" data-v-b57cc07c>async</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#await" class="sidebar-link reco-side-await" data-v-b57cc07c>await</a></li><li class="level-2" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#第42篇-foreach-中用-await-会产生什么问题-怎么解决这个问题" class="sidebar-link reco-side-第42篇-foreach-中用-await-会产生什么问题-怎么解决这个问题" data-v-b57cc07c>第42篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#问题-2" class="sidebar-link reco-side-问题-2" data-v-b57cc07c>问题</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#问题原因" class="sidebar-link reco-side-问题原因" data-v-b57cc07c>问题原因</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#解决方案" class="sidebar-link reco-side-解决方案" data-v-b57cc07c>解决方案</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#解决原理-iterator" class="sidebar-link reco-side-解决原理-iterator" data-v-b57cc07c>解决原理——Iterator</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepress-blog/blogs/JavaScript-03.html#重新认识生成器" class="sidebar-link reco-side-重新认识生成器" data-v-b57cc07c>重新认识生成器</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/media/starsky.m4a" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:20px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/media/starsky.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/media/starsky.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>Star Sky</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>Two Steps From Hell</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/vuepress-blog/assets/js/app.d7c20d16.js" defer></script><script src="/vuepress-blog/assets/js/7.52cd3cfd.js" defer></script><script src="/vuepress-blog/assets/js/2.5e77f0d2.js" defer></script><script src="/vuepress-blog/assets/js/1.c3e4b76d.js" defer></script><script src="/vuepress-blog/assets/js/24.6e5b88ce.js" defer></script>
  </body>
</html>
